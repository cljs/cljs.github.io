<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Book</title>
  <meta name="description" content="The Clojure to JavaScript compiler.
">

  <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,300,300italic,400italic,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://cljsinfo.github.io/book/">
  <link rel="alternate" type="application/rss+xml" title="ClojureScript" href="http://cljsinfo.github.io/feed.xml" />

  <link rel="apple-touch-icon" sizes="57x57" href="/img/icons/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/img/icons/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/img/icons/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/img/icons/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/img/icons/apple-touch-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/img/icons/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/icons/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/img/icons/apple-touch-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/img/icons/apple-touch-icon-180x180.png">
  <link rel="icon" type="image/png" href="/img/icons/favicon-192x192.png" sizes="192x192">
  <link rel="icon" type="image/png" href="/img/icons/favicon-160x160.png" sizes="160x160">
  <link rel="icon" type="image/png" href="/img/icons/favicon-96x96.png" sizes="96x96">
  <link rel="icon" type="image/png" href="/img/icons/favicon-16x16.png" sizes="16x16">
  <link rel="icon" type="image/png" href="/img/icons/favicon-32x32.png" sizes="32x32">
</head>


  <body>
    <div class="container">

      <header class="site-header">

  <div class="wrapper">

    <a href="/"><img class="logo" src="/img/logo-light.svg"></a>

    <div class="title-block">
      <div class="title">ClojureScript</div>
      <div class="subtitle">early website draft</div>
    </div>

    <nav class="site-nav">
      <a class="page-link " href="/about">About</a>
      <a class="page-link active" href="/docs">Docs</a>
      <a class="page-link " href="/news">News</a>
      <a class="page-link " href="/community">Community</a>
    </nav>

    <nav class="site-nav-ext">
      <a class="page-link-ext" href="https://github.com/clojure/clojurescript">GitHub</a>
      <a class="page-link-ext" href="http://dev.clojure.org/jira/browse/CLJS">Jira</a>
      <a class="page-link-ext" href="http://clojure.org">Clo<i>j</i>ure <img width="24px" src="/img/clojure-icon.gif"></a>

    </nav>

  </div>

</header>


      <div class="wrapper nosidebar pageContent">
  <div class="inner-content">

    <article class="post-content">
      <h1>ClojureScript Unraveled</h1>
<div id="preamble">
<div class="sectionbody">
<div id="toc" class="toc">
<div id="toctitle" class="title">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#about-this-book">1. About this book</a></li>
<li><a href="#introduction">2. Introduction</a></li>
<li><a href="#language-the-basics">3. Language (the basics)</a>
<ul class="sectlevel2">
<li><a href="#first-steps-with-lisp-syntax">3.1. First steps with Lisp syntax</a></li>
<li><a href="#the-base-data-types">3.2. The base data types</a></li>
<li><a href="#vars">3.3. Vars</a></li>
<li><a href="#function-section">3.4. Functions</a></li>
<li><a href="#flow-control">3.5. Flow control</a></li>
<li><a href="#locals-blocks-and-loops">3.6. Locals, Blocks, and Loops</a></li>
<li><a href="#collection-types">3.7. Collection types</a></li>
<li><a href="#destructuring-section">3.8. Destructuring</a></li>
<li><a href="#namespace-section">3.9. Namespaces</a></li>
<li><a href="#abstractions-and-polymorphism">3.10. Abstractions and Polymorphism</a></li>
<li><a href="#data-types">3.11. Data types</a></li>
<li><a href="#host-interoperability">3.12. Host interoperability</a></li>
<li><a href="#truthiness">3.13. Truthiness</a></li>
<li><a href="#state-management">3.14. State management</a></li>
</ul>
</li>
<li><a href="#tooling-compiler">4. Tooling &amp; Compiler</a>
<ul class="sectlevel2">
<li><a href="#getting-started-with-the-compiler">4.1. Getting Started with the Compiler</a></li>
<li><a href="#working-with-the-repl">4.2. Working with the REPL</a></li>
<li><a href="#the-closure-library">4.3. The Closure Library</a></li>
<li><a href="#dependency-management">4.4. Dependency management</a></li>
<li><a href="#using-javascript-libraries">4.5. Using javascript libraries</a></li>
<li><a href="#unit-testing">4.6. Unit testing</a></li>
</ul>
</li>
<li><a href="#language-advanced-topics">5. Language (advanced topics)</a>
<ul class="sectlevel2">
<li><a href="#transducers">5.1. Transducers</a></li>
<li><a href="#transients">5.2. Transients</a></li>
<li><a href="#metadata">5.3. Metadata</a></li>
<li><a href="#macros">5.4. Macros</a></li>
<li><a href="#core-protocols">5.5. Core protocols</a></li>
<li><a href="#the-reader">5.6. The Reader</a></li>
</ul>
</li>
<li><a href="#appendix">6. Appendix</a>
<ul class="sectlevel2">
<li><a href="#appendix-a-interactive-development-with-figwheel">6.1. Appendix A: Interactive development with Figwheel</a></li>
<li><a href="#appendix-b-csp-and-core-async">6.2. Appendix B: CSP and core.async</a></li>
<li><a href="#appendix-c-setting-up-a-clojurescript-development-environment">6.3. Appendix C: Setting up a ClojureScript development environment</a></li>
</ul>
</li>
<li><a href="#acknowledgments">7. Acknowledgments</a></li>
<li><a href="#further-reading">8. Further Reading</a></li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="about-this-book"><a class="link" href="#about-this-book">1. About this book</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>This book covers the ClojureScript programming language, serves as a detailed guide of its<br>
tooling for development, and presents a series of articles about topics that are<br>
applicable to day-to-day programming in ClojureScript.</p>
</div>
<div class="paragraph">
<p>It is not an introductory book to programming in that it assumes the reader has experience<br>
programming in at least one language. However, it doesn&#8217;t assume experience with<br>
<em>ClojureScript</em> or functional programming. We&#8217;ll try to include links to reference<br>
material when talking about the theoretical underpinnings of ClojureScript that may not<br>
be familiar to everyone.</p>
</div>
<div class="paragraph">
<p>Since the ClojureScript documentation is good but sparse, we wanted to write a compendium<br>
of reference information and extensive examples to serve as a ClojureScript primer as<br>
well as a series of practical how-to&#8217;s. This document will evolve with the ClojureScript<br>
language, both as a reference of the language features and as a sort of cookbook with<br>
practical programming recipes.</p>
</div>
<div class="paragraph">
<p>You&#8217;ll get the most out of this book if you:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>are curious about ClojureScript or functional programming and have some programming<br>
experience;</p>
</li>
<li>
<p>write JavaScript or any other language that compiles to it and want to know what<br>
ClojureScript has to offer;</p>
</li>
<li>
<p>already know some Clojure and want to learn how ClojureScript differs from it, plus<br>
practical topics like how to target both languages with the same code base.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Don&#8217;t be turned off if you don&#8217;t see yourself in any of the above groups. We encourage<br>
you to give this book a try and to give us feedback on how we can make it more accessible.<br>
Our goal is to make ClojureScript more friendly to newcomers and spread the ideas about<br>
programming that Clojure has helped popularize, as we see a lot of value in them.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="introduction"><a class="link" href="#introduction">2. Introduction</a></h2>
<div class="sectionbody">
<div class="quoteblock">
<blockquote>
Why are we doing this? Because Clojure <em>rocks</em>, and JavaScript <em>reaches</em>.
</blockquote>
<div class="attribution">
&#8212; Rich Hickey
</div>
</div>
<div class="paragraph">
<p><em>ClojureScript</em> is an implementation of the Clojure programming language that<br>
targets JavaScript. Because of this, it can run in many different execution<br>
environments including web browsers, Node.js, io.js and Nashorn.</p>
</div>
<div class="paragraph">
<p>Unlike other languages that intend to <em>compile</em> to JavaScript (like TypeScript,<br>
FunScript, or CoffeeScript), ClojureScript is designed to use JavaScript like bytecode.<br>
It embraces functional programming and has very safe and consistent defaults. Its<br>
semantics differ significantly from those of JavaScript.</p>
</div>
<div class="paragraph">
<p>Another big difference (and in our opinion an advantage) over other languages is that<br>
Clojure is designed to be a guest. It is a language without its own virtual machine that<br>
can be easily adapted to the nuances of its execution environment. This has the<br>
benefit that Clojure (and hence ClojureScript) has access to all the existing<br>
libraries written for the host language.</p>
</div>
<div class="paragraph">
<p>Before we jump in, let us summarize some of the core ideas that ClojureScript brings<br>
to the table. Don&#8217;t worry if you don&#8217;t understand all of them right now, they&#8217;ll become<br>
clear throughout the book.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ClojureScript enforces the functional programming paradigm with its design decisions<br>
and idioms. Although being strongly opinionated about functional programming it&#8217;s a<br>
pragmatic language rather than pursuing theoretical purity.</p>
</li>
<li>
<p>Encourages programming with immutable data, offering highly performant and state of the<br>
art immutable collection implementations.</p>
</li>
<li>
<p>It makes a clear distinction of identity and its state, with explicit constructs<br>
for managing change as a series of immutable values over time.</p>
</li>
<li>
<p>It has type-based and value-based polymorphism, elegantly solving the expression<br>
problem.</p>
</li>
<li>
<p>It is a Lisp dialect so programs are written in the programming language&#8217;s own data<br>
structures, a property known as <em>homoiconicity</em> that makes metaprogramming (programs<br>
that write programs) as simple as it can be.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These ideas together hava a great influence in the way you design and implement software,<br>
even if you are not using Clojure. Functional programming, decoupling of data (which is<br>
immutable) from the operations to transform it, explicit idioms for managing change<br>
over time and polymorphic constructs for programming to abstractions greatly simplify the<br>
systems we write.</p>
</div>
<div class="quoteblock">
<blockquote>
We can make the same exact software we are making today with dramatically simpler stuff<br>
— dramatically simpler languages, tools, techniques, approaches.
</blockquote>
<div class="attribution">
&#8212; Rich Hickey
</div>
</div>
<div class="paragraph">
<p>We hope you enjoy the book and ClojureScript brings the same joy and inspiration that has<br>
brought to us.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="language-the-basics"><a class="link" href="#language-the-basics">3. Language (the basics)</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter will be a little introduction to ClojureScript without assumptions about<br>
previous knowledge of the Clojure language, providing a quick tour over all the things<br>
you will need to know about clojurescript and understand the rest of this book.</p>
</div>
<div class="sect2">
<h3 id="first-steps-with-lisp-syntax"><a class="link" href="#first-steps-with-lisp-syntax">3.1. First steps with Lisp syntax</a></h3>
<div class="paragraph">
<p>Invented by John McCarthy in 1958, Lisp is one of the oldest programming languages that is still<br>
around. It has evolved into many derivatives called dialects, ClojureScript being one of them. It<br>
is a programming language written in its own data structures — originally lists enclosed in<br>
parentheses — but Clojure(Script) has evolved the Lisp syntax with more data structures, making<br>
it more pleasant to write and read.</p>
</div>
<div class="paragraph">
<p>A list with a function in the first position is used for calling a function in ClojureScript. In the<br>
example below, we apply the addition function to three arguments. Note that unlike in other languages,<br>
<code>+</code> is not an operator but a function. Lisp has no operators; it only has functions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 6</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example above, we&#8217;re applying the addition function <code>+</code> to the arguments <code>1</code>, <code>2</code> and <code>3</code>. ClojureScript<br>
allows many unusual characters like <code>?</code> or <code>-</code> in symbol names, which makes it easier to read:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">zero? </span><span class="tok-mi">0</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>To distinguish function calls from lists of data items, we can quote lists to keep them from being evaluated.<br>
The quoted lists will be treated as data instead of as a function call:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-o">&#39;</span><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; (+ 1 2 3)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>ClojureScript uses more than lists for its syntax. The full details will be covered later, but here is an<br>
example of the usage of a vector (enclosed in brackets) for defining local bindings:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-mi">1</span>
      <span class="tok-nv">y</span> <span class="tok-mi">2</span>
      <span class="tok-nv">z</span> <span class="tok-mi">3</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">x</span> <span class="tok-nv">y</span> <span class="tok-nv">z</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; 6</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is practically all the syntax we need to know for using not only ClojureScript, but any Lisp. Being<br>
written in its own data structures (often referred to as <em>homoiconicity</em>) is a great property since the<br>
syntax is uniform and simple; also, code generation via <a href="#macros-section">macros</a> is easier than in any other language, giving<br>
us plenty of power to extend the language to suit our needs.</p>
</div>
</div>
<div class="sect2">
<h3 id="the-base-data-types"><a class="link" href="#the-base-data-types">3.2. The base data types</a></h3>
<div class="paragraph">
<p>The ClojureScript language has a rich set of data types like most programming languages. It provides<br>
scalar data types that will be very familiar to you, such as numbers, strings, and floats. Beyond these, it also<br>
provides a great number of others that might be less familiar, such as symbols, keywords, regexes (regular expressions),<br>
vars, atoms, and volatiles.</p>
</div>
<div class="paragraph">
<p><em>ClojureScript</em> embraces the host language, and where possible, uses the host&#8217;s provided types. For example:<br>
numbers and strings are used as is and behave in the same way as in JavaScript.</p>
</div>
<div class="sect3">
<h4 id="numbers"><a class="link" href="#numbers">3.2.1. Numbers</a></h4>
<div class="paragraph">
<p>In <em>ClojureScript</em>, numbers include both integers and floating points. Keeping in mind that<br>
<em>ClojureScript</em> is a guest language that compiles to JavaScript, integers are actually JavaScript&#8217;s native<br>
floating points under the hood.</p>
</div>
<div class="paragraph">
<p>As in any other language, numbers in <em>ClojureScript</em> are represented in the following ways:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-mi">23</span>
<span class="tok-nv">+23</span>
<span class="tok-mi">-100</span>
<span class="tok-mf">1.7</span>
<span class="tok-mi">-2</span>
<span class="tok-mi">33</span><span class="tok-nv">e8</span>
<span class="tok-mi">12</span><span class="tok-nv">e-14</span>
<span class="tok-mf">3.2</span><span class="tok-nv">e-4</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="keywords"><a class="link" href="#keywords">3.2.2. Keywords</a></h4>
<div class="paragraph">
<p>Keywords in <em>ClojureScript</em> are objects that always evaluate to themselves. They are usually<br>
used in <a href="#maps-section">map data structures</a> to efficiently represent the keys.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-ss">:foobar</span>
<span class="tok-ss">:2</span>
<span class="tok-ss">:?</span>
<span class="tok-ss">:foo/bar</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, the keywords are all prefixed with <code>:</code>, but this character is only part<br>
of the literal syntax and is not part of the name of the object.</p>
</div>
<div class="paragraph">
<p>You can also create a keyword by calling the <code>keyword</code> function. Don&#8217;t worry if you don&#8217;t understand<br>
or are unclear about anything in the following example; <a href="#function-section">functions</a> are discussed in a later section.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">keyword </span><span class="tok-s">&quot;foo&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; :foo</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="symbols"><a class="link" href="#symbols">3.2.3. Symbols</a></h4>
<div class="paragraph">
<p>Symbols in <em>ClojureScript</em> are very, very similar to <strong>keywords</strong> (which you now know about). But<br>
instead of evaluating to themselves, symbols are evaluated to something that they refer to, which<br>
can be functions, variables, etc.</p>
</div>
<div class="paragraph">
<p>Symbols start with a non numeric character and can contain alphanumeric characters as well as *, +, !, -, _, ', and ? such as :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-nv">sample-symbol</span>
<span class="tok-nv">othersymbol</span>
<span class="tok-nv">f1</span>
<span class="tok-nv">my-special-swap!</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Don&#8217;t worry if you don&#8217;t understand right away; symbols are used in almost<br>
all of our examples, which will give you the opportunity to learn more as we go on.</p>
</div>
</div>
<div class="sect3">
<h4 id="strings"><a class="link" href="#strings">3.2.4. Strings</a></h4>
<div class="paragraph">
<p>There is almost nothing new we can explain about strings that you don&#8217;t already know. In <em>ClojureScript</em>, they<br>
work the same as in any other language. One point of interest, however, is that they are immutable.</p>
</div>
<div class="paragraph">
<p>In this case they are the same as in JavaScript:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-s">&quot;An example of a string&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>One peculiar aspect of strings in <em>ClojureScript</em> is due to the language&#8217;s Lisp syntax: single and multiline strings<br>
have the same syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-s">&quot;This is a multiline</span>
<span class="tok-s">      string in ClojureScript.&quot;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="characters"><a class="link" href="#characters">3.2.5. Characters</a></h4>
<div class="paragraph">
<p><em>ClojureScript</em> also lets you write single characters using Clojure&#8217;s character literal syntax.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-sc">\a</span>        <span class="tok-c1">; The lowercase a character</span>
<span class="tok-sc">\n</span><span class="tok-nv">ewline</span>  <span class="tok-c1">; The newline character</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Since the host language doesn&#8217;t contain character literals, <em>ClojureScript</em> characters are transformed<br>
behind the scenes into single character JavaScript strings.</p>
</div>
</div>
<div class="sect3">
<h4 id="collections"><a class="link" href="#collections">3.2.6. Collections</a></h4>
<div class="paragraph">
<p>Another big step in explaining a language is to explain its collections and collection<br>
abstractions. <em>ClojureScript</em> is not an exception to this rule.</p>
</div>
<div class="paragraph">
<p><em>ClojureScript</em> comes with many types of collections. The main difference between <em>ClojureScript</em><br>
collections and collections in other languages is that they are persistent and immutable.</p>
</div>
<div class="paragraph">
<p>Before moving on to these (possibly) unknown concepts, we&#8217;ll present a high-level overview<br>
of existing collection types in <em>ClojureScript</em>.</p>
</div>
<div class="sect4">
<h5 id="lists"><a class="link" href="#lists">Lists</a></h5>
<div class="paragraph">
<p>This is a classic collection type in languages based on Lisp. Lists are the<br>
simplest type of collection in <em>ClojureScript</em>. Lists can contain items of any type, including<br>
other collections.</p>
</div>
<div class="paragraph">
<p>Lists in <em>ClojureScript</em> are represented by items enclosed between parentheses:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-o">&#39;</span><span class="tok-p">(</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">)</span>
<span class="tok-o">&#39;</span><span class="tok-p">(</span><span class="tok-ss">:foo</span> <span class="tok-ss">:bar</span> <span class="tok-mi">2</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, all list examples are prefixed with the <code>'</code> char. This is because lists in Lisp-like<br>
languages are often used to express things like function or macro calls. In that case,<br>
the first item should be a symbol that will evaluate to something callable, and the rest of the list<br>
elements will be function arguments. However, in the preceding examples, we don&#8217;t want the first item as a symbol;<br>
we just want a list of items.  The following example shows the difference between a list without and with the preceding<br>
single quote mark:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 2</span>

<span class="tok-o">&#39;</span><span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; (inc 1)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, if you evaluate <code>(inc 1)</code> without prefixing it with <code>'</code>, it will resolve<br>
the <code>inc</code> symbol to the <strong>inc</strong> function and will execute it with <code>1</code> as the first argument, returning the value <code>2</code>.</p>
</div>
<div class="paragraph">
<p>You can also explicitly create a list with the <code>list</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">list </span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; (1 2 3 4 5)</span>

<span class="tok-p">(</span><span class="tok-nb">list </span><span class="tok-ss">:foo</span> <span class="tok-ss">:bar</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; (:foo :bar 2)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Lists have the peculiarity that they are very efficient if you access them sequentially or<br>
access their first elements, but a list is not a very good option if you need random (index) access to its<br>
elements.</p>
</div>
</div>
<div class="sect4">
<h5 id="vectors"><a class="link" href="#vectors">Vectors</a></h5>
<div class="paragraph">
<p>Like lists, <strong>vectors</strong> store a series of values, but in this case, with very efficient index access<br>
to their elements, as opposed to lists, which are evaluated in order. Don&#8217;t worry; in<br>
the following sections we&#8217;ll go in depth with details, but at this moment, this simple explanation is<br>
more than enough.</p>
</div>
<div class="paragraph">
<p>Vectors use square brackets for the literal syntax; let&#8217;s see some examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">[</span><span class="tok-ss">:foo</span> <span class="tok-ss">:bar</span><span class="tok-p">]</span>
<span class="tok-p">[</span><span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span> <span class="tok-nv">nil</span><span class="tok-p">]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Like lists, vectors can contain objects of any type, as you can observe in the preceding example.</p>
</div>
<div class="paragraph">
<p>You can also explicitly create a vector with the <code>vector</code> function, but this is not commonly used in ClojureScript programs:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">vector </span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [1 2 3]</span>

<span class="tok-p">(</span><span class="tok-nb">vector </span><span class="tok-s">&quot;blah&quot;</span> <span class="tok-mf">3.5</span> <span class="tok-nv">nil</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [&quot;blah&quot; 3.5 nil]</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="maps-section"><a class="link" href="#maps-section">Maps</a></h5>
<div class="paragraph">
<p>Maps are a collection abstraction that allow you to store key/value pairs. In other<br>
languages, this type of structure is commonly known as a hash-map or dict (dictionary). Map literals<br>
in <em>ClojureScript</em> are written with the pairs between curly braces.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">{</span><span class="tok-ss">:foo</span> <span class="tok-s">&quot;bar&quot;</span>, <span class="tok-ss">:baz</span> <span class="tok-mi">2</span><span class="tok-p">}</span>
<span class="tok-p">{</span><span class="tok-ss">:alphabet</span> <span class="tok-p">[</span><span class="tok-ss">:a</span> <span class="tok-ss">:b</span> <span class="tok-ss">:c</span><span class="tok-p">]}</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Commas are frequently used to separate a key-value pair, but they are completely optional. In<br>
<em>ClojureScript</em> syntax, commas are treated like spaces.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Like vectors, every item in a map literal is evaluated before the result is stored in a map, but<br>
the order of evaluation is not guaranteed.</p>
</div>
</div>
<div class="sect4">
<h5 id="sets"><a class="link" href="#sets">Sets</a></h5>
<div class="paragraph">
<p>And finally, <strong>sets</strong>.</p>
</div>
<div class="paragraph">
<p>Sets store zero or more unique items of any type and are unordered. Like maps,<br>
they use curly braces for their literal syntax, with the difference being that they use a <code>#</code> as<br>
the leading character. You can also use the <code>set</code> function to convert a collection to a set:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-ss">:foo</span> <span class="tok-ss">:bar</span><span class="tok-p">}</span>
<span class="tok-c1">;; =&gt; #{1 :bar 3 :foo 2}</span>
<span class="tok-p">(</span><span class="tok-nb">set </span><span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">1</span> <span class="tok-mi">3</span> <span class="tok-mi">1</span> <span class="tok-mi">4</span> <span class="tok-mi">1</span> <span class="tok-mi">5</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; #{1 2 3 4 5}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In subsequent sections, we&#8217;ll go in depth about sets and the other collection types you&#8217;ve seen in this<br>
section.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="vars"><a class="link" href="#vars">3.3. Vars</a></h3>
<div class="paragraph">
<p><em>ClojureScript</em> is a mostly functional language that focuses on immutability. Because of that, it does<br>
not have the concept of variables as you know them in most other programming languages. The closest analogy to<br>
variables are the variables you define in algebra; when you say <code>x = 6</code> in mathematics, you are saying that you<br>
want the symbol <code>x</code> to stand for the number six.</p>
</div>
<div class="paragraph">
<p>In <em>ClojureScript</em>, vars are represented by symbols and store a single value together with metadata.</p>
</div>
<div class="paragraph">
<p>You can define a var using the <code>def</code> special form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">x</span> <span class="tok-mi">22</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">y</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Vars are always top level in the namespace (<a href="#namespace-section">which we will explain later</a>). If you use <code>def</code> in a function call,<br>
the var will be defined at the namespace level, but we do not recommend this - instead, you should use <code>let</code><br>
to define variables within a function.</p>
</div>
</div>
<div class="sect2">
<h3 id="function-section"><a class="link" href="#function-section">3.4. Functions</a></h3>
<div class="sect3">
<h4 id="the-first-contact"><a class="link" href="#the-first-contact">3.4.1. The first contact</a></h4>
<div class="paragraph">
<p>It&#8217;s time to make things happen. <em>ClojureScript</em> has what are known as first class functions. They behave<br>
like any other type; you can pass them as parameters and you can return them as values, always respecting<br>
the lexical scope. <em>ClojureScript</em> also has some features of dynamic scoping, but this will be discussed<br>
in another section.</p>
</div>
<div class="paragraph">
<p>If you want to know more about scopes, this <a href="http://en.wikipedia.org/wiki/Scope_(computer_science)">Wikipedia article</a><br>
is very extensive and explains different types of scoping.</p>
</div>
<div class="paragraph">
<p>As <em>ClojureScript</em> is a Lisp dialect, it uses the prefix notation for calling a function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 2</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example above, <code>inc</code> is a function and is part of the <em>ClojureScript</em> runtime, and <code>1</code> is the first<br>
argument for the <code>inc</code> function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 6</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>+</code> symbol represents an <code>add</code> function. It allows multiple parameters, whereas in ALGOL-type languages,<br>
<code>+</code> is an operator and only allows two parameters.</p>
</div>
<div class="paragraph">
<p>The prefix notation has huge advantages, some of them not always obvious. <em>ClojureScript</em> does not<br>
make a distinction between a function and an operator; everything is a function. The immediate advantage<br>
is that the prefix notation allows an arbitrary number of arguments per "operator". It also completely<br>
eliminates the problem of operator precedence.</p>
</div>
</div>
<div class="sect3">
<h4 id="defining-your-own-functions"><a class="link" href="#defining-your-own-functions">3.4.2. Defining your own functions</a></h4>
<div class="paragraph">
<p>You can define an unnamed (anonymous) function with the <code>fn</code> special form. This is one type of function definition;<br>
in the following example, the function takes two parameters and returns their average.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">param1</span> <span class="tok-nv">param2</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">/ </span><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">param1</span> <span class="tok-nv">param2</span><span class="tok-p">)</span> <span class="tok-mf">2.0</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>You can define a function and call it at the same time (in a single expression):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">((</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-nv">x</span> <span class="tok-nv">x</span><span class="tok-p">))</span> <span class="tok-mi">5</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 25</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s start creating named functions. But what does a <em>named function</em> really mean? It is very simple;<br>
in <em>ClojureScript</em>, functions are first-class and behave like any other value, so naming a function<br>
is done by simply binding the function to a symbol:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">square</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-nv">x</span> <span class="tok-nv">x</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">square</span> <span class="tok-mi">12</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 144</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><em>ClojureScript</em> also offers the <code>defn</code> macro as a little syntactic sugar for making function definition<br>
more idiomatic:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">square</span>
  <span class="tok-s">&quot;Return the square of a given number.&quot;</span>
  <span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-nv">x</span> <span class="tok-nv">x</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The string that comes between the function name and the parameter vector is called a<br>
<em>docstring</em> (documentation string); programs that automatically create web documentation<br>
from your source files will use these docstrings.</p>
</div>
</div>
<div class="sect3">
<h4 id="functions-with-multiple-arities"><a class="link" href="#functions-with-multiple-arities">3.4.3. Functions with multiple arities</a></h4>
<div class="paragraph">
<p><em>ClojureScript</em> also comes with the ability to define functions with an arbitrary number of<br>
arguments. (The term <em>arity</em> means the number of arguments that a function takes.) The<br>
syntax is almost the same as for defining an ordinary function, with the difference that<br>
it has more than one body.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see an example, which will explain it better:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">myinc</span>
  <span class="tok-s">&quot;Self defined version of parameterized `inc`.&quot;</span>
  <span class="tok-p">([</span><span class="tok-nv">x</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nf">myinc</span> <span class="tok-nv">x</span> <span class="tok-mi">1</span><span class="tok-p">))</span>
  <span class="tok-p">([</span><span class="tok-nv">x</span> <span class="tok-nv">increment</span><span class="tok-p">]</span>
   <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">x</span> <span class="tok-nv">increment</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This line: <code>([x] (myinc x 1))</code> says that if there is only one argument, call the function<br>
<code>myinc</code> with that argument and the number <code>1</code> as the second argument. The other function body<br>
<code>([x increment] (+ x increment))</code> says that if there are two arguments, return the result of<br>
adding them.</p>
</div>
<div class="paragraph">
<p>Here are some examples using the previously defined multi-arity function. Observe that<br>
if you call a function with the wrong number of arguments, the compiler will emit an error message.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">myinc</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 2</span>

<span class="tok-p">(</span><span class="tok-nf">myinc</span> <span class="tok-mi">1</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 4</span>

<span class="tok-p">(</span><span class="tok-nf">myinc</span> <span class="tok-mi">1</span> <span class="tok-mi">3</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-c1">;; Compiler error</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Explaining the concept of "arity" is out of the scope of this book, however you can read about that in this<br>
<a href="http://en.wikipedia.org/wiki/Arity">Wikipedia article</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="variadic-functions"><a class="link" href="#variadic-functions">3.4.4. Variadic functions</a></h4>
<div class="paragraph">
<p>Another way to accept multiple parameters is defining variadic functions. Variadic functions<br>
are functions that accept an arbitrary number of arguments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">my-variadic-set</span>
  <span class="tok-p">[</span><span class="tok-o">&amp;</span> <span class="tok-nv">params</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">set </span><span class="tok-nv">params</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">my-variadic-set</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #{1 2 3}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The way to denote a variadic function is using the <code>&amp;</code> symbol prefix on its arguments vector.</p>
</div>
</div>
<div class="sect3">
<h4 id="short-syntax-for-anonymous-functions"><a class="link" href="#short-syntax-for-anonymous-functions">3.4.5. Short syntax for anonymous functions</a></h4>
<div class="paragraph">
<p><em>ClojureScript</em> provides a shorter syntax for defining anonymous functions using<br>
the <code>#()</code> reader macro (usually leads to one-liners). Reader macros are "special" expressions that will be<br>
transformed to the appropriate language form at compile time; in this case, to some expression<br>
that uses the <code>fn</code> special form.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">average</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">/ </span><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">%1</span> <span class="tok-nv">%2</span><span class="tok-p">)</span> <span class="tok-mi">2</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">average</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 3.5</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding definition is shorthand for:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">average-longer</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">a</span> <span class="tok-nv">b</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">/ </span><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">a</span> <span class="tok-nv">b</span><span class="tok-p">)</span> <span class="tok-mi">2</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">average-longer</span> <span class="tok-mi">7</span> <span class="tok-mi">8</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 7.5</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>%1</code>, <code>%2</code>, <code>%N</code> are simple markers for parameter positions that are implicitly declared when<br>
the reader macro will be interpreted and converted to a <code>fn</code> expression.</p>
</div>
<div class="paragraph">
<p>If a function only accepts one argument, you can omit the number after the <code>%</code> symbol, e.g., a<br>
function that squares a number: <code>#(* %1 %1))</code> can be written <code>#(* % %))</code>.</p>
</div>
<div class="paragraph">
<p>Additionally, this syntax also supports the variadic form with the <code>%&amp;</code> symbol:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">my-variadic-set</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">set </span><span class="tok-nv">%</span><span class="tok-o">&amp;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">my-variadic-set</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #{1 2}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="flow-control"><a class="link" href="#flow-control">3.5. Flow control</a></h3>
<div class="paragraph">
<p><em>ClojureScript</em> has a very different approach to flow control than languages like JavaScript, C, etc.</p>
</div>
<div class="sect3">
<h4 id="branching-with-code-if-code"><a class="link" href="#branching-with-code-if-code">3.5.1. Branching with <code>if</code></a></h4>
<div class="paragraph">
<p>Let&#8217;s start with a basic one: <code>if</code>. In <em>ClojureScript</em>, the <code>if</code> is an expression and not a<br>
statement, and it has three parameters: the first one is the condition expression, the second one<br>
is an expression that will be evaluated if the condition expression evaluates to logical true,<br>
and the third expression will be evaluated otherwise.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">discount</span>
  <span class="tok-s">&quot;You get 5% discount for ordering 100 or more items&quot;</span>
  <span class="tok-p">[</span><span class="tok-nv">quantity</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">&gt;= </span><span class="tok-nv">quantity</span> <span class="tok-mi">100</span><span class="tok-p">)</span>
    <span class="tok-mf">0.05</span>
    <span class="tok-mi">0</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">discount</span> <span class="tok-mi">30</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 0</span>

<span class="tok-p">(</span><span class="tok-nf">discount</span> <span class="tok-mi">130</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 0.05</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The block expression <code>do</code> can be used to have multiple expressions in an <code>if</code> branch.<br>
<a href="#block-section"><code>do</code> is explained in the next section</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="branching-with-code-cond-code"><a class="link" href="#branching-with-code-cond-code">3.5.2. Branching with <code>cond</code></a></h4>
<div class="paragraph">
<p>Sometimes, the <code>if</code> expression can be slightly limiting because it does not have the "else if" part<br>
to add more than one condition. The <code>cond</code> macro comes to the rescue.</p>
</div>
<div class="paragraph">
<p>With the <code>cond</code> expression, you can define multiple conditions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">mypos?</span>
  <span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">cond</span>
    <span class="tok-p">(</span><span class="tok-nb">&gt; </span><span class="tok-nv">x</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-s">&quot;positive&quot;</span>
    <span class="tok-p">(</span><span class="tok-nb">&lt; </span><span class="tok-nv">x</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-s">&quot;negative&quot;</span>
    <span class="tok-ss">:else</span> <span class="tok-s">&quot;zero&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">mypos?</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;zero&quot;</span>

<span class="tok-p">(</span><span class="tok-nf">mypos?</span> <span class="tok-mi">-2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;negative&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Also, <code>cond</code> has another form, called <code>condp</code>, that works very similarly to the simple <code>cond</code><br>
but looks cleaner when the condition (also called a predicate) is the same for all conditions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">translate-lang-code</span>
  <span class="tok-p">[</span><span class="tok-nv">code</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">condp</span> <span class="tok-nb">= </span><span class="tok-p">(</span><span class="tok-nb">keyword </span><span class="tok-nv">code</span><span class="tok-p">)</span>
    <span class="tok-ss">:es</span> <span class="tok-s">&quot;Spanish&quot;</span>
    <span class="tok-ss">:en</span> <span class="tok-s">&quot;English&quot;</span>
    <span class="tok-s">&quot;Unknown&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">translate-lang-code</span> <span class="tok-s">&quot;en&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;English&quot;</span>

<span class="tok-p">(</span><span class="tok-nf">translate-lang-code</span> <span class="tok-s">&quot;fr&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;Unknown&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The line <code>condp = (keyword code)</code> means that, in each of the following lines, <em>ClojureScript</em><br>
will apply the <code>=</code> function to the given keyword and the <code>code</code> argument.</p>
</div>
</div>
<div class="sect3">
<h4 id="branching-with-code-case-code"><a class="link" href="#branching-with-code-case-code">3.5.3. Branching with <code>case</code></a></h4>
<div class="paragraph">
<p>The <code>case</code> branching expression has a similar use as our previous example with<br>
<code>condp</code>. The main differences are that <code>case</code> always uses the <code>=</code> predicate/function and its<br>
branching values are evaluated at compile time. This results in a more performant form<br>
than <code>cond</code> or <code>condp</code> but has the disadvantage that the condition value must be static.</p>
</div>
<div class="paragraph">
<p>Here is the previous example rewritten to use <code>case</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">translate-lang-code</span>
  <span class="tok-p">[</span><span class="tok-nv">code</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">case</span> <span class="tok-nv">code</span>
    <span class="tok-s">&quot;es&quot;</span> <span class="tok-s">&quot;Spanish&quot;</span>
    <span class="tok-s">&quot;en&quot;</span> <span class="tok-s">&quot;English&quot;</span>
    <span class="tok-s">&quot;Unknown&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">translate-lang-code</span> <span class="tok-s">&quot;en&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;English&quot;</span>

<span class="tok-p">(</span><span class="tok-nf">translate-lang-code</span> <span class="tok-s">&quot;fr&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;Unknown&quot;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="locals-blocks-and-loops"><a class="link" href="#locals-blocks-and-loops">3.6. Locals, Blocks, and Loops</a></h3>
<div class="sect3">
<h4 id="locals"><a class="link" href="#locals">3.6.1. Locals</a></h4>
<div class="paragraph">
<p><em>ClojureScript</em> does not have the concept of variables as in ALGOL-like languages, but it does<br>
have locals. Locals, as per usual, are immutable, and if you try to mutate them, the compiler<br>
will throw an error.</p>
</div>
<div class="paragraph">
<p>Locals are defined with the <code>let</code> expression. The expression starts with a vector as the first parameter<br>
followed by an arbitrary number of expressions. The first parameter (the vector) should contain an arbitrary<br>
number of pairs that give a <em>binding form</em> (usually a symbol) followed by an expression whose value will<br>
be bound to this new local for the remainder of the <code>let</code> expression.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-mi">1</span><span class="tok-p">)</span>
      <span class="tok-nv">y</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">x</span> <span class="tok-mi">1</span><span class="tok-p">)]</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Simple message from the body of a let&quot;</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">))</span>
<span class="tok-c1">;; Simple message from the body of a let</span>
<span class="tok-c1">;; =&gt; 6</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, the symbol <code>x</code> is bound to the value <code>(inc 1)</code>, which comes out to 2,<br>
and the symbol <code>y</code> is bound to the sum of <code>x</code> and 1, which comes out to 3. Given those bindings, the<br>
expressions <code>(println "Simple message from the body of a let")</code> and <code>(* x y)</code> are evaluated.</p>
</div>
</div>
<div class="sect3">
<h4 id="blocks"><a class="link" href="#blocks">3.6.2. Blocks</a></h4>
<div class="paragraph">
<p>In JavaScript, braces <code>{</code> and <code>}</code> delimit a block of code that “belongs together”. Blocks in<br>
<em>ClojureScript</em> are created using the <code>do</code> expression and are usually used for side effects, like<br>
printing something to the console or writing a log in a logger.</p>
</div>
<div class="paragraph">
<p>A side effect is something that is not necessary for the return value.</p>
</div>
<div class="paragraph">
<p>The <code>do</code> expression accepts as its parameter an arbitrary number of other expressions, but it returns<br>
the return value only from the last one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">do</span>
   <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;hello world&quot;</span><span class="tok-p">)</span>
   <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;hola mundo&quot;</span><span class="tok-p">)</span>
   <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-mi">3</span> <span class="tok-mi">5</span><span class="tok-p">)</span> <span class="tok-c1">;; this value will not be returned; it is thrown away</span>
   <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">))</span>

<span class="tok-c1">;; hello world</span>
<span class="tok-c1">;; hola mundo</span>
<span class="tok-c1">;; =&gt; 3</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The body of the <code>let</code> expression, explained in the previous section, is very similar to the<br>
<code>do</code> expression in that it allows multiple expressions. In fact, the <code>let</code> has an implicit <code>do</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="loops"><a class="link" href="#loops">3.6.3. Loops</a></h4>
<div class="paragraph">
<p>The functional approach of <em>ClojureScript</em> means that it does not have standard,<br>
well-known, statement-based loops such as <code>for</code> in JavaScript. The loops in <em>ClojureScript</em> are handled using recursion.<br>
Recursion sometimes requires additional thinking about how to model your problem in<br>
a slightly different way than imperative languages.</p>
</div>
<div class="paragraph">
<p>Many of the common patterns for which <code>for</code> is used in other languages are achieved<br>
through higher-order functions - functions that accept other functions as parameters.</p>
</div>
<div class="sect4">
<h5 id="looping-with-loop-recur"><a class="link" href="#looping-with-loop-recur">Looping with loop/recur</a></h5>
<div class="paragraph">
<p>Let&#8217;s take a look at how to express loops using recursion with the <code>loop</code> and <code>recur</code> forms.<br>
<code>loop</code> defines a possibly empty list of bindings (notice the symmetry with <code>let</code>) and <code>recur</code><br>
jumps execution back to the looping point with new values for those bindings.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">loop </span><span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-mi">0</span><span class="tok-p">]</span>
   <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Looping with &quot;</span> <span class="tok-nv">x</span><span class="tok-p">)</span>
   <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">x</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Done looping!&quot;</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nf">recur</span> <span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-nv">x</span><span class="tok-p">))))</span>
<span class="tok-c1">;; Looping with 0</span>
<span class="tok-c1">;; Looping with 1</span>
<span class="tok-c1">;; Looping with 2</span>
<span class="tok-c1">;; Done looping!</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above snippet, we bind the name <code>x</code> to the value <code>0</code> and execute the body. Since the<br>
condition is not met the first time, it&#8217;s rerun with <code>recur</code>, incrementing the binding value with<br>
the <code>inc</code> function. We do this once more until the condition is met and, since there aren&#8217;t any<br>
more <code>recur</code> calls, exit the loop.</p>
</div>
<div class="paragraph">
<p>Note that <code>loop</code> isn&#8217;t the only point we can <code>recur</code> to; using <code>recur</code> inside a function<br>
executes the body of the function recursively with the new bindings:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">recursive-function</span> <span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span>
   <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Looping with&quot;</span> <span class="tok-nv">x</span><span class="tok-p">)</span>
   <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">x</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Done looping!&quot;</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nf">recur</span> <span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-nv">x</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-nf">recursive-function</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
<span class="tok-c1">;; Looping with 0</span>
<span class="tok-c1">;; Looping with 1</span>
<span class="tok-c1">;; Looping with 2</span>
<span class="tok-c1">;; Done looping!</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="replacing-for-loops-with-higher-order-functions"><a class="link" href="#replacing-for-loops-with-higher-order-functions">Replacing for loops with higher-order functions</a></h5>
<div class="paragraph">
<p>In imperative programming languages it is common to use <code>for</code> loops to iterate over data and<br>
transform it, usually with the intent being one of the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Transform every value in the iterable yielding another iterable</p>
</li>
<li>
<p>Filter the elements of the iterable by certain criteria</p>
</li>
<li>
<p>Convert the iterable to a value where each iteration depends on the result from the previous one</p>
</li>
<li>
<p>Run a computation for every value in the iterable</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The above actions are encoded in higher-order functions and syntactic constructs in ClojureScript;<br>
let&#8217;s see an example of the first three.</p>
</div>
<div class="paragraph">
<p>For transforming every value in an iterable data structure we use the <code>map</code> function, which takes a<br>
function and a sequence and applies the function to every element:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">map inc </span><span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; (1 2 3)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The first parameter for <code>map</code> can be <em>any</em> function that takes one argument and returns a value.<br>
For example, if you had a graphing application and you wanted to graph the equation<br>
<code>y&#160;=&#160;3x&#160;+&#160;5</code> for a set of <em>x</em> values, you could get the <em>y</em> values like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">y-value</span> <span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-mi">3</span> <span class="tok-nv">x</span><span class="tok-p">)</span> <span class="tok-mi">5</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-nv">y-value</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; (8 11 14 17 20)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If your function is short, you can use an anonymous function instead, either the normal or short syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-mi">3</span> <span class="tok-nv">x</span><span class="tok-p">)</span> <span class="tok-mi">5</span><span class="tok-p">))</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; (8 11 14 17 20)</span>
<span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-mi">3</span> <span class="tok-nv">%</span><span class="tok-p">)</span> <span class="tok-mi">5</span><span class="tok-p">)</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; (8 11 14 17 20)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For filtering the values of a data structure we use the <code>filter</code> function, which takes a predicate<br>
and a sequence and gives a new sequence with only the elements that returned <code>true</code> for the given<br>
predicate:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">filter </span><span class="tok-nv">odd?</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; (1 3)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Again, you can use any function that returns <code>true</code> or <code>false</code> as the first argument to <code>filter</code>.<br>
Here is an example that keeps only words less than five characters long. (The <code>count</code> function<br>
returns the length of its argument.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">filter </span><span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">word</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">&lt; </span><span class="tok-p">(</span><span class="tok-nb">count </span><span class="tok-nv">word</span><span class="tok-p">)</span> <span class="tok-mi">5</span><span class="tok-p">))</span> <span class="tok-p">[</span><span class="tok-s">&quot;ant&quot;</span> <span class="tok-s">&quot;baboon&quot;</span> <span class="tok-s">&quot;crab&quot;</span> <span class="tok-s">&quot;duck&quot;</span> <span class="tok-s">&quot;echidna&quot;</span> <span class="tok-s">&quot;fox&quot;</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; (&quot;ant&quot; &quot;crab&quot; &quot;duck&quot; &quot;fox&quot;)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Converting an iterable to a single value, accumulating the intermediate result at every step of the iteration<br>
can be achieved with <code>reduce</code>, which takes a function for accumulating values, an optional initial value<br>
and a collection:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">reduce + </span><span class="tok-mi">0</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; 10</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Yet again, you can provide your own function as the first argument to <code>reduce</code>, but your function must have<br>
<em>two</em> parameters. The first one is the "accumulated value" and the second parameter is the collection item<br>
being processed. The function returns a value that becomes the accumulator for the next item in the list.<br>
For example, here is how you would find the sum of squares of a set of numbers (this is<br>
an important calculation in statistics). Using a separate function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">sum-squares</span> <span class="tok-p">[</span><span class="tok-nv">accumulator</span> <span class="tok-nv">item</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">accumulator</span> <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-nv">item</span> <span class="tok-nv">item</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nb">reduce </span><span class="tok-nv">sum-squares</span> <span class="tok-mi">0</span> <span class="tok-p">[</span><span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; 50</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;and with an anonymous function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">reduce </span><span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">acc</span> <span class="tok-nv">item</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">acc</span> <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-nv">item</span> <span class="tok-nv">item</span><span class="tok-p">)))</span> <span class="tok-mi">0</span> <span class="tok-p">[</span><span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; 50</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is a <code>reduce</code> that finds the total number of characters in a set of words:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">reduce </span><span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">acc</span> <span class="tok-nv">word</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">acc</span> <span class="tok-p">(</span><span class="tok-nb">count </span><span class="tok-nv">word</span><span class="tok-p">)))</span> <span class="tok-mi">0</span> <span class="tok-p">[</span><span class="tok-s">&quot;ant&quot;</span> <span class="tok-s">&quot;bee&quot;</span> <span class="tok-s">&quot;crab&quot;</span> <span class="tok-s">&quot;duck&quot;</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; 14</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We have not used the short syntax here because, although it requires less typing,<br>
it can be less readable, and when you are starting with a new language,<br>
it&#8217;s important to be able to read what you wrote! If you are comfortable with the<br>
short syntax, feel free to use it.</p>
</div>
<div class="paragraph">
<p>Remember to choose your starting value for the accumulator carefully. If you<br>
wanted to use <code>reduce</code> to find the product of a series of numbers, you would have to start<br>
with one rather than zero, otherwise all the numbers would be multiplied by zero!</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-c1">;; wrong starting value</span>
<span class="tok-p">(</span><span class="tok-nb">reduce * </span><span class="tok-mi">0</span> <span class="tok-p">[</span><span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; 0</span>

<span class="tok-c1">;; correct starting accumulator</span>
<span class="tok-p">(</span><span class="tok-nb">reduce * </span><span class="tok-mi">1</span> <span class="tok-p">[</span><span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; 60</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="code-for-code-sequence-comprehensions"><a class="link" href="#code-for-code-sequence-comprehensions"><code>for</code> sequence comprehensions</a></h5>
<div class="paragraph">
<p>In ClojureScript, the <code>for</code> construct isn&#8217;t used for iteration but for generating sequences, an operation<br>
also known as "sequence comprehension". It offers a small domain specific language for declaratively<br>
building sequences.</p>
</div>
<div class="paragraph">
<p><code>for</code> takes a vector of bindings and an expression and generates a sequence of the result of evaluating the<br>
expression. Let&#8217;s take a look at an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">for </span><span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]]</span>
  <span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-nv">x</span> <span class="tok-nv">x</span><span class="tok-p">)])</span>
<span class="tok-c1">;; =&gt; ([1 1] [2 4] [3 9])</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, <code>x</code> is bound to each of the items in the vector <code>[1 2 3]</code> in turn, and returns a new<br>
sequence of two-item vectors with the original item squared.</p>
</div>
<div class="paragraph">
<p><code>for</code> supports multiple bindings, which will cause the collections to be iterated in a nested fashion, much<br>
like nesting <code>for</code> loops in imperative languages. The innermost binding iterates “fastest.”</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">for </span><span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]</span>
      <span class="tok-nv">y</span> <span class="tok-p">[</span><span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">]]</span>
  <span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">])</span>

<span class="tok-c1">;; =&gt; ([1 4] [1 5] [2 4] [2 5] [3 4] [3 5])</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We can also follow the bindings with three modifiers: <code>:let</code> for creating local bindings, <code>:while</code> for<br>
breaking out of the sequence generation, and <code>:when</code> for filtering out values.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an example of local bindings using the <code>:let</code> modifier; note that the bindings defined with it<br>
will be available in the expression:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">for </span><span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]</span>
      <span class="tok-nv">y</span> <span class="tok-p">[</span><span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">]</span>
      <span class="tok-ss">:let</span> <span class="tok-p">[</span><span class="tok-nv">z</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">)]]</span>
  <span class="tok-nv">z</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; (5 6 6 7 7 8)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We can use the <code>:while</code> modifier for expressing a condition that, when it is no longer met, will stop<br>
the sequence generation. Here&#8217;s an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">for </span><span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]</span>
      <span class="tok-nv">y</span> <span class="tok-p">[</span><span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">]</span>
      <span class="tok-ss">:while</span> <span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">y</span> <span class="tok-mi">4</span><span class="tok-p">)]</span>
  <span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">])</span>

<span class="tok-c1">;; =&gt; ([1 4] [2 4] [3 4])</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For filtering out generated values, use the <code>:when</code> modifier as in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">for </span><span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]</span>
      <span class="tok-nv">y</span> <span class="tok-p">[</span><span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">]</span>
      <span class="tok-ss">:when</span> <span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">)</span> <span class="tok-mi">6</span><span class="tok-p">)]</span>
  <span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">])</span>

<span class="tok-c1">;; =&gt; ([1 5] [2 4])</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We can combine the modifiers shown above for expressing complex sequence generations or<br>
more clearly expressing the intent of our comprehension:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">for </span><span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]</span>
      <span class="tok-nv">y</span> <span class="tok-p">[</span><span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">]</span>
      <span class="tok-ss">:let</span> <span class="tok-p">[</span><span class="tok-nv">z</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">)]</span>
      <span class="tok-ss">:when</span> <span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">z</span> <span class="tok-mi">6</span><span class="tok-p">)]</span>
  <span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">])</span>

<span class="tok-c1">;; =&gt; ([1 5] [2 4])</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>When we outlined the most common usages of the <code>for</code> construct in imperative programming languages,<br>
we mentioned that sometimes we want to run a computation for every value in a sequence, not caring<br>
about the result. Presumably we do this for achieving some sort of side-effect with the values of<br>
the sequence.</p>
</div>
<div class="paragraph">
<p>ClojureScript provides the <code>doseq</code> construct, which is analogous to <code>for</code> but executes the expression,<br>
discards the resulting values, and returns <code>nil</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">doseq </span><span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]</span>
        <span class="tok-nv">y</span> <span class="tok-p">[</span><span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">]</span>
       <span class="tok-ss">:let</span> <span class="tok-p">[</span><span class="tok-nv">z</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">)]]</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-nv">x</span> <span class="tok-s">&quot;+&quot;</span> <span class="tok-nv">y</span> <span class="tok-s">&quot;=&quot;</span> <span class="tok-nv">z</span><span class="tok-p">))</span>

<span class="tok-c1">;; 1 + 4 = 5</span>
<span class="tok-c1">;; 1 + 5 = 6</span>
<span class="tok-c1">;; 2 + 4 = 6</span>
<span class="tok-c1">;; 2 + 5 = 7</span>
<span class="tok-c1">;; 3 + 4 = 7</span>
<span class="tok-c1">;; 3 + 5 = 8</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="collection-types"><a class="link" href="#collection-types">3.7. Collection types</a></h3>
<div class="sect3">
<h4 id="immutable-and-persistent"><a class="link" href="#immutable-and-persistent">3.7.1. Immutable and persistent</a></h4>
<div class="paragraph">
<p>We mentioned before that ClojureScript collections are persistent and immutable, but we didn&#8217;t explain what<br>
that meant.</p>
</div>
<div class="paragraph">
<p>An immutable data structure, as its name suggests, is a data structure that cannot be changed. In-place<br>
updates are not allowed in immutable data structures.</p>
</div>
<div class="paragraph">
<p>A persistent data structure is a data structure that returns a new version of itself when transforming<br>
it, leaving the original unmodified. ClojureScript makes this memory and time efficient using an<br>
implementation technique called <em>structural sharing</em>, where most of the data shared between two versions<br>
of a value is not duplicated and transformations of a value are implemented by copying the minimal amount of data<br>
required.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see an example of appending values to a vector using the <code>conj</code> (conjoin) operation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">xs</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]</span>
      <span class="tok-nv">ys</span> <span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-nv">xs</span> <span class="tok-mi">4</span><span class="tok-p">)]</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;xs:&quot;</span> <span class="tok-nv">xs</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;ys:&quot;</span> <span class="tok-nv">ys</span><span class="tok-p">))</span>

<span class="tok-c1">;; xs: [1 2 3]</span>
<span class="tok-c1">;; ys: [1 2 3 4]</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, we derived a new version of the <code>xs</code> vector appending an element to it and got a new<br>
vector <code>ys</code> with the element added. However, the <code>xs</code> vector remained unchanged because it is immutable.</p>
</div>
<div class="paragraph">
<p>For illustrating the structural sharing of ClojureScript data structures, let&#8217;s compare whether some parts<br>
of the old and new versions of a data structure are actually the same object with the <code>identical?</code> predicate.<br>
We&#8217;ll use the list data type for this purpose:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">xs</span> <span class="tok-p">(</span><span class="tok-nb">list </span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
      <span class="tok-nv">ys</span> <span class="tok-p">(</span><span class="tok-nb">cons </span><span class="tok-mi">0</span> <span class="tok-nv">xs</span><span class="tok-p">)]</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;xs:&quot;</span> <span class="tok-nv">xs</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;ys:&quot;</span> <span class="tok-nv">ys</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;(rest ys):&quot;</span> <span class="tok-p">(</span><span class="tok-nb">rest </span><span class="tok-nv">ys</span><span class="tok-p">))</span>
  <span class="tok-p">(</span><span class="tok-nb">identical? </span><span class="tok-nv">xs</span> <span class="tok-p">(</span><span class="tok-nb">rest </span><span class="tok-nv">ys</span><span class="tok-p">)))</span>

<span class="tok-c1">;; xs: (1 2 3)</span>
<span class="tok-c1">;; ys: (0 1 2 3)</span>
<span class="tok-c1">;; (rest ys): (1 2 3)</span>
<span class="tok-c1">;; =&gt; true</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see in the example, we used <code>cons</code> (construct) to prepend a value to the <code>xs</code> list and we got<br>
a new list <code>ys</code> with the element added. The <code>rest</code> of the <code>ys</code> list (all the values but the first)<br>
are the same object in memory as the <code>xs</code> list, thus <code>xs</code> and <code>ys</code> share structure.</p>
</div>
</div>
<div class="sect3">
<h4 id="the-sequence-abstraction"><a class="link" href="#the-sequence-abstraction">3.7.2. The sequence abstraction</a></h4>
<div class="paragraph">
<p>One of the central ClojureScript abstractions is the <em>sequence</em> which can be thought of as a list and can be derived<br>
from any of the collection types. It is persistent and immutable like all collection types, and many of the<br>
core ClojureScript functions return sequences.</p>
</div>
<div class="paragraph">
<p>The types that can be used to generate a sequence are called "seqables"; we can call <code>seq</code> on them and get<br>
a sequence back. Sequences support two basic operations: <code>first</code> and <code>rest</code>. They both call <code>seq</code> on the<br>
argument we provide them:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">first </span><span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; 1</span>

<span class="tok-p">(</span><span class="tok-nb">rest </span><span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; (2 3)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Calling <code>seq</code> on a seqable can yield different results if the seqable is empty or not. It will return <code>nil</code><br>
when empty and a sequence otherwise:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">seq </span><span class="tok-p">[])</span>
<span class="tok-c1">;; =&gt; nil</span>

<span class="tok-p">(</span><span class="tok-nb">seq </span><span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; (1 2 3)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>next</code> is a similar sequence operation to <code>rest</code>, but it differs from the latter in that it yields a <code>nil</code> value<br>
when called with a sequence with one or zero elements. Note that, when given one of the aforementioned sequences,<br>
the empty sequence returned by <code>rest</code> will evaluate as a boolean true whereas the <code>nil</code> value returned by <code>next</code><br>
will evaluate as false (<a href="#truthiness-section">see the section on <em>truthiness</em> later in this chapter</a>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">rest </span><span class="tok-p">[])</span>
<span class="tok-c1">;; =&gt; ()</span>

<span class="tok-p">(</span><span class="tok-nb">next </span><span class="tok-p">[])</span>
<span class="tok-c1">;; =&gt; nil</span>

<span class="tok-p">(</span><span class="tok-nb">rest </span><span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; (2 3)</span>

<span class="tok-p">(</span><span class="tok-nb">next </span><span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; (2 3)</span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="nil-punning"><a class="link" href="#nil-punning">nil-punning</a></h5>
<div class="paragraph">
<p>Since <code>seq</code> returns <code>nil</code> when the collection is empty, and <code>nil</code> evaluates to false in boolean context, you can check to see if a collection is empty by using the <code>seq</code> function. The technical term for this is nil-punning.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">print-coll</span>
  <span class="tok-p">[</span><span class="tok-nv">coll</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">when </span><span class="tok-p">(</span><span class="tok-nb">seq </span><span class="tok-nv">coll</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Saw &quot;</span> <span class="tok-p">(</span><span class="tok-nb">first </span><span class="tok-nv">coll</span><span class="tok-p">))</span>
    <span class="tok-p">(</span><span class="tok-nf">recur</span> <span class="tok-p">(</span><span class="tok-nb">rest </span><span class="tok-nv">coll</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-nf">print-coll</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
<span class="tok-c1">;; Saw 1</span>
<span class="tok-c1">;; Saw 2</span>
<span class="tok-c1">;; Saw 3</span>
<span class="tok-c1">;; =&gt; nil</span>

<span class="tok-p">(</span><span class="tok-nf">print-coll</span> <span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">})</span>
<span class="tok-c1">;; Saw 1</span>
<span class="tok-c1">;; Saw 3</span>
<span class="tok-c1">;; Saw 2</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Though <code>nil</code> is neither a seqable nor a sequence, it is supported by all the functions we saw so far:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">seq </span><span class="tok-nv">nil</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; nil</span>

<span class="tok-p">(</span><span class="tok-nb">first </span><span class="tok-nv">nil</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; nil</span>

<span class="tok-p">(</span><span class="tok-nb">rest </span><span class="tok-nv">nil</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; ()</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="functions-that-work-on-sequences"><a class="link" href="#functions-that-work-on-sequences">Functions that work on sequences</a></h5>
<div class="paragraph">
<p>The ClojureScript core functions for transforming collections make sequences out of their arguments and are<br>
implemented in terms of the generic sequence operations we learned about in the preceding section. This makes<br>
them highly generic because we can use them on any data type that is seqable. Let&#8217;s see how we can use <code>map</code> with<br>
a variety of seqables:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">map inc </span><span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; (2 3 4)</span>

<span class="tok-p">(</span><span class="tok-nb">map inc </span><span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; (2 4 3)</span>

<span class="tok-p">(</span><span class="tok-nb">map count </span><span class="tok-p">{</span><span class="tok-ss">:a</span> <span class="tok-mi">41</span> <span class="tok-ss">:b</span> <span class="tok-mi">40</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; (2 2)</span>

<span class="tok-p">(</span><span class="tok-nb">map inc </span><span class="tok-o">&#39;</span><span class="tok-p">(</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; (2 3 4)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note: When you use the <code>map</code> function on a map collection, your higher-order function<br>
will receive a two-item vector containing a key and value from the map. The following example<br>
uses <a href="#destructuring-section">destructuring</a> to access the key and value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[[</span><span class="tok-nb">key </span><span class="tok-nv">value</span><span class="tok-p">]]</span> <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-nv">value</span> <span class="tok-nv">value</span><span class="tok-p">))</span> <span class="tok-p">{</span><span class="tok-ss">:ten</span> <span class="tok-mi">10</span> <span class="tok-ss">:seven</span> <span class="tok-mi">7</span> <span class="tok-ss">:four</span> <span class="tok-mi">4</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; (100 49 16)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you may have noticed, functions that operate on sequences are safe to use with empty collections or even<br>
<code>nil</code> values since they don&#8217;t need to do anything but return an empty sequence when encountering such values.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">map inc </span><span class="tok-p">[])</span>
<span class="tok-c1">;; =&gt; ()</span>

<span class="tok-p">(</span><span class="tok-nb">map inc </span><span class="tok-o">#</span><span class="tok-p">{})</span>
<span class="tok-c1">;; =&gt; ()</span>

<span class="tok-p">(</span><span class="tok-nb">map inc </span><span class="tok-nv">nil</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; ()</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We already saw examples with the usual suspects like <code>map</code>, <code>filter</code>, and <code>reduce</code>, but ClojureScript offers a<br>
plethora of generic sequence operations in its core namespace. Note that many of the operations we&#8217;ll learn about<br>
either work with seqables or are extensible to user-defined types.</p>
</div>
<div class="paragraph">
<p>We can query a value to know whether it&#8217;s a collection type with the <code>coll?</code> predicate:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">coll?</span> <span class="tok-nv">nil</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; false</span>

<span class="tok-p">(</span><span class="tok-nf">coll?</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nf">coll?</span> <span class="tok-p">{</span><span class="tok-ss">:language</span> <span class="tok-s">&quot;ClojureScript&quot;</span> <span class="tok-ss">:file-extension</span> <span class="tok-s">&quot;cljs&quot;</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nf">coll?</span> <span class="tok-s">&quot;ClojureScript&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; false</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Similar predicates exist for checking if a value is a sequence (<code>seq?</code>) or a seqable (<code>seqable?</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">seq? </span><span class="tok-nv">nil</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; false</span>
<span class="tok-p">(</span><span class="tok-nf">seqable?</span> <span class="tok-nv">nil</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; false</span>

<span class="tok-p">(</span><span class="tok-nb">seq? </span><span class="tok-p">[])</span>
<span class="tok-c1">;; =&gt; false</span>
<span class="tok-p">(</span><span class="tok-nf">seqable?</span> <span class="tok-p">[])</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nb">seq? </span><span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; false</span>
<span class="tok-p">(</span><span class="tok-nf">seqable?</span> <span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nb">seq? </span><span class="tok-s">&quot;ClojureScript&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; false</span>
<span class="tok-p">(</span><span class="tok-nf">seqable?</span> <span class="tok-s">&quot;ClojureScript&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; false</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For collections that can be counted in constant time, we can use the <code>count</code> operation. This operation also works on strings, even though, as you have seen, they are not collections, sequences, or seqable.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">count </span><span class="tok-nv">nil</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 0</span>

<span class="tok-p">(</span><span class="tok-nb">count </span><span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; 3</span>

<span class="tok-p">(</span><span class="tok-nb">count </span><span class="tok-p">{</span><span class="tok-ss">:language</span> <span class="tok-s">&quot;ClojureScript&quot;</span> <span class="tok-ss">:file-extension</span> <span class="tok-s">&quot;cljs&quot;</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; 2</span>

<span class="tok-p">(</span><span class="tok-nb">count </span><span class="tok-s">&quot;ClojureScript&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 13</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We can also get an empty variant of a given collection with the <code>empty</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">empty</span> <span class="tok-nv">nil</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; nil</span>

<span class="tok-p">(</span><span class="tok-nf">empty</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; []</span>

<span class="tok-p">(</span><span class="tok-nf">empty</span> <span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; #{}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>empty?</code> predicate returns true if the given collection is empty:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">empty?</span> <span class="tok-nv">nil</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nf">empty?</span> <span class="tok-p">[])</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nf">empty?</span> <span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; false</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>conj</code> operation adds elements to collections and may add them in different "places" depending<br>
on the type of collection. It adds them where it is most performant for the collection type,<br>
but note that not every collection has a defined order.</p>
</div>
<div class="paragraph">
<p>We can pass as many elements as we want to add to <code>conj</code>; let&#8217;s see it in action:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-nv">nil</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; (42)</span>

<span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">]</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [1 2 3]</span>

<span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">]</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [1 2 3 4 5]</span>

<span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-o">&#39;</span><span class="tok-p">(</span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">)</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; (0 1 2)</span>

<span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">}</span> <span class="tok-mi">4</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #{1 3 2 4}</span>

<span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-p">{</span><span class="tok-ss">:language</span> <span class="tok-s">&quot;ClojureScript&quot;</span><span class="tok-p">}</span> <span class="tok-p">[</span><span class="tok-ss">:file-extension</span> <span class="tok-s">&quot;cljs&quot;</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; {:language &quot;ClojureScript&quot;, :file-extension &quot;cljs&quot;}</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="laziness"><a class="link" href="#laziness">Laziness</a></h5>
<div class="paragraph">
<p>Most of ClojureScript&#8217;s sequence-returning functions generate lazy sequences instead of eagerly creating<br>
a whole new sequence. Lazy sequences generate their contents as they are requested, usually when iterating<br>
over them. Laziness ensures that we don&#8217;t do more work than we need to and gives us the possibility of<br>
treating potentially infinite sequences as regular ones.</p>
</div>
<div class="paragraph">
<p>Consider the <code>range</code> function, which generates a range of integers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">5</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; (0 1 2 3 4)</span>
<span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">1</span> <span class="tok-mi">10</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; (1 2 3 4 5 6 7 8 9)</span>
<span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">10</span> <span class="tok-mi">100</span> <span class="tok-mi">15</span><span class="tok-p">)</span>
<span class="tok-c1">;; (10 25 40 55 70 85)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If you just say <code>(range)</code>, you will get an infinite sequence of all the integers.<br>
Do <strong>not</strong> try this in the REPL, unless you are prepared to wait for a very, very long time, because<br>
the REPL wants to fully evaluate the expression.</p>
</div>
<div class="paragraph">
<p>Here is a contrived example. Let&#8217;s say you are writing a graphing program and you are graphing the<br>
equation <em>y</em>= 2_x_<sup>2</sup> + 5, and you want only those values of <em>x</em> for which the <em>y</em> value is less than 100.<br>
You can generate all the numbers 0 through 100, which will certainly be enough, and then <code>take-while</code><br>
the condition holds:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">take-while </span><span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">&lt; </span><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-mi">2</span> <span class="tok-nv">x</span> <span class="tok-nv">x</span><span class="tok-p">)</span> <span class="tok-mi">5</span><span class="tok-p">)</span> <span class="tok-mi">100</span><span class="tok-p">))</span> <span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">0</span> <span class="tok-mi">100</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; (0 1 2 3 4 5 6)</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="collections-in-depth"><a class="link" href="#collections-in-depth">3.7.3. Collections in depth</a></h4>
<div class="paragraph">
<p>Now that we&#8217;re acquainted with ClojureScript&#8217;s sequence abstraction and some of the generic sequence manipulating<br>
functions, it&#8217;s time to dive into the concrete collection types and the operations they support.</p>
</div>
<div class="sect4">
<h5 id="lists-2"><a class="link" href="#lists-2">Lists</a></h5>
<div class="paragraph">
<p>In ClojureScript, lists are mostly used as a data structure for grouping symbols together into programs. Unlike in other<br>
Lisps, many of the syntactic constructs of ClojureScript use data structures different from the list (vectors and maps).<br>
This makes code less uniform, but the gains in readability are well worth the price.</p>
</div>
<div class="paragraph">
<p>You can think of ClojureScript lists as singly linked lists, where each node contains a value and a pointer to the rest of the list.<br>
This makes it natural (and fast!) to add items to the front of the list, since adding to the end would require traversal of the entire<br>
list. The prepend operation is performed using the <code>cons</code> (construct) function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">cons </span><span class="tok-mi">0</span> <span class="tok-p">(</span><span class="tok-nb">cons </span><span class="tok-mi">1</span> <span class="tok-p">(</span><span class="tok-nb">cons </span><span class="tok-mi">2</span> <span class="tok-p">())))</span>
<span class="tok-c1">;; =&gt; (0 1 2)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We used the literal <code>()</code> to represent the empty list. Since it doesn&#8217;t contain any symbols, it is not treated<br>
as a function call. However, when using list literals that contain elements, we need to quote them to<br>
prevent ClojureScript from evaluating them as a function call:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">cons </span><span class="tok-mi">0</span> <span class="tok-o">&#39;</span><span class="tok-p">(</span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; (0 1 2)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Since the head is the position that has constant time addition in the list collection, the <code>conj</code> operation<br>
on lists naturally adds items to the front:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-o">&#39;</span><span class="tok-p">(</span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">)</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; (0 1 2)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Lists and other ClojureScript data structures can be used as stacks using the <code>peek</code>, <code>pop</code>, and <code>conj</code> functions.<br>
Note that the top of the stack will be the "place" where <code>conj</code> adds elements, making <code>conj</code> equivalent to the<br>
stack&#8217;s push operation. In the case of lists, <code>conj</code> adds elements to the front of the list, <code>peek</code> returns the first<br>
element of the list, and <code>pop</code> returns a list with all the elements but the first one.</p>
</div>
<div class="paragraph">
<p>Note that the two operations that return a stack (<code>conj</code> and <code>pop</code>) don&#8217;t change the type of the collection used for<br>
the stack.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">list-stack</span> <span class="tok-o">&#39;</span><span class="tok-p">(</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nb">peek </span><span class="tok-nv">list-stack</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 0</span>

<span class="tok-p">(</span><span class="tok-nb">pop </span><span class="tok-nv">list-stack</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; (1 2)</span>

<span class="tok-p">(</span><span class="tok-nf">type</span> <span class="tok-p">(</span><span class="tok-nb">pop </span><span class="tok-nv">list-stack</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; cljs.core/List</span>

<span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-nv">list-stack</span> <span class="tok-mi">-1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; (-1 0 1 2)</span>

<span class="tok-p">(</span><span class="tok-nf">type</span> <span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-nv">list-stack</span> <span class="tok-mi">-1</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; cljs.core/List</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>One thing that lists are not particularly good at is random indexed access. Since they are stored in a single linked list-like<br>
structure in memory, random access to a given index requires a linear traversal in order to either retrieve the requested<br>
item or throw an index out of bounds error. Non-indexed ordered collections like lazy sequences also suffer from this limitation.</p>
</div>
</div>
<div class="sect4">
<h5 id="vectors-2"><a class="link" href="#vectors-2">Vectors</a></h5>
<div class="paragraph">
<p>Vectors are one of the most common data structures in ClojureScript. They are used as a syntactic construct in many<br>
places where more traditional Lisps use lists, for example in function argument declarations and <code>let</code> bindings.</p>
</div>
<div class="paragraph">
<p>ClojureScript vectors have enclosing brackets <code>[]</code> in their syntax literals. They can be created with <code>vector</code> and from<br>
another collection with <code>vec</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">vector? </span><span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nb">vector </span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [0 1 2]</span>

<span class="tok-p">(</span><span class="tok-nf">vec</span> <span class="tok-o">&#39;</span><span class="tok-p">(</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; [0 1 2]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Vectors are, like lists, ordered collections of heterogeneous values. Unlike lists, vectors grow naturally from the tail,<br>
so the <code>conj</code> operation appends items to the end of a vector. Insertion on the end of a vector is effectively constant<br>
time:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span><span class="tok-p">]</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [0 1 2]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Another thing that differentiates lists and vectors is that vectors are indexed collections and as such support efficient<br>
random index access and non-destructive updates. We can use the <code>nth</code> function to retrieve values given an index:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">nth </span><span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">]</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Since vectors associate sequential numeric keys (indexes) to values, we can treat them as an associative data structure. ClojureScript<br>
provides the <code>assoc</code> function that, given an associative data structure and a set of key-value pairs, yields a new data structure with<br>
the values corresponding to the keys modified. Indexes begin at zero for the first element in a vector.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">assoc </span><span class="tok-p">[</span><span class="tok-s">&quot;cero&quot;</span> <span class="tok-s">&quot;uno&quot;</span> <span class="tok-s">&quot;two&quot;</span><span class="tok-p">]</span> <span class="tok-mi">2</span> <span class="tok-s">&quot;dos&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [&quot;cero&quot; &quot;uno&quot; &quot;dos&quot;]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that we can only <code>assoc</code> to a key that is either contained in the vector already or if it is the last position in a vector:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">assoc </span><span class="tok-p">[</span><span class="tok-s">&quot;cero&quot;</span> <span class="tok-s">&quot;uno&quot;</span> <span class="tok-s">&quot;dos&quot;</span><span class="tok-p">]</span> <span class="tok-mi">3</span> <span class="tok-s">&quot;tres&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [&quot;cero&quot; &quot;uno&quot; &quot;dos&quot; &quot;tres&quot;]</span>

<span class="tok-p">(</span><span class="tok-nb">assoc </span><span class="tok-p">[</span><span class="tok-s">&quot;cero&quot;</span> <span class="tok-s">&quot;uno&quot;</span> <span class="tok-s">&quot;dos&quot;</span><span class="tok-p">]</span> <span class="tok-mi">4</span> <span class="tok-s">&quot;cuatro&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; Error: Index 4 out of bounds [0,3]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Perhaps surprisingly, associative data structures can also be used as functions. They are functions of their keys to the values they<br>
are associated with. In the case of vectors, if the given key is not present an exception is thrown:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">([</span><span class="tok-s">&quot;cero&quot;</span> <span class="tok-s">&quot;uno&quot;</span> <span class="tok-s">&quot;dos&quot;</span><span class="tok-p">]</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;cero&quot;</span>

<span class="tok-p">([</span><span class="tok-s">&quot;cero&quot;</span> <span class="tok-s">&quot;uno&quot;</span> <span class="tok-s">&quot;dos&quot;</span><span class="tok-p">]</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;dos&quot;</span>

<span class="tok-p">([</span><span class="tok-s">&quot;cero&quot;</span> <span class="tok-s">&quot;uno&quot;</span> <span class="tok-s">&quot;dos&quot;</span><span class="tok-p">]</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-c1">;; Error: Not item 3 in vector of length 3</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As with lists, vectors can also be used as stacks with the <code>peek</code>, <code>pop</code>, and <code>conj</code> functions. Note, however, that vectors grow<br>
from the opposite end of the collection as lists:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">vector-stack</span> <span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nb">peek </span><span class="tok-nv">vector-stack</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 2</span>

<span class="tok-p">(</span><span class="tok-nb">pop </span><span class="tok-nv">vector-stack</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [0 1]</span>

<span class="tok-p">(</span><span class="tok-nf">type</span> <span class="tok-p">(</span><span class="tok-nb">pop </span><span class="tok-nv">vector-stack</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; cljs.core/PersistentVector</span>

<span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-nv">vector-stack</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [0 1 2 3]</span>

<span class="tok-p">(</span><span class="tok-nf">type</span> <span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-nv">vector-stack</span> <span class="tok-mi">3</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; cljs.core/PersistentVector</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>map</code> and <code>filter</code> operations return lazy sequences, but as it is common to need a fully realized sequence after performing those operations, vector-returning counterparts of such functions are available as <code>mapv</code> and <code>filterv</code>. They have the advantages of being<br>
faster than building a vector from a lazy sequence and making your intent more explicit:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">map inc </span><span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; (1 2 3)</span>

<span class="tok-p">(</span><span class="tok-nf">type</span> <span class="tok-p">(</span><span class="tok-nb">map inc </span><span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">]))</span>
<span class="tok-c1">;; =&gt; cljs.core/LazySeq</span>

<span class="tok-p">(</span><span class="tok-nf">mapv</span> <span class="tok-nb">inc </span><span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; [1 2 3]</span>

<span class="tok-p">(</span><span class="tok-nf">type</span> <span class="tok-p">(</span><span class="tok-nf">mapv</span> <span class="tok-nb">inc </span><span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">]))</span>
<span class="tok-c1">;; =&gt; cljs.core/PersistentVector</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="maps"><a class="link" href="#maps">Maps</a></h5>
<div class="paragraph">
<p>Maps are ubiquitous in ClojureScript. Like vectors, they are also used as a syntactic construct, particularly for attaching<br>
<a href="#metadata-section">metadata</a> to vars. Any ClojureScript data structure can be used as a key in a map, although it&#8217;s common<br>
to use keywords since they can<br>
also be called as functions.</p>
</div>
<div class="paragraph">
<p>ClojureScript maps are written literally as key-value pairs enclosed in braces <code>{}</code>. Alternatively, they can be created<br>
with the <code>hash-map</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">map? </span><span class="tok-p">{</span><span class="tok-ss">:name</span> <span class="tok-s">&quot;Cirilla&quot;</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nb">hash-map </span><span class="tok-ss">:name</span> <span class="tok-s">&quot;Cirilla&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:name &quot;Cirilla&quot;}</span>

<span class="tok-p">(</span><span class="tok-nb">hash-map </span><span class="tok-ss">:name</span> <span class="tok-s">&quot;Cirilla&quot;</span> <span class="tok-ss">:surname</span> <span class="tok-s">&quot;Fiona&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:name &quot;Cirilla&quot; :surname &quot;Fiona&quot;}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Since regular maps don&#8217;t have a specific order, the <code>conj</code> operation just adds one or more key-value pairs to a map. <code>conj</code><br>
for maps expects one or more sequences of key-value pairs as its last arguments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ciri</span> <span class="tok-p">{</span><span class="tok-ss">:name</span> <span class="tok-s">&quot;Cirilla&quot;</span><span class="tok-p">})</span>

<span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-nv">ciri</span> <span class="tok-p">[</span><span class="tok-ss">:surname</span> <span class="tok-s">&quot;Fiona&quot;</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; {:name &quot;Cirilla&quot;, :surname &quot;Fiona&quot;}</span>

<span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-nv">ciri</span> <span class="tok-p">[</span><span class="tok-ss">:surname</span> <span class="tok-s">&quot;Fiona&quot;</span><span class="tok-p">]</span> <span class="tok-p">[</span><span class="tok-ss">:occupation</span> <span class="tok-s">&quot;Wizard&quot;</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; {:name &quot;Cirilla&quot;, :surname &quot;Fiona&quot;, :occupation &quot;Wizard&quot;}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, it just so happens that the order was preserved, but if you have many keys, you will see that<br>
the order is not preserved.</p>
</div>
<div class="paragraph">
<p>Maps associate keys to values and, as such, are an associative data structure. They support adding associations with <code>assoc</code> and,<br>
unlike vectors, removing them with <code>dissoc</code>. <code>assoc</code> will also update the value of an existing key. Let&#8217;s explore these functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">assoc </span><span class="tok-p">{</span><span class="tok-ss">:name</span> <span class="tok-s">&quot;Cirilla&quot;</span><span class="tok-p">}</span> <span class="tok-ss">:surname</span> <span class="tok-s">&quot;Fiona&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:name &quot;Cirilla&quot;, :surname &quot;Fiona&quot;}</span>
<span class="tok-p">(</span><span class="tok-nb">assoc </span><span class="tok-p">{</span><span class="tok-ss">:name</span> <span class="tok-s">&quot;Cirilla&quot;</span><span class="tok-p">}</span> <span class="tok-ss">:name</span> <span class="tok-s">&quot;Alfonso&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:name &quot;Alfonso&quot;}</span>
<span class="tok-p">(</span><span class="tok-nb">dissoc </span><span class="tok-p">{</span><span class="tok-ss">:name</span> <span class="tok-s">&quot;Cirilla&quot;</span><span class="tok-p">}</span> <span class="tok-ss">:name</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Maps are also functions of their keys, returning the values related to the given keys. Unlike vectors, they return <code>nil</code> if we supply<br>
a key that is not present in the map:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">({</span><span class="tok-ss">:name</span> <span class="tok-s">&quot;Cirilla&quot;</span><span class="tok-p">}</span> <span class="tok-ss">:name</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;Cirilla&quot;</span>

<span class="tok-p">({</span><span class="tok-ss">:name</span> <span class="tok-s">&quot;Cirilla&quot;</span><span class="tok-p">}</span> <span class="tok-ss">:surname</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>ClojureScript also offers sorted hash maps which behave like their unsorted versions but preserve order when iterating over them. We<br>
can create a sorted map with default ordering with <code>sorted-map</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">sm</span> <span class="tok-p">(</span><span class="tok-nb">sorted-map </span><span class="tok-ss">:c</span> <span class="tok-mi">2</span> <span class="tok-ss">:b</span> <span class="tok-mi">1</span> <span class="tok-ss">:a</span> <span class="tok-mi">0</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; {:a 0, :b 1, :c 2}</span>

<span class="tok-p">(</span><span class="tok-nb">keys </span><span class="tok-nv">sm</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; (:a :b :c)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If we need a custom ordering we can provide a comparator function to <code>sorted-map-by</code>, let&#8217;s see an example inverting the value<br>
returned by the built-in <code>compare</code> function. Comparator functions take two items to compare<br>
and return -1 (if the first item is less than the second), 0 (if they are equal),<br>
or 1 (if the first item is greater than the second).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">reverse-compare</span> <span class="tok-p">[</span><span class="tok-nv">a</span> <span class="tok-nv">b</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nf">compare</span> <span class="tok-nv">b</span> <span class="tok-nv">a</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">sm</span> <span class="tok-p">(</span><span class="tok-nb">sorted-map-by </span><span class="tok-nv">reverse-compare</span> <span class="tok-ss">:a</span> <span class="tok-mi">0</span> <span class="tok-ss">:b</span> <span class="tok-mi">1</span> <span class="tok-ss">:c</span> <span class="tok-mi">2</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; {:c 2, :b 1, :a 0}</span>

<span class="tok-p">(</span><span class="tok-nb">keys </span><span class="tok-nv">sm</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; (:c :b :a)</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sets-2"><a class="link" href="#sets-2">Sets</a></h5>
<div class="paragraph">
<p>Sets in ClojureScript have literal syntax as values enclosed in <code>#{}</code> and they can be created with the <code>set</code> constructor. They are<br>
unordered collections of values without duplicates.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">set?</span> <span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-sc">\a</span> <span class="tok-sc">\e</span> <span class="tok-sc">\i</span> <span class="tok-sc">\o</span> <span class="tok-sc">\u</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nb">set </span><span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; #{1 2 3}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Set literals cannot contain duplicate values. If you accidentally write a set literal with duplicates an error will be thrown:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-mi">1</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">}</span>
<span class="tok-c1">;; clojure.lang.ExceptionInfo: Duplicate key: 1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are many operations that can be performed with sets, although they are located in the <code>clojure.set</code> namespace and thus<br>
need to be imported. You&#8217;ll learn <a href="#namespace-section">the details of namespacing</a> later; for now, you only need to know that<br>
we are loading a namespace called <code>clojure.set</code> and binding it to the <code>s</code> symbol.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">clojure.set</span> <span class="tok-ss">:as</span> <span class="tok-nv">s</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">danish-vowels</span> <span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-sc">\a</span> <span class="tok-sc">\e</span> <span class="tok-sc">\i</span> <span class="tok-sc">\o</span> <span class="tok-sc">\u</span> <span class="tok-sc">\æ</span> <span class="tok-sc">\ø</span> <span class="tok-sc">\å</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; #{&quot;a&quot; &quot;e&quot; &quot;å&quot; &quot;æ&quot; &quot;i&quot; &quot;o&quot; &quot;u&quot; &quot;ø&quot;}</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">spanish-vowels</span> <span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-sc">\a</span> <span class="tok-sc">\e</span> <span class="tok-sc">\i</span> <span class="tok-sc">\o</span> <span class="tok-sc">\u</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; #{&quot;a&quot; &quot;e&quot; &quot;i&quot; &quot;o&quot; &quot;u&quot;}</span>

<span class="tok-p">(</span><span class="tok-nf">s/difference</span> <span class="tok-nv">danish-vowels</span> <span class="tok-nv">spanish-vowels</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #{&quot;å&quot; &quot;æ&quot; &quot;ø&quot;}</span>

<span class="tok-p">(</span><span class="tok-nf">s/union</span> <span class="tok-nv">danish-vowels</span> <span class="tok-nv">spanish-vowels</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #{&quot;a&quot; &quot;e&quot; &quot;å&quot; &quot;æ&quot; &quot;i&quot; &quot;o&quot; &quot;u&quot; &quot;ø&quot;}</span>

<span class="tok-p">(</span><span class="tok-nf">s/intersection</span> <span class="tok-nv">danish-vowels</span> <span class="tok-nv">spanish-vowels</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #{&quot;a&quot; &quot;e&quot; &quot;i&quot; &quot;o&quot; &quot;u&quot;}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A nice property of immutable sets is that they can be nested. Languages that have mutable sets can end up containing duplicate values,<br>
but that can&#8217;t happen in ClojureScript. In fact, all ClojureScript data structures can be nested arbitrarily due to immutability.</p>
</div>
<div class="paragraph">
<p>Sets also support the generic <code>conj</code> operation just like every other collection does.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">spanish-vowels</span> <span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-sc">\a</span> <span class="tok-sc">\e</span> <span class="tok-sc">\i</span> <span class="tok-sc">\o</span> <span class="tok-sc">\u</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; #{&quot;a&quot; &quot;e&quot; &quot;i&quot; &quot;o&quot; &quot;u&quot;}</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">danish-vowels</span> <span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-nv">spanish-vowels</span> <span class="tok-sc">\æ</span> <span class="tok-sc">\ø</span> <span class="tok-sc">\å</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #{&quot;a&quot; &quot;e&quot; &quot;i&quot; &quot;o&quot; &quot;u&quot; &quot;æ&quot; &quot;ø&quot; &quot;å&quot;}</span>

<span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">}</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #{1 3 2}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Sets act as read-only associative data that associates the values it contains to themselves. Since every value except <code>nil</code> and <code>false</code><br>
is truthy in ClojureScript, we can use sets as predicate functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">vowels</span> <span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-sc">\a</span> <span class="tok-sc">\e</span> <span class="tok-sc">\i</span> <span class="tok-sc">\o</span> <span class="tok-sc">\u</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; #{&quot;a&quot; &quot;e&quot; &quot;i&quot; &quot;o&quot; &quot;u&quot;}</span>

<span class="tok-p">(</span><span class="tok-nb">get </span><span class="tok-nv">vowels</span> <span class="tok-sc">\b</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; nil</span>

<span class="tok-p">(</span><span class="tok-nb">contains? </span><span class="tok-nv">vowels</span> <span class="tok-sc">\b</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; false</span>

<span class="tok-p">(</span><span class="tok-nf">vowels</span> <span class="tok-sc">\a</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;a&quot;</span>

<span class="tok-p">(</span><span class="tok-nf">vowels</span> <span class="tok-sc">\z</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; nil</span>

<span class="tok-p">(</span><span class="tok-nb">filter </span><span class="tok-nv">vowels</span> <span class="tok-s">&quot;Hound dog&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; (&quot;o&quot; &quot;u&quot; &quot;o&quot;)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Sets have a sorted counterpart like maps do that are created using the functions <code>sorted-set</code> and <code>sorted-set-by</code> which are analogous to map&#8217;s <code>sorted-map</code> and <code>sorted-map-by</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">unordered-set</span> <span class="tok-o">#</span><span class="tok-p">{[</span><span class="tok-mi">0</span><span class="tok-p">]</span> <span class="tok-p">[</span><span class="tok-mi">1</span><span class="tok-p">]</span> <span class="tok-p">[</span><span class="tok-mi">2</span><span class="tok-p">]})</span>
<span class="tok-c1">;; =&gt; #{[0] [2] [1]}</span>

<span class="tok-p">(</span><span class="tok-nb">seq </span><span class="tok-nv">unordered-set</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; ([0] [2] [1])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ordered-set</span> <span class="tok-p">(</span><span class="tok-nb">sorted-set </span><span class="tok-p">[</span><span class="tok-mi">0</span><span class="tok-p">]</span> <span class="tok-p">[</span><span class="tok-mi">1</span><span class="tok-p">]</span> <span class="tok-p">[</span><span class="tok-mi">2</span><span class="tok-p">]))</span>
<span class="tok-c1">;; =&gt;# {[0] [1] [2]}</span>

<span class="tok-p">(</span><span class="tok-nb">seq </span><span class="tok-nv">ordered-set</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; ([0] [1] [2])</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="queues"><a class="link" href="#queues">Queues</a></h5>
<div class="paragraph">
<p>ClojureScript also provides a persistent and immutable queue. Queues are not used as pervasively as other collection types.  They can be created using the <code>#queue []</code> literal syntax, but there are no convenient constructor functions for them.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">pq</span> <span class="tok-o">#</span><span class="tok-nv">queue</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; #queue [1 2 3]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Using <code>conj</code> to add values to a queue adds items onto the rear:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">pq</span> <span class="tok-o">#</span><span class="tok-nv">queue</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; #queue [1 2 3]</span>

<span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-nv">pq</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #queue [1 2 3 4 5]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A thing to bear in mind about queues is that the stack operations don&#8217;t follow the usual stack semantics (pushing and popping from the same end). <code>pop</code> takes values from the front position, and <code>conj</code> pushes (appends) elements to the back.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">pq</span> <span class="tok-o">#</span><span class="tok-nv">queue</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; #queue [1 2 3]</span>

<span class="tok-p">(</span><span class="tok-nb">peek </span><span class="tok-nv">pq</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 1</span>

<span class="tok-p">(</span><span class="tok-nb">pop </span><span class="tok-nv">pq</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #queue [2 3]</span>

<span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-nv">pq</span> <span class="tok-mi">4</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #queue [1 2 3 4]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Queues are not as frequently used as lists or vectors, but it is good to know that they are available in ClojureScript, as they may occasionally come in handy.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="destructuring-section"><a class="link" href="#destructuring-section">3.8. Destructuring</a></h3>
<div class="paragraph">
<p>Destructuring, as its name suggests, is a way of taking apart structured data such as collections<br>
and focusing on individual parts of them. ClojureScript offers a concise syntax for destructuring<br>
both indexed sequences and associative data structures that can be used any place where bindings<br>
are declared.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see an example of what destructuring is useful for that will help us understand the previous<br>
statements better. Imagine that you have a sequence but are only interested in the first and third<br>
item. You could get a reference to them easily with the <code>nth</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">v</span> <span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">]</span>
      <span class="tok-nv">fst</span> <span class="tok-p">(</span><span class="tok-nb">nth </span><span class="tok-nv">v</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
      <span class="tok-nv">thrd</span> <span class="tok-p">(</span><span class="tok-nb">nth </span><span class="tok-nv">v</span> <span class="tok-mi">2</span><span class="tok-p">)]</span>
  <span class="tok-p">[</span><span class="tok-nv">thrd</span> <span class="tok-nv">fst</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; [2 0]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>However, the previous code is overly verbose. Destructuring lets us extract values of indexed<br>
sequences more succintly using a vector on the left-hand side of a binding:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[[</span><span class="tok-nv">fst</span> <span class="tok-nv">_</span> <span class="tok-nv">thrd</span><span class="tok-p">]</span> <span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">]]</span>
  <span class="tok-p">[</span><span class="tok-nv">thrd</span> <span class="tok-nv">fst</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; [2 0]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example, <code>[fst _ thrd]</code> is a destructuring form. It is represented as a vector and<br>
used for binding indexed values to the symbols <code>fst</code> and <code>thrd</code>, corresponding to the index <code>0</code><br>
and <code>2</code>, respectively. The <code>_</code> symbol is used as a placeholder for indexes we are not interested<br>
in — in this case <code>1</code>.</p>
</div>
<div class="paragraph">
<p>Note that destructuring is not limited to the <code>let</code> binding form; it works in almost every place<br>
where we bind values to symbols such as in the <code>for</code> and <code>doseq</code> special forms or in function<br>
arguments. We can write a function that takes a pair and swaps its positions very concisely using<br>
destructuring syntax in function arguments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">swap-pair</span> <span class="tok-p">[[</span><span class="tok-nv">fst</span> <span class="tok-nv">snd</span><span class="tok-p">]]</span>
  <span class="tok-p">[</span><span class="tok-nv">snd</span> <span class="tok-nv">fst</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">swap-pair</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; [2 1]</span>

<span class="tok-p">(</span><span class="tok-nf">swap-pair</span> <span class="tok-o">&#39;</span><span class="tok-p">(</span><span class="tok-mi">3</span> <span class="tok-mi">4</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; [4 3]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Positional destructuring with vectors is quite handy for taking indexed values out of sequences,<br>
but sometimes we don&#8217;t want to discard the rest of the elements in the sequence when destructuring.<br>
Similarly to how <code>&amp;</code> is used for accepting variadic function arguments, the ampersand can be used<br>
inside a vector destructuring form for grouping together the rest of a sequence:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[[</span><span class="tok-nv">fst</span> <span class="tok-nv">snd</span> <span class="tok-o">&amp;</span> <span class="tok-nv">more</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">10</span><span class="tok-p">)]</span>
  <span class="tok-p">{</span><span class="tok-ss">:first</span> <span class="tok-nv">fst</span>
   <span class="tok-ss">:snd</span> <span class="tok-nv">snd</span>
   <span class="tok-ss">:rest</span> <span class="tok-nv">more</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; {:first 0, :snd 1, :rest (2 3 4 5 6 7 8 9)}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice how the value in the <code>0</code> index got bound to <code>fst</code>, the value in the <code>1</code> index got bound to<br>
<code>snd</code>, and the sequence of elements from <code>2</code> onwards got bound to the <code>more</code> symbol.</p>
</div>
<div class="paragraph">
<p>We may still be interested in a data structure as a whole even when we are destructuring it. This<br>
can be achieved with the <code>:as</code> keyword. If used inside a destructuring form, the original data<br>
structure is bound to the symbol following that keyword:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[[</span><span class="tok-nv">fst</span> <span class="tok-nv">snd</span> <span class="tok-o">&amp;</span> <span class="tok-nv">more</span> <span class="tok-ss">:as</span> <span class="tok-nv">original</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">10</span><span class="tok-p">)]</span>
  <span class="tok-p">{</span><span class="tok-ss">:first</span> <span class="tok-nv">fst</span>
   <span class="tok-ss">:snd</span> <span class="tok-nv">snd</span>
   <span class="tok-ss">:rest</span> <span class="tok-nv">more</span>
   <span class="tok-ss">:original</span> <span class="tok-nv">original</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; {:first 0, :snd 1, :rest (2 3 4 5 6 7 8 9), :original (0 1 2 3 4 5 6 7 8 9)}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Not only can indexed sequences be destructured, but associative data can also be destructured. Its<br>
destructuring binding form is represented as a map instead of a vector, where the keys are the<br>
symbols we want to bind values to and the values are the keys that we want to look up in the<br>
associative data structure. Let&#8217;s see an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[{</span><span class="tok-nv">language</span> <span class="tok-ss">:language</span><span class="tok-p">}</span> <span class="tok-p">{</span><span class="tok-ss">:language</span> <span class="tok-s">&quot;ClojureScript&quot;</span><span class="tok-p">}]</span>
  <span class="tok-nv">language</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;ClojureScript&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example, we are extracting the value associated with the <code>:language</code> key and binding<br>
it to the <code>language</code> symbol. When looking up keys that are not present, the symbol will get bound<br>
to <code>nil</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[{</span><span class="tok-nb">name </span><span class="tok-ss">:name</span><span class="tok-p">}</span> <span class="tok-p">{</span><span class="tok-ss">:language</span> <span class="tok-s">&quot;ClojureScript&quot;</span><span class="tok-p">}]</span>
  <span class="tok-nv">name</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Associative destructuring lets us give default values to bindings which will be used if the key<br>
isn&#8217;t found in the data structure we are taking apart. A map following the <code>:or</code> keyword is used<br>
for default values as the following examples show:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[{</span><span class="tok-nb">name </span><span class="tok-ss">:name</span> <span class="tok-ss">:or</span> <span class="tok-p">{</span><span class="tok-nb">name </span><span class="tok-s">&quot;Anonymous&quot;</span><span class="tok-p">}}</span> <span class="tok-p">{</span><span class="tok-ss">:language</span> <span class="tok-s">&quot;ClojureScript&quot;</span><span class="tok-p">}]</span>
  <span class="tok-nv">name</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;Anonymous&quot;</span>

<span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[{</span><span class="tok-nb">name </span><span class="tok-ss">:name</span> <span class="tok-ss">:or</span> <span class="tok-p">{</span><span class="tok-nb">name </span><span class="tok-s">&quot;Anonymous&quot;</span><span class="tok-p">}}</span> <span class="tok-p">{</span><span class="tok-ss">:name</span> <span class="tok-s">&quot;Cirilla&quot;</span><span class="tok-p">}]</span>
  <span class="tok-nv">name</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;Cirilla&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Associative destructuring also supports binding the original data structure to a symbol placed<br>
after the <code>:as</code> keyword:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[{</span><span class="tok-nb">name </span><span class="tok-ss">:name</span> <span class="tok-ss">:as</span> <span class="tok-nv">person</span><span class="tok-p">}</span> <span class="tok-p">{</span><span class="tok-ss">:name</span> <span class="tok-s">&quot;Cirilla&quot;</span> <span class="tok-ss">:age</span> <span class="tok-mi">49</span><span class="tok-p">}]</span>
  <span class="tok-p">[</span><span class="tok-nb">name </span><span class="tok-nv">person</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; [&quot;Cirilla&quot; {:name &quot;Cirilla&quot; :age 49}]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Keywords aren&#8217;t the only things that can be the keys of associative data structures.<br>
Numbers, strings, symbols and many other data structures can be used as keys, so we<br>
can destructure using those, too. Note that we need to quote the symbols to prevent<br>
them from being resolved as a var lookup:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[{</span><span class="tok-nv">one</span> <span class="tok-mi">1</span><span class="tok-p">}</span> <span class="tok-p">{</span><span class="tok-mi">0</span> <span class="tok-s">&quot;zero&quot;</span> <span class="tok-mi">1</span> <span class="tok-s">&quot;one&quot;</span><span class="tok-p">}]</span>
  <span class="tok-nv">one</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;one&quot;</span>

<span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[{</span><span class="tok-nb">name </span><span class="tok-s">&quot;name&quot;</span><span class="tok-p">}</span> <span class="tok-p">{</span><span class="tok-s">&quot;name&quot;</span> <span class="tok-s">&quot;Cirilla&quot;</span><span class="tok-p">}]</span>
  <span class="tok-nv">name</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;Cirilla&quot;</span>

<span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[{</span><span class="tok-nv">lang</span> <span class="tok-ss">&#39;language</span><span class="tok-p">}</span> <span class="tok-p">{</span><span class="tok-ss">&#39;language</span> <span class="tok-s">&quot;ClojureScript&quot;</span><span class="tok-p">}]</span>
  <span class="tok-nv">lang</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;ClojureScript&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Since the values corresponding to keys are usually bound to their equivalent symbol representation<br>
(for example, when binding the value of <code>:language</code> to the symbol <code>language</code>) and keys are usually<br>
keywords, strings, or symbols, ClojureScript offers shorthand syntax for these cases.</p>
</div>
<div class="paragraph">
<p>We&#8217;ll show examples of all of these, starting with destructuring keywords using <code>:keys</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[{</span><span class="tok-ss">:keys</span> <span class="tok-p">[</span><span class="tok-nb">name </span><span class="tok-nv">surname</span><span class="tok-p">]}</span> <span class="tok-p">{</span><span class="tok-ss">:name</span> <span class="tok-s">&quot;Cirilla&quot;</span> <span class="tok-ss">:surname</span> <span class="tok-s">&quot;Fiona&quot;</span><span class="tok-p">}]</span>
  <span class="tok-p">[</span><span class="tok-nb">name </span><span class="tok-nv">surname</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; [&quot;Cirilla&quot; &quot;Fiona&quot;]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see in the example, if we use the <code>:keys</code> keyword and associate it with a vector of<br>
symbols in a binding form, the values corresponding to the keywordized version of the symbols will<br>
be bound to them. The <code>{:keys [name surname]}</code> destructuring is equivalent to<br>
<code>{name :name surname :surname}</code>, only shorter.</p>
</div>
<div class="paragraph">
<p>The string and symbol shorthand syntax works exactly like <code>:keys</code>, but using the <code>:strs</code> and <code>:syms</code><br>
keywords respectively:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[{</span><span class="tok-ss">:strs</span> <span class="tok-p">[</span><span class="tok-nb">name </span><span class="tok-nv">surname</span><span class="tok-p">]}</span> <span class="tok-p">{</span><span class="tok-s">&quot;name&quot;</span> <span class="tok-s">&quot;Cirilla&quot;</span> <span class="tok-s">&quot;surname&quot;</span> <span class="tok-s">&quot;Fiona&quot;</span><span class="tok-p">}]</span>
  <span class="tok-p">[</span><span class="tok-nb">name </span><span class="tok-nv">surname</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; [&quot;Cirilla&quot; &quot;Fiona&quot;]</span>

<span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[{</span><span class="tok-ss">:syms</span> <span class="tok-p">[</span><span class="tok-nb">name </span><span class="tok-nv">surname</span><span class="tok-p">]}</span> <span class="tok-p">{</span><span class="tok-ss">&#39;name</span> <span class="tok-s">&quot;Cirilla&quot;</span> <span class="tok-ss">&#39;surname</span> <span class="tok-s">&quot;Fiona&quot;</span><span class="tok-p">}]</span>
  <span class="tok-p">[</span><span class="tok-nb">name </span><span class="tok-nv">surname</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; [&quot;Cirilla&quot; &quot;Fiona&quot;]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An interesting property of destructuring is that we can nest destructuring forms arbitrarily, which<br>
makes code that accesses nested data on a collection very easy to understand, as it mimics the<br>
collection&#8217;s structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[{[</span><span class="tok-nv">fst</span> <span class="tok-nv">snd</span><span class="tok-p">]</span> <span class="tok-ss">:languages</span><span class="tok-p">}</span> <span class="tok-p">{</span><span class="tok-ss">:languages</span> <span class="tok-p">[</span><span class="tok-s">&quot;ClojureScript&quot;</span> <span class="tok-s">&quot;Clojure&quot;</span><span class="tok-p">]}]</span>
  <span class="tok-p">[</span><span class="tok-nv">snd</span> <span class="tok-nv">fst</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; [&quot;Clojure&quot; &quot;ClojureScript&quot;]</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="namespace-section"><a class="link" href="#namespace-section">3.9. Namespaces</a></h3>
<div class="sect3">
<h4 id="defining-a-namespace"><a class="link" href="#defining-a-namespace">3.9.1. Defining a namespace</a></h4>
<div class="paragraph">
<p>The <em>namespace</em> is ClojureScript&#8217;s fundamental unit of code modularity. Namespaces are analogous to Java packages or<br>
Ruby and Python modules and can be defined with the <code>ns</code> macro. If you have ever looked at a little bit of<br>
ClojureScript source, you may have noticed something like this at the beginning of the file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">myapp.core</span>
  <span class="tok-s">&quot;Some docstring for the namespace.&quot;</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">x</span> <span class="tok-s">&quot;hello&quot;</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Namespaces are dynamic, meaning you can create one at any time. However, the convention is to have one namespace<br>
per file. Naturally, a namespace definition is usually at the beginning of the file, followed by an optional<br>
docstring.</p>
</div>
<div class="paragraph">
<p>Previously we have explained vars and symbols. Every var that you define will be associated<br>
with its namespace. If you do not define a concrete namespace, then the default one called "cljs.user" will be<br>
used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">x</span> <span class="tok-s">&quot;hello&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&#39;cljs.user/x</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="loading-other-namespaces"><a class="link" href="#loading-other-namespaces">3.9.2. Loading other namespaces</a></h4>
<div class="paragraph">
<p>Defining a namespace and the vars in it is really easy, but it&#8217;s not very useful if we can&#8217;t<br>
use symbols from other namespaces. For this purpose, the <code>ns</code> macro offers a simple way to load other<br>
namespaces.</p>
</div>
<div class="paragraph">
<p>Observe the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">myapp.main</span>
  <span class="tok-p">(</span><span class="tok-ss">:require</span> <span class="tok-nv">myapp.core</span>
            <span class="tok-nv">clojure.string</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">clojure.string/upper-case</span> <span class="tok-nv">myapp.core/x</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;HELLO&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can observe, we are using fully qualified names (namespace + var name) for access to vars and<br>
functions from different namespaces.</p>
</div>
<div class="paragraph">
<p>While this will let you access other namespaces, it&#8217;s also repetitive and overly verbose. It will be especially<br>
uncomfortable if the name of a namespace is very long. To solve that, you can use the <code>:as</code> directive to<br>
create an additional (usually shorter) alias to the namespace.<br>
This is how it can be done:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">myapp.main</span>
  <span class="tok-p">(</span><span class="tok-ss">:require</span> <span class="tok-p">[</span><span class="tok-nv">myapp.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">core</span><span class="tok-p">]</span>
            <span class="tok-p">[</span><span class="tok-nv">clojure.string</span> <span class="tok-ss">:as</span> <span class="tok-nv">str</span><span class="tok-p">]))</span>

<span class="tok-p">(</span><span class="tok-nf">str/upper-case</span> <span class="tok-nv">core/x</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;HELLO&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Additionally, <em>ClojureScript</em> offers a simple way to refer to specific vars or functions from a concrete namespace using the <code>:refer</code> directive, followed by a sequence of symbols that will<br>
refer to vars in the namespace. Effectively, it is as if those vars and<br>
functions are now part of your namespace, and you do not need to qualify them at all.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">myapp.main</span>
  <span class="tok-p">(</span><span class="tok-ss">:require</span> <span class="tok-p">[</span><span class="tok-nv">clojure.string</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">upper-case</span><span class="tok-p">]]))</span>
<span class="tok-p">(</span><span class="tok-nf">upper-case</span> <span class="tok-nv">x</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;HELLO&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And finally, you should know that everything located in the <code>cljs.core</code> namespace is automatically<br>
loaded and you should not require it explicitly. Sometimes you may want to declare vars that will clash<br>
with some others defined in the <code>cljs.core</code> namespace. To do this, the <code>ns</code> macro offers another directive that<br>
allows you to exclude specific symbols and prevent them from being automatically loaded.</p>
</div>
<div class="paragraph">
<p>Observe the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">myapp.main</span>
  <span class="tok-p">(</span><span class="tok-ss">:refer-clojure</span> <span class="tok-ss">:exclude</span> <span class="tok-p">[</span><span class="tok-nv">min</span><span class="tok-p">]))</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">min</span>
  <span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">&gt; </span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">)</span>
    <span class="tok-nv">y</span>
    <span class="tok-nv">x</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>ns</code> macro also has other directives for loading host classes (<code>:import</code>) and macros<br>
(<code>:refer-macros</code>), but these are explained in other sections.</p>
</div>
</div>
<div class="sect3">
<h4 id="namespaces-and-file-names"><a class="link" href="#namespaces-and-file-names">3.9.3. Namespaces and File Names</a></h4>
<div class="paragraph">
<p>When you have a namespace like <code>myapp.core</code>, the code must be in a file named  <em>core.cljs</em> inside the<br>
<em>myapp</em> directory.  So, the preceding examples with namespaces <code>myapp.core</code> and <code>myapp.main</code> would be<br>
found in project with a file structure like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>myapp
└── src
    └── myapp
        ├── core.cljs
        └── main.cljs</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="abstractions-and-polymorphism"><a class="link" href="#abstractions-and-polymorphism">3.10. Abstractions and Polymorphism</a></h3>
<div class="paragraph">
<p>I&#8217;m sure that at more than one time you have found yourself in this situation: you have defined a great<br>
abstraction (using interfaces or something similar) for your "business logic", and you have found<br>
the need to deal with another module over which you have absolutely no control, and you probably<br>
were thinking of creating adapters, proxies, and other approaches that imply a great amount<br>
of additional complexity.</p>
</div>
<div class="paragraph">
<p>Some dynamic languages allow "monkey-patching"; languages where the classes are open and any<br>
method can be defined and redefined at any time. Also, it is well known that this technique is a very<br>
bad practice.</p>
</div>
<div class="paragraph">
<p>We can not trust languages that allow you to silently overwrite methods that you are using when you<br>
import third party libraries; you cannot expect consistent behavior when this happens.</p>
</div>
<div class="paragraph">
<p>These symptoms are commonly called the "expression problem";<br>
see <a href="http://en.wikipedia.org/wiki/Expression_problem" class="bare">http://en.wikipedia.org/wiki/Expression_problem</a> for more details</p>
</div>
<div class="sect3">
<h4 id="protocols"><a class="link" href="#protocols">3.10.1. Protocols</a></h4>
<div class="paragraph">
<p>The <em>ClojureScript</em> primitive for defining "interfaces" is called a protocol. A protocol consists of<br>
a name and set of functions. All the functions have at least one argument corresponding to the<br>
<code>this</code> in JavaScript or <code>self</code> in Python.</p>
</div>
<div class="paragraph">
<p>Protocols provide a type-based polymorphism, and the dispatch is always done by the<br>
first argument (equivalent to JavaScript’s <code>this</code>, as previously mentioned).</p>
</div>
<div class="paragraph">
<p>A protocol looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">myapp.testproto</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-kd">defprotocol </span><span class="tok-nv">IProtocolName</span>
  <span class="tok-s">&quot;A docstring describing the protocol.&quot;</span>
  <span class="tok-p">(</span><span class="tok-nf">sample-method</span> <span class="tok-p">[</span><span class="tok-nv">this</span><span class="tok-p">]</span> <span class="tok-s">&quot;A doc string of the function associated with the protocol.&quot;</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
the "I" prefix is commonly used to designate the separation of protocols and types. In the Clojure<br>
community, there are many different opinions about how the "I" prefix should be used. In our opinion, it is an<br>
acceptable solution to avoid name clashing and possible confusion.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>From the user perspective, protocol functions are simply plain functions defined in the namespace<br>
where the protocol is defined. As you can intuit, this namespacing of protocols allows us to avoid<br>
any conflict between different protocols implemented for the same type.</p>
</div>
<div class="paragraph">
<p>Here is an example. Let&#8217;s create a protocol called <code>IInvertible</code> for data that can be "inverted".<br>
It will have a single method named <code>invert</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">proto.testproto</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-kd">defprotocol </span><span class="tok-nv">IInvertible</span>
  <span class="tok-s">&quot;This is a protocol for data types that are &#39;invertible&#39;&quot;</span>
    <span class="tok-p">(</span><span class="tok-nf">invert</span> <span class="tok-p">[</span><span class="tok-nv">this</span><span class="tok-p">]</span> <span class="tok-s">&quot;Invert the given item.&quot;</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="extending-existing-types"><a class="link" href="#extending-existing-types">Extending existing types</a></h5>
<div class="paragraph">
<p>One of the big strengths of protocols is the ability to extend existing and maybe third party types,<br>
and this operation can be done in different ways. The majority of time you will tend to use<br>
the <strong>extend-protocol</strong> or the <strong>extend-type</strong> macros.</p>
</div>
<div class="paragraph">
<p>This is an example of how the <strong>extend-type</strong> macro can be used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">extend-type</span> <span class="tok-nv">TypeA</span>
  <span class="tok-nv">ProtocolA</span>
  <span class="tok-p">(</span><span class="tok-nf">function-from-protocol-a</span> <span class="tok-p">[</span><span class="tok-nv">this</span><span class="tok-p">]</span>
    <span class="tok-c1">;; implementation here</span>
    <span class="tok-p">)</span>

  <span class="tok-nv">ProtocolB</span>
  <span class="tok-p">(</span><span class="tok-nf">function-from-protocol-b-1</span> <span class="tok-p">[</span><span class="tok-nv">this</span> <span class="tok-nv">parameter1</span><span class="tok-p">]</span>
    <span class="tok-c1">;; implementation here</span>
    <span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">function-from-protocol-b-2</span> <span class="tok-p">[</span><span class="tok-nv">this</span> <span class="tok-nv">parameter1</span> <span class="tok-nv">parameter2</span><span class="tok-p">]</span>
    <span class="tok-c1">;; implementation here</span>
    <span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>You can observe that with <strong>extend-type</strong> you are extending a single type with different protocols<br>
in a single expression.  Here is code that will extend the <code>number</code>, <code>string</code>, <code>List</code>, and<br>
<code>PersistentVector</code> types to be "invertible".  For numbers, we define the inverse to be the<br>
reciprocal of the number (or zero, if the number is zero). For strings, lists, and vectors,<br>
the inverse is defined as the reverse of the input.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>(extend-type number
  IInvertible
  (invert [this] (if (zero? this) 0 (/ 1 this))))

(extend-type string
  IInvertible
  (invert [this] (apply str (reverse this))))

(extend-type List
  IInvertible
  (invert [this] (reverse this)))

(extend-type PersistentVector
  IInvertible
  (invert [this] (into [] (reverse this))))</pre>
</div>
</div>
<div class="paragraph">
<p>If you load in this code, you can see that it works:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">proto.testproto/invert</span> <span class="tok-s">&quot;abc&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;cba&quot;</span>
<span class="tok-p">(</span><span class="tok-nf">proto.testproto/invert</span> <span class="tok-mi">25</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 0.04</span>
<span class="tok-p">(</span><span class="tok-nf">proto.testproto/invert</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 0</span>
<span class="tok-p">(</span><span class="tok-nf">proto.testproto/invert</span> <span class="tok-o">&#39;</span><span class="tok-p">(</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; (3 2 1)</span>
<span class="tok-p">(</span><span class="tok-nf">proto.testproto/invert</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; [3 2 1]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Admittedly, this is a somewhat contrived example. In <a href="#extend-type-section">the next section</a><br>
you will see how to extend an existing type.</p>
</div>
<div class="paragraph">
<p>In comparison, <strong>extend-protocol</strong> does the inverse;<br>
given a protocol, it adds implementations for multiple types:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">extend-protocol</span> <span class="tok-nv">ProtocolA</span>
  <span class="tok-nv">TypeA</span>
  <span class="tok-p">(</span><span class="tok-nf">function-from-protocol-a</span> <span class="tok-p">[</span><span class="tok-nv">this</span><span class="tok-p">]</span>
    <span class="tok-c1">;; implementation here</span>
    <span class="tok-p">)</span>

  <span class="tok-nv">TypeB</span>
  <span class="tok-p">(</span><span class="tok-nf">function-from-protocol-a</span> <span class="tok-p">[</span><span class="tok-nv">this</span><span class="tok-p">]</span>
    <span class="tok-c1">;; implementation here</span>
    <span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Thus, the previous example could have been written equally well this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">extend-protocol</span> <span class="tok-nv">IInvertible</span>
  <span class="tok-nv">number</span>
  <span class="tok-p">(</span><span class="tok-nf">invert</span> <span class="tok-p">[</span><span class="tok-nv">this</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">zero? </span><span class="tok-nv">this</span><span class="tok-p">)</span> <span class="tok-mi">0</span> <span class="tok-p">(</span><span class="tok-nb">/ </span><span class="tok-mi">1</span> <span class="tok-nv">this</span><span class="tok-p">)))</span>

  <span class="tok-nv">string</span>
  <span class="tok-p">(</span><span class="tok-nf">invert</span> <span class="tok-p">[</span><span class="tok-nv">this</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">apply str </span><span class="tok-p">(</span><span class="tok-nb">reverse </span><span class="tok-nv">this</span><span class="tok-p">)))</span>

  <span class="tok-nv">List</span>
  <span class="tok-p">(</span><span class="tok-nf">invert</span> <span class="tok-p">[</span><span class="tok-nv">this</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">reverse </span><span class="tok-nv">this</span><span class="tok-p">))</span>

  <span class="tok-nv">PersistentVector</span>
  <span class="tok-p">(</span><span class="tok-nf">invert</span> <span class="tok-p">[</span><span class="tok-nv">this</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">into </span><span class="tok-p">[]</span> <span class="tok-p">(</span><span class="tok-nb">reverse </span><span class="tok-nv">this</span><span class="tok-p">))))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are other ways to extend a type with a protocol implementation, but they will be covered<br>
in another section of this book.</p>
</div>
</div>
<div class="sect4">
<h5 id="participate-in-clojurescript-abstractions"><a class="link" href="#participate-in-clojurescript-abstractions">Participate in ClojureScript abstractions</a></h5>
<div class="paragraph">
<p>ClojureScript itself is built up on abstractions defined as protocols. Almost all behavior<br>
in the <em>ClojureScript</em> language itself can be adapted to third party libraries. Let&#8217;s look at a<br>
real life example.</p>
</div>
<div class="paragraph">
<p>In previous sections, we have explained the different kinds of built-in collections. For this example we<br>
will use a <strong>set</strong>. See this snippet of code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">mynums</span> <span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">})</span>

<span class="tok-p">(</span><span class="tok-nb">filter </span><span class="tok-nv">mynums</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span> <span class="tok-mi">1</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; (1 2 1)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>What happened? In this case, the <em>set</em> type implements the <em>ClojureScript</em> internal<br>
<code>IFn</code> protocol that represents an abstraction for functions or anything callable. This way it can be<br>
used like a callable predicate in filter.</p>
</div>
<div class="paragraph">
<p>OK, but what happens if we want to use a regular expression as a predicate function for filtering<br>
a collection of strings:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">filter </span><span class="tok-o">#</span><span class="tok-s">&quot;^foo&quot;</span> <span class="tok-p">[</span><span class="tok-s">&quot;haha&quot;</span> <span class="tok-s">&quot;foobar&quot;</span> <span class="tok-s">&quot;baz&quot;</span> <span class="tok-s">&quot;foobaz&quot;</span><span class="tok-p">])</span>
<span class="tok-c1">;; TypeError: Cannot call undefined</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The exception is raised because the <code>RegExp</code> type does not implement the <code>IFn</code> protocol<br>
so it cannot behave like a callable, but that can be easily fixed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">extend-type</span> <span class="tok-nv">js/RegExp</span>
  <span class="tok-nv">IFn</span>
  <span class="tok-p">(</span><span class="tok-nf">-invoke</span>
   <span class="tok-p">([</span><span class="tok-nv">this</span> <span class="tok-nv">a</span><span class="tok-p">]</span>
     <span class="tok-p">(</span><span class="tok-nb">re-find </span><span class="tok-nv">this</span> <span class="tok-nv">a</span><span class="tok-p">))))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Let’s analyze this:  we are extending the <code>js/RegExp</code> type so that it implements the <code>invoke</code> function in the<br>
<code>IFn</code> protocol. To invoke a regular expression <code>a</code> as if it were a function, call the <code>re-find</code> function with<br>
the object of the function and the pattern.</p>
</div>
<div class="paragraph">
<p>Now, you will be able use the regex instances as predicates in a filter operation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">filter </span><span class="tok-o">#</span><span class="tok-s">&quot;^foo&quot;</span> <span class="tok-p">[</span><span class="tok-s">&quot;haha&quot;</span> <span class="tok-s">&quot;foobar&quot;</span> <span class="tok-s">&quot;baz&quot;</span> <span class="tok-s">&quot;foobaz&quot;</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; (&quot;foobar&quot; &quot;foobaz&quot;)</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="introspection-using-protocols"><a class="link" href="#introspection-using-protocols">Introspection using Protocols</a></h5>
<div class="paragraph">
<p><em>ClojureScript</em> comes with a useful function that allows runtime introspection: <code>satisfies?</code>. The<br>
purpose of this function is to determine at runtime if some object (instance of some type) satisfies the<br>
concrete protocol.</p>
</div>
<div class="paragraph">
<p>So, with the previous examples, if we check if a <code>set</code> instance satisfies an <strong>IFn</strong> protocol, it should<br>
return <code>true</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">satisfies?</span> <span class="tok-nv">IFn</span> <span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-mi">1</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; true</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="multimethods"><a class="link" href="#multimethods">3.10.2. Multimethods</a></h4>
<div class="paragraph">
<p>We have previously talked about protocols which solve a very common use case of polymorphism:<br>
dispatch by type. But in some circumstances, the protocol approach can be limiting. And<br>
here, <strong>multimethods</strong> come to the rescue.</p>
</div>
<div class="paragraph">
<p>These <strong>multimethods</strong> are not limited to type dispatch only; instead, they also offer dispatch<br>
by types of multiple arguments and by value. They also allow ad-hoc hierarchies to be defined. Also,<br>
like protocols, multimethods are an "Open System", so you or any third parties can extend a multimethod for<br>
new types.</p>
</div>
<div class="paragraph">
<p>The basic constructions of <strong>multimethods</strong> are the <code>defmulti</code> and <code>defmethod</code> forms. The<br>
<code>defmulti</code> form is used to create the multimethod with an initial dispatch function. This is<br>
a model of what it looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defmulti </span><span class="tok-nv">say-hello</span>
  <span class="tok-s">&quot;A polymorphic function that return a greetings message</span>
<span class="tok-s">  depending on the language key with default lang as `:en`&quot;</span>
  <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">param</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-ss">:locale</span> <span class="tok-nv">param</span><span class="tok-p">))</span>
  <span class="tok-ss">:default</span> <span class="tok-ss">:en</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The anonymous function defined within the <code>defmulti</code> form is a dispatch function. It will<br>
be called in every call to the <code>say-hello</code> function and should return some kind of marker object<br>
that will be used for dispatch. In our example, it returns the contents of the <code>:locale</code> key<br>
of the first argument.</p>
</div>
<div class="paragraph">
<p>And finally, you should add implementations. That is done with the <code>defmethod</code> form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defmethod </span><span class="tok-nv">say-hello</span> <span class="tok-ss">:en</span>
  <span class="tok-p">[</span><span class="tok-nv">person</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-s">&quot;Hello &quot;</span> <span class="tok-p">(</span><span class="tok-ss">:name</span> <span class="tok-nv">person</span> <span class="tok-s">&quot;Anonymous&quot;</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-kd">defmethod </span><span class="tok-nv">say-hello</span> <span class="tok-ss">:es</span>
  <span class="tok-p">[</span><span class="tok-nv">person</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-s">&quot;Hola &quot;</span> <span class="tok-p">(</span><span class="tok-ss">:name</span> <span class="tok-nv">person</span> <span class="tok-s">&quot;Anónimo&quot;</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>So, if you execute that function over a hash map containing the <code>:locale</code> and optionally<br>
the <code>:name</code> key, the multimethod will first call the dispatch function to determine the<br>
dispatch value, then it will search for an implementation for that value. If an implementation<br>
is found, the dispatcher will execute it. Otherwise, the dispatch will search for a default implementation<br>
(if one is specified) and execute it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">say-hello</span> <span class="tok-p">{</span><span class="tok-ss">:locale</span> <span class="tok-ss">:es</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; &quot;Hola Anónimo&quot;</span>

<span class="tok-p">(</span><span class="tok-nf">say-hello</span> <span class="tok-p">{</span><span class="tok-ss">:locale</span> <span class="tok-ss">:en</span> <span class="tok-ss">:name</span> <span class="tok-s">&quot;Ciri&quot;</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; &quot;Hello Ciri&quot;</span>

<span class="tok-p">(</span><span class="tok-nf">say-hello</span> <span class="tok-p">{</span><span class="tok-ss">:locale</span> <span class="tok-ss">:fr</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; &quot;Hello Anonymous&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If the default implementation is not specified, an exception will be raised notifying you<br>
that some value does not have an implementation for that multimethod.</p>
</div>
</div>
<div class="sect3">
<h4 id="hierarchies"><a class="link" href="#hierarchies">3.10.3. Hierarchies</a></h4>
<div class="paragraph">
<p>Hierarchies are <em>ClojureScript</em>’s way to let you build whatever relations that your<br>
domain may require. Hierarchies are defined in term of relations between named objects,<br>
such as symbols, keywords, or types.</p>
</div>
<div class="paragraph">
<p>Hierarchies can be defined globally or locally, depending on your needs. Like multimethods,<br>
hierarchies are not limited to a single namespace. You can extend a hierarchy from any namespace,<br>
not only from the one in which it is defined.</p>
</div>
<div class="paragraph">
<p>The global namespace is more limited, for good reasons. Keywords or symbols that are not namespaced can<br>
not be used in the global hierarchy. That behavior helps prevent unexpected situations when<br>
two or more third party libraries use the same symbol for different semantics.</p>
</div>
<div class="sect4">
<h5 id="defining-a-hierarchy"><a class="link" href="#defining-a-hierarchy">Defining a hierarchy</a></h5>
<div class="paragraph">
<p>The hierarchy relations should be established using the <code>derive</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">derive</span> <span class="tok-ss">::circle</span> <span class="tok-ss">::shape</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">derive</span> <span class="tok-ss">::box</span> <span class="tok-ss">::shape</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We have just defined a set of relationships between namespaced keywords. In this case the<br>
<code>::circle</code> is a child of <code>::shape</code>, and <code>::box</code> is also a child of <code>::shape</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
The <code>::circle</code> keyword syntax is a shorthand for <code>:current.ns/circle</code>. So if you are executing<br>
it in a REPL, <code>::circle</code> will be evaluated as <code>:cljs.user/circle</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="hierarchies-and-introspection"><a class="link" href="#hierarchies-and-introspection">Hierarchies and introspection</a></h5>
<div class="paragraph">
<p><em>ClojureScript</em> comes with a little toolset of functions that allows runtime introspection<br>
of globally or locally defined hierarchies. This toolset consists of three functions:<br>
<code>isa?</code>, <code>ancestors</code>, and <code>descendants</code>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see an example of how it can be used with the hierarchy defined in the previous example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">ancestors</span> <span class="tok-ss">::box</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #{:cljs.user/shape}</span>

<span class="tok-p">(</span><span class="tok-nf">descendants</span> <span class="tok-ss">::shape</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #{:cljs.user/circle :cljs.user/box}</span>

<span class="tok-p">(</span><span class="tok-nf">isa?</span> <span class="tok-ss">::box</span> <span class="tok-ss">::shape</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nf">isa?</span> <span class="tok-ss">::rect</span> <span class="tok-ss">::shape</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; false</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="locally-defined-hierarchies"><a class="link" href="#locally-defined-hierarchies">Locally defined hierarchies</a></h5>
<div class="paragraph">
<p>As we mentioned previously, in <em>ClojureScript</em> you also can define local hierarchies. This can be<br>
done with the <code>make-hierarchy</code> function. Here is an example of how you can replicate the previous<br>
example using a local hierarchy:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">h</span> <span class="tok-p">(</span><span class="tok-nb">-&gt; </span><span class="tok-p">(</span><span class="tok-nf">make-hierarchy</span><span class="tok-p">)</span>
           <span class="tok-p">(</span><span class="tok-nf">derive</span> <span class="tok-ss">:box</span> <span class="tok-ss">:shape</span><span class="tok-p">)</span>
           <span class="tok-p">(</span><span class="tok-nf">derive</span> <span class="tok-ss">:circle</span> <span class="tok-ss">:shape</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now you can use the same introspection functions with that locally defined hierarchy:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">isa?</span> <span class="tok-nv">h</span> <span class="tok-ss">:box</span> <span class="tok-ss">:shape</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nf">isa?</span> <span class="tok-ss">:box</span> <span class="tok-ss">:shape</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; false</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can observe, in local hierarchies we can use normal (not namespace qualified) keywords,<br>
and if we execute the <code>isa?</code> without passing the local hierarchy parameter, it returns <code>false</code><br>
as expected.</p>
</div>
</div>
<div class="sect4">
<h5 id="hierarchies-in-multimethods"><a class="link" href="#hierarchies-in-multimethods">Hierarchies in multimethods</a></h5>
<div class="paragraph">
<p>One of the big advantages of hierarchies is that they work very well together with multimethods.<br>
This is because multimethods by default use the <code>isa?</code> function for the last step of dispatching.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see an example to clearly understand what that means. First, we define the multimethod with<br>
the <code>defmulti</code> form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defmulti </span><span class="tok-nv">stringify-shape</span>
  <span class="tok-s">&quot;A function that prints a human readable representation</span>
<span class="tok-s">  of a shape keyword.&quot;</span>
  <span class="tok-nv">identity</span>
  <span class="tok-ss">:hierarchy</span> <span class="tok-o">#</span><span class="tok-ss">&#39;h</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>With the <code>:hierarchy</code> keyword parameter, we indicate to the multimethod what hierarchy we want to use;<br>
if it is not specified, the global hierarchy will be used.</p>
</div>
<div class="paragraph">
<p>Second, we define an implementation for our multimethod using the <code>defmethod</code> form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defmethod </span><span class="tok-nv">stringify-shape</span> <span class="tok-ss">:box</span>
  <span class="tok-p">[</span><span class="tok-nv">_</span><span class="tok-p">]</span>
  <span class="tok-s">&quot;A box shape&quot;</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-kd">defmethod </span><span class="tok-nv">stringify-shape</span> <span class="tok-ss">:shape</span>
  <span class="tok-p">[</span><span class="tok-nv">_</span><span class="tok-p">]</span>
  <span class="tok-s">&quot;A generic shape&quot;</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-kd">defmethod </span><span class="tok-nv">stringify-shape</span> <span class="tok-ss">:default</span>
  <span class="tok-p">[</span><span class="tok-nv">_</span><span class="tok-p">]</span>
  <span class="tok-s">&quot;Unexpected object&quot;</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, let&#8217;s see what happens if we execute that function with a box:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">stringify-shape</span> <span class="tok-ss">:box</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;A box shape&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now everything works as expected; the multimethod executes the direct matching implementation<br>
for the given parameter. Next, let&#8217;s see what happens if we execute the same function but with the <code>:circle</code><br>
keyword as the parameter which does not have the direct matching dispatch value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">stringify-shape</span> <span class="tok-ss">:circle</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;A generic shape&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The multimethod automatically resolves it using the provided hierarchy, and since <code>:circle</code> is<br>
a descendant of <code>:shape</code>, the <code>:shape</code> implementation is executed.</p>
</div>
<div class="paragraph">
<p>Finally, if you give a keyword that isn&#8217;t part of the hierarchy, you get the <code>:default</code> implementation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">stringify-shape</span> <span class="tok-ss">:triangle</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;Unexpected object&quot;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="data-types"><a class="link" href="#data-types">3.11. Data types</a></h3>
<div class="paragraph">
<p>Until now, we have used maps, sets, lists, and vectors to represent our data. And in most cases, this is a<br>
really great approach. But sometimes we need to define our own types, and in this book we will<br>
call them <strong>data types</strong>.</p>
</div>
<div class="paragraph">
<p>A data type provides the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A unique host-backed type, either named or anonymous.</p>
</li>
<li>
<p>The ability to implement protocols (inline).</p>
</li>
<li>
<p>Explicitly declared structure using fields or closures.</p>
</li>
<li>
<p>Map-like behavior (via records, see below).</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="deftype"><a class="link" href="#deftype">3.11.1. Deftype</a></h4>
<div class="paragraph">
<p>The most low-level construction in <em>ClojureScript</em> for creating your own types is the <code>deftype</code> macro. As a<br>
demonstration, we will define a type called <code>User</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">deftype </span><span class="tok-nv">User</span> <span class="tok-p">[</span><span class="tok-nv">firstname</span> <span class="tok-nv">lastname</span><span class="tok-p">])</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Once the type has been defined, we can create an instance of our <code>User</code>. In the<br>
following example, the <code>.</code> after <code>User</code> indicates that we are calling a constructor.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">person</span> <span class="tok-p">(</span><span class="tok-nf">User.</span> <span class="tok-s">&quot;Triss&quot;</span> <span class="tok-s">&quot;Merigold&quot;</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Its fields can be accessed using the prefix dot notation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">.-firstname</span> <span class="tok-nv">person</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;Triss&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Types defined with <code>deftype</code> (and <code>defrecord</code>, which we will see later) create a host-backed class-like object<br>
associated with the current namespace. For convenience, <em>ClojureScript</em> also defines a constructor function called<br>
<code>&#8594;User</code> that can be imported using the <code>:require</code> directive.</p>
</div>
<div class="paragraph">
<p>We personally do not like this type of function, and we prefer to define our own constructors with more<br>
idiomatic names:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">make-user</span>
  <span class="tok-p">[</span><span class="tok-nv">firstname</span> <span class="tok-nv">lastname</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">User.</span> <span class="tok-nv">firstname</span> <span class="tok-nv">lastname</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We use this in our code instead of <code>&#8594;User</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="defrecord"><a class="link" href="#defrecord">3.11.2. Defrecord</a></h4>
<div class="paragraph">
<p>The record is a slightly higher-level abstraction for defining types in <em>ClojureScript</em> and should be<br>
the preferred way to do it.</p>
</div>
<div class="paragraph">
<p>As we know, <em>ClojureScript</em> tends to use plain data types such as maps, but in most cases we need<br>
a named type to represent the entities of our application. Here come the records.</p>
</div>
<div class="paragraph">
<p>A record is a data type that implements the map protocol and therefore can be used like any other map.<br>
And since records are also proper types, they support type-based polymorphism through protocols.</p>
</div>
<div class="paragraph">
<p>In summary: with records, we have the best of both worlds, maps that can play in different<br>
abstractions.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s start defining the <code>User</code> type but using records:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defrecord </span><span class="tok-nv">User</span> <span class="tok-p">[</span><span class="tok-nv">firstname</span> <span class="tok-nv">lastname</span><span class="tok-p">])</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>It looks really similar to the <code>deftype</code> syntax; in fact, it uses <code>deftype</code> behind the scenes as a low-level<br>
primitive for defining types.</p>
</div>
<div class="paragraph">
<p>Now, look at the difference with raw types for access to its fields:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">person</span> <span class="tok-p">(</span><span class="tok-nf">User.</span> <span class="tok-s">&quot;Yennefer&quot;</span> <span class="tok-s">&quot;of Vengerberg&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-ss">:firstname</span> <span class="tok-nv">user</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;Yennefer&quot;</span>

<span class="tok-p">(</span><span class="tok-nb">get </span><span class="tok-nv">person</span> <span class="tok-ss">:firstname</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;Yennefer&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As we mentioned previously, records are maps and act like them:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">map? </span><span class="tok-nv">person</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And like maps, they support extra fields that are not initially defined:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">person2</span> <span class="tok-p">(</span><span class="tok-nb">assoc </span><span class="tok-nv">person</span> <span class="tok-ss">:age</span> <span class="tok-mi">92</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-ss">:age</span> <span class="tok-nv">person2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 92</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As we can see, the <code>assoc</code> function works as expected and returns a new instance of the same<br>
type but with new key value pair. But take care with <code>dissoc</code>! Its behavior with records is slightly<br>
different than with maps; it will return a new record if the field being dissociated is an optional<br>
field, but it will return a plain map if you dissociate a mandatory field.</p>
</div>
<div class="paragraph">
<p>Another difference with maps is that records do not act like functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">plain-person</span> <span class="tok-p">{</span><span class="tok-ss">:firstname</span> <span class="tok-s">&quot;Yennefer&quot;</span>, <span class="tok-ss">:lastname</span> <span class="tok-s">&quot;of Vengerberg&quot;</span><span class="tok-p">})</span>

<span class="tok-p">(</span><span class="tok-nf">plain-person</span> <span class="tok-ss">:firstname</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;Yennefer&quot;</span>

<span class="tok-p">(</span><span class="tok-nf">person</span> <span class="tok-ss">:firstname</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; person.User does not implement IFn protocol.</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For convenience, the <code>defrecord</code> macro, like <code>deftype</code>, exposes a <code>&#8594;User</code> function, as well as an additional<br>
<code>map&#8594;User</code> constructor function. We have the same opinion about that constructor as with<br>
<code>deftype</code> defined ones: we recommend defining your own instead of using the other ones. But as they exist, let’s see<br>
how they can be used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">cirilla</span> <span class="tok-p">(</span><span class="tok-nf">-&gt;User</span> <span class="tok-s">&quot;Cirilla&quot;</span> <span class="tok-s">&quot;Fiona&quot;</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">yen</span> <span class="tok-p">(</span><span class="tok-nf">map-&gt;User</span> <span class="tok-p">{</span><span class="tok-ss">:firstname</span> <span class="tok-s">&quot;Yennefer&quot;</span>
                     <span class="tok-ss">:lastname</span> <span class="tok-s">&quot;of Vengerberg&quot;</span><span class="tok-p">}))</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="implementing-protocols"><a class="link" href="#implementing-protocols">3.11.3. Implementing protocols</a></h4>
<div class="paragraph">
<p>Both type definition primitives that we have seen so far allow inline implementations for protocols<br>
(explained in a previous section). Let&#8217;s define one for example purposes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defprotocol </span><span class="tok-nv">IUser</span>
  <span class="tok-s">&quot;A common abstraction for working with user types.&quot;</span>
  <span class="tok-p">(</span><span class="tok-nf">full-name</span> <span class="tok-p">[</span><span class="tok-nv">_</span><span class="tok-p">]</span> <span class="tok-s">&quot;Get the full name of the user.&quot;</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, you can define a type with inline implementation for an abstraction, in our case the <code>IUser</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defrecord </span><span class="tok-nv">User</span> <span class="tok-p">[</span><span class="tok-nv">firstname</span> <span class="tok-nv">lastname</span><span class="tok-p">]</span>
  <span class="tok-nv">IUser</span>
  <span class="tok-p">(</span><span class="tok-nf">full-name</span> <span class="tok-p">[</span><span class="tok-nv">_</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-nv">firstname</span> <span class="tok-s">&quot; &quot;</span> <span class="tok-nv">lastname</span><span class="tok-p">)))</span>

<span class="tok-c1">;; Create an instance.</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">user</span> <span class="tok-p">(</span><span class="tok-nf">User.</span> <span class="tok-s">&quot;Yennefer&quot;</span> <span class="tok-s">&quot;of Vengerberg&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">full-name</span> <span class="tok-nv">user</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;Yennefer of Vengerberg&quot;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="reify"><a class="link" href="#reify">3.11.4. Reify</a></h4>
<div class="paragraph">
<p>The <code>reify</code> macro is an <em>ad hoc constructor</em> you can use to create objects without pre-defining a type.<br>
Protocol implementations are supplied the same as <code>deftype</code> and <code>defrecord</code>, but in contrast, <code>reify</code><br>
does not have accessible fields.</p>
</div>
<div class="paragraph">
<p>This is how we can emulate an instance of the user type that plays well with the <code>IUser</code> abstraction:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">user</span>
  <span class="tok-p">[</span><span class="tok-nv">firstname</span> <span class="tok-nv">lastname</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">reify</span>
    <span class="tok-nv">IUser</span>
    <span class="tok-p">(</span><span class="tok-nf">full-name</span> <span class="tok-p">[</span><span class="tok-nv">_</span><span class="tok-p">]</span>
      <span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-nv">firstname</span> <span class="tok-s">&quot; &quot;</span> <span class="tok-nv">lastname</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">yen</span> <span class="tok-p">(</span><span class="tok-nf">user</span> <span class="tok-s">&quot;Yennefer&quot;</span> <span class="tok-s">&quot;of Vengerberg&quot;</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-nf">full-name</span> <span class="tok-nv">user</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;Yennefer of Vengerberg&quot;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="specify"><a class="link" href="#specify">3.11.5. Specify</a></h4>
<div class="paragraph">
<p><code>specify!</code> is an advanced alternative to <code>reify</code>, allowing you to add protocol<br>
implementations to an existing JavaScript object.  This can be useful if<br>
you want to graft protocols onto a JavaScript library&#8217;s components.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">obj</span> <span class="tok-o">#</span><span class="tok-nv">js</span> <span class="tok-p">{})</span>

<span class="tok-p">(</span><span class="tok-nf">specify!</span> <span class="tok-nv">obj</span>
  <span class="tok-nv">IUser</span>
  <span class="tok-p">(</span><span class="tok-nf">full-name</span> <span class="tok-p">[</span><span class="tok-nv">_</span><span class="tok-p">]</span>
    <span class="tok-s">&quot;my full name&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">full-name</span> <span class="tok-nv">obj</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;my full name&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>specify</code> is an immutable version of <code>specify!</code> that can be used on immutable,<br>
copyable values implementing <code>ICloneable</code> (e.g. ClojureScript collections).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">a</span> <span class="tok-p">{})</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">b</span> <span class="tok-p">(</span><span class="tok-nf">specify</span> <span class="tok-nv">a</span>
         <span class="tok-nv">IUser</span>
         <span class="tok-p">(</span><span class="tok-nf">full-name</span> <span class="tok-p">[</span><span class="tok-nv">_</span><span class="tok-p">]</span>
           <span class="tok-s">&quot;my full name&quot;</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">full-name</span> <span class="tok-nv">a</span><span class="tok-p">)</span>
<span class="tok-c1">;; Error: No protocol method IUser.full-name defined for type cljs.core/PersistentArrayMap: {}</span>

<span class="tok-p">(</span><span class="tok-nf">full-name</span> <span class="tok-nv">b</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;my full name&quot;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="host-interoperability"><a class="link" href="#host-interoperability">3.12. Host interoperability</a></h3>
<div class="paragraph">
<p><em>ClojureScript</em>, in the same way as its brother Clojure, is designed to be a "guest" language. This means<br>
that the design of the language works well on top of an existing ecosystem such as JavaScript<br>
for <em>ClojureScript</em> and the JVM for <em>Clojure</em>.</p>
</div>
<div class="sect3">
<h4 id="the-types"><a class="link" href="#the-types">3.12.1. The types</a></h4>
<div class="paragraph">
<p><em>ClojureScript</em>, unlike what you might expect, tries to take advantage of every type that the platform provides. This<br>
is a (perhaps incomplete) list of things that <em>ClojureScript</em> inherits and reuses from the underlying<br>
platform:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>ClojureScript</em> strings are JavaScript <strong>Strings</strong>.</p>
</li>
<li>
<p><em>ClojureScript</em> numbers are JavaScript <strong>Numbers</strong>.</p>
</li>
<li>
<p><em>ClojureScript</em> <code>nil</code> is a JavaScript <strong>null</strong>.</p>
</li>
<li>
<p><em>ClojureScript</em> regular expressions are JavaScript <code>RegExp</code> instances.</p>
</li>
<li>
<p><em>ClojureScript</em> is not interpreted; it is always compiled down to JavaScript.</p>
</li>
<li>
<p><em>ClojureScript</em> allows easy call to platform APIs with the same semantics.</p>
</li>
<li>
<p><em>ClojureScript</em> data types internally compile to objects in JavaScript.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>On top of it, <em>ClojureScript</em> builds its own abstractions and types that do not exist in the<br>
platform, such as Vectors, Maps, Sets, and others that are explained in preceding sections of this chapter.</p>
</div>
</div>
<div class="sect3">
<h4 id="interacting-with-platform-types"><a class="link" href="#interacting-with-platform-types">3.12.2. Interacting with platform types</a></h4>
<div class="paragraph">
<p><em>ClojureScript</em> comes with a little set of special forms that allows it to interact with platform<br>
types such as calling object methods, creating new instances, and accessing object<br>
properties.</p>
</div>
<div class="sect4">
<h5 id="access-to-the-platform"><a class="link" href="#access-to-the-platform">Access to the platform</a></h5>
<div class="paragraph">
<p><em>ClojureScript</em> has a special syntax for access to the entire platform environment through the<br>
<code>js/</code> special namespace. This is an example of an expression to execute JavaScript&#8217;s<br>
built-in <code>parseInt</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">js/parseInt</span> <span class="tok-s">&quot;222&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 222</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="creating-new-instances"><a class="link" href="#creating-new-instances">Creating new instances</a></h5>
<div class="paragraph">
<p><em>ClojureScript</em> has two ways to create instances:</p>
</div>
<div class="paragraph">
<p>Using the <code>new</code> special form</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">new </span><span class="tok-nv">js/RegExp</span> <span class="tok-s">&quot;^foo$&quot;</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Using the <code>.</code> special form</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">js/RegExp.</span> <span class="tok-s">&quot;^foo$&quot;</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The last one is the recommended way to create instances. We are not aware of any real differences<br>
between the two forms, but in the ClojureScript community, the last one is used most often.</p>
</div>
</div>
<div class="sect4">
<h5 id="invoke-instance-methods"><a class="link" href="#invoke-instance-methods">Invoke instance methods</a></h5>
<div class="paragraph">
<p>To invoke methods of some object instance, as opposed to how it is done in JavaScript (e.g.,<br>
<code>obj.method()</code>, the method name comes first like any other standard function in Lisp languages<br>
but with a little variation: the function name starts with special form <code>.</code>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see how we can call the <code>.test()</code> method of a regexp instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">re</span> <span class="tok-p">(</span><span class="tok-nf">js/RegExp</span> <span class="tok-s">&quot;^Clojure&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">.test</span> <span class="tok-nv">re</span> <span class="tok-s">&quot;ClojureScript&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>You can invoke instance methods on JavaScript objects. The first example follows the pattern you have seen;<br>
the last one is a shortcut:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">.sqrt</span> <span class="tok-nv">js/Math</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 1.4142135623730951</span>
<span class="tok-p">(</span><span class="tok-nf">js/Math.sqrt</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 1.4142135623730951</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="access-to-object-properties"><a class="link" href="#access-to-object-properties">Access to object properties</a></h5>
<div class="paragraph">
<p>Access to an object&#8217;s properties is really very similar to calling a method. The difference is that<br>
instead of using the <code>.</code> you use <code>.-</code>. Let&#8217;s see an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">.-multiline</span> <span class="tok-nv">re</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; false</span>
<span class="tok-p">(</span><span class="tok-nf">.-PI</span> <span class="tok-nv">js/Math</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 3.141592653589793</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="property-access-shorthand"><a class="link" href="#property-access-shorthand">Property access shorthand</a></h5>
<div class="paragraph">
<p>Symbols with the <code>js/</code> prefix can contain dots to denote nested property access.<br>
Both of the following expressions invoke the same function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">.log</span> <span class="tok-nv">js/console</span> <span class="tok-s">&quot;Hello World&quot;</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-nf">js/console.log</span> <span class="tok-s">&quot;Hello World&quot;</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And both of the following expressions access the same property:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">.-PI</span> <span class="tok-nv">js/Math</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 3.141592653589793</span>

<span class="tok-nv">js/Math.PI</span>
<span class="tok-c1">;; =&gt; 3.141592653589793</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="javascript-objects"><a class="link" href="#javascript-objects">JavaScript objects</a></h5>
<div class="paragraph">
<p><em>ClojureScript</em> has different ways to create plain JavaScript objects; each one has its own<br>
purpose. The basic one is the <code>js-obj</code> function. It accepts a variable number of pairs of keys and<br>
values and returns a JavaScript object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">js-obj</span> <span class="tok-s">&quot;country&quot;</span> <span class="tok-s">&quot;FR&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #js {:country &quot;FR&quot;}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The return value can be passed to some kind of third party library that accepts a plain<br>
JavaScript object, but you can observe the real representation of the return value of this<br>
function. It is really another form for doing the same thing.</p>
</div>
<div class="paragraph">
<p>Using the reader macro <code>#js</code> consists of prepending it to a ClojureScript map or vector, and the<br>
result will be transformed to plain JavaScript:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">myobj</span> <span class="tok-o">#</span><span class="tok-nv">js</span> <span class="tok-p">{</span><span class="tok-ss">:country</span> <span class="tok-s">&quot;FR&quot;</span><span class="tok-p">})</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The translation of that to plain JavaScript is similar to this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="javascript"><span class="tok-kd">var</span> <span class="tok-nx">myobj</span> <span class="tok-o">=</span> <span class="tok-p">{</span><span class="tok-nx">country</span><span class="tok-o">:</span> <span class="tok-s2">&quot;FR&quot;</span><span class="tok-p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As explained in the previous section, you can also access the plain object properties using<br>
the <code>.-</code> syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">.-country</span> <span class="tok-nv">myobj</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;FR&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And as JavaScript objects are mutable, you can set a new value for some property using<br>
the <code>set!</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">set!</span> <span class="tok-p">(</span><span class="tok-nf">.-country</span> <span class="tok-nv">myobj</span><span class="tok-p">)</span> <span class="tok-s">&quot;KR&quot;</span><span class="tok-p">)</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="conversions"><a class="link" href="#conversions">Conversions</a></h5>
<div class="paragraph">
<p>The inconvenience of the previously explained forms is that they do not make recursive<br>
transformations, so if you have nested objects, the nested objects will not be converted.<br>
Consider this example that uses Clojurescript maps, then a similar one with JavaScript objects:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">clj-map</span> <span class="tok-p">{</span><span class="tok-ss">:country</span> <span class="tok-p">{</span><span class="tok-ss">:code</span> <span class="tok-s">&quot;FR&quot;</span> <span class="tok-ss">:name</span> <span class="tok-s">&quot;France&quot;</span><span class="tok-p">}})</span>
<span class="tok-c1">;; =&gt; {:country {:code &quot;FR&quot;, :name &quot;France&quot;}}</span>
<span class="tok-p">(</span><span class="tok-ss">:code</span> <span class="tok-p">(</span><span class="tok-ss">:country</span> <span class="tok-nv">clj-map</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;FR&quot;</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">js-obj</span> <span class="tok-o">#</span><span class="tok-nv">js</span> <span class="tok-p">{</span><span class="tok-ss">:country</span> <span class="tok-p">{</span><span class="tok-ss">:code</span> <span class="tok-s">&quot;FR&quot;</span> <span class="tok-ss">:name</span> <span class="tok-s">&quot;France&quot;</span><span class="tok-p">}})</span>
<span class="tok-c1">;; =&gt; #js {:country {:code &quot;FR&quot;, :name &quot;France&quot;}</span>
<span class="tok-p">(</span><span class="tok-nf">.-country</span> <span class="tok-nv">js-obj</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:code &quot;FR&quot;, :name &quot;France&quot;}</span>
<span class="tok-p">(</span><span class="tok-nf">.-code</span> <span class="tok-p">(</span><span class="tok-nf">.-country</span> <span class="tok-nv">js-obj</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>To solve that use case, <em>ClojureScript</em> comes with the <code>clj&#8594;js</code> and <code>js&#8594;clj</code> functions<br>
that transform Clojure collection types into JavaScript and back. Note that the conversion to<br>
ClojureScript changes the <code>:country</code> keyword to a string.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">clj-&gt;js</span> <span class="tok-p">{</span><span class="tok-ss">:foo</span> <span class="tok-p">{</span><span class="tok-ss">:bar</span> <span class="tok-s">&quot;baz&quot;</span><span class="tok-p">}})</span>
<span class="tok-c1">;; =&gt; #js {:foo #js {:bar &quot;baz&quot;}}</span>
<span class="tok-p">(</span><span class="tok-nf">js-&gt;clj</span> <span class="tok-o">#</span><span class="tok-nv">js</span> <span class="tok-p">{</span><span class="tok-ss">:country</span> <span class="tok-p">{</span><span class="tok-ss">:code</span> <span class="tok-s">&quot;FR&quot;</span> <span class="tok-ss">:name</span> <span class="tok-s">&quot;France&quot;</span><span class="tok-p">}}))</span>
<span class="tok-c1">;; =&gt; {&quot;country&quot; {:code &quot;FR&quot;, :name &quot;France&quot;}}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the case of arrays, there is a specialized function <code>into-array</code> that behaves as expected:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">into-array </span><span class="tok-p">[</span><span class="tok-s">&quot;France&quot;</span> <span class="tok-s">&quot;Korea&quot;</span> <span class="tok-s">&quot;Peru&quot;</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; #js [&quot;France&quot; &quot;Korea&quot; &quot;Peru&quot;]</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="arrays"><a class="link" href="#arrays">Arrays</a></h5>
<div class="paragraph">
<p>In the previous example, we saw how we can create an array from an existing <em>ClojureScript</em><br>
collection. But there is another function for creating arrays: <code>make-array</code>.</p>
</div>
<div class="listingblock">
<div class="title">Creating a preallocated array with length 10</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">a</span> <span class="tok-p">(</span><span class="tok-nb">make-array </span><span class="tok-mi">10</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #js [nil nil nil nil nil nil nil nil nil nil]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In <em>ClojureScript</em>, arrays also play well with sequence abstractions, so you can iterate<br>
over them or simply get the number of elements with the <code>count</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">count </span><span class="tok-nv">a</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 10</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As arrays in the JavaScript platform are a mutable collection type, you can access a concrete index<br>
and set the value at that position:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">aset </span><span class="tok-nv">a</span> <span class="tok-mi">0</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 2</span>
<span class="tok-nv">a</span>
<span class="tok-c1">;; =&gt; #js [2 nil nil nil nil nil nil nil nil nil]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Or access in an indexed way to get its values:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">aget </span><span class="tok-nv">a</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 2</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In JavaScript, array index access is equivalent to object property access, so you can use the same functions for interacting<br>
with plain objects:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">b</span> <span class="tok-o">#</span><span class="tok-nv">js</span> <span class="tok-p">{</span><span class="tok-ss">:hour</span> <span class="tok-mi">16</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; #js {:hour 16}</span>

<span class="tok-p">(</span><span class="tok-nb">aget </span><span class="tok-nv">b</span> <span class="tok-s">&quot;hour&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 16</span>

<span class="tok-p">(</span><span class="tok-nb">aset </span><span class="tok-nv">b</span> <span class="tok-s">&quot;minute&quot;</span> <span class="tok-mi">22</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 22</span>

<span class="tok-nv">b</span>
<span class="tok-c1">;; =&gt; #js {:hour 16, :minute 22}</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truthiness"><a class="link" href="#truthiness">3.13. Truthiness</a></h3>
<div class="paragraph">
<p><a id="truthiness-section"></a></p>
</div>
<div class="paragraph">
<p>This is the aspect where each language has its own semantics. The majority of languages<br>
consider empty collections, the integer 0, and other things like this to be false.<br>
In <em>ClojureScript</em>, unlike in other languages, only two values are considered as false: <code>nil</code><br>
and <code>false</code>. Everything else is treated as <code>true</code>.</p>
</div>
<div class="paragraph">
<p>Thanks to this, sets can also be considered as predicates. If a set returns a value, it exists;<br>
if it returns <code>nil</code>, the value does not exist:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">s</span> <span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">})</span>

<span class="tok-p">(</span><span class="tok-nf">s</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 1</span>

<span class="tok-p">(</span><span class="tok-nf">s</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="state-management"><a class="link" href="#state-management">3.14. State management</a></h3>
<div class="paragraph">
<p>We&#8217;ve learned that one of ClojureScript&#8217;s fundamental ideas is immutability. Both scalar values<br>
and collections are immutable in ClojureScript, except those mutable types present in the JS host<br>
like <code>Date</code>.</p>
</div>
<div class="paragraph">
<p>Immutability has many great properties but we are sometimes faced with the need to model values<br>
that change over time. How can we achieve this if we can&#8217;t change data structures in place?</p>
</div>
<div class="sect3">
<h4 id="vars-2"><a class="link" href="#vars-2">3.14.1. Vars</a></h4>
<div class="paragraph">
<p>Vars can be redefined at will inside a namespace but there is no way to know <strong>when</strong> they change. The<br>
inability to redefine vars from other namespaces is a bit limiting; also, if we are modifying state, we&#8217;re<br>
probably interested in knowing when it occurs.</p>
</div>
</div>
<div class="sect3">
<h4 id="atoms"><a class="link" href="#atoms">3.14.2. Atoms</a></h4>
<div class="paragraph">
<p>ClojureScript gives us the <code>Atom</code> type, which is an object containing a value that can be altered at<br>
will. Besides altering its value, it also supports observation through watcher functions that can<br>
be attached and detached from it and validation for ensuring that the value contained in the atom is<br>
always valid.</p>
</div>
<div class="paragraph">
<p>If we were to model an identity corresponding to a person called Ciri, we could wrap an immutable value<br>
containing Ciri&#8217;s data in an atom. Note that we can get the atom&#8217;s value with the <code>deref</code> function or using<br>
its shorthand <code>@</code> notation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ciri</span> <span class="tok-p">(</span><span class="tok-nf">atom</span> <span class="tok-p">{</span><span class="tok-ss">:name</span> <span class="tok-s">&quot;Cirilla&quot;</span> <span class="tok-ss">:lastname</span> <span class="tok-s">&quot;Fiona&quot;</span> <span class="tok-ss">:age</span> <span class="tok-mi">20</span><span class="tok-p">}))</span>
<span class="tok-c1">;; #&lt;Atom: {:name &quot;Cirilla&quot;, :lastname &quot;Fiona&quot;, :age 20}&gt;</span>

<span class="tok-p">(</span><span class="tok-nb">deref </span><span class="tok-nv">ciri</span><span class="tok-p">)</span>
<span class="tok-c1">;; {:name &quot;Cirilla&quot;, :lastname &quot;Fiona&quot;, :age 20}</span>

<span class="tok-o">@</span><span class="tok-nv">ciri</span>
<span class="tok-c1">;; {:name &quot;Cirilla&quot;, :lastname &quot;Fiona&quot;, :age 20}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We can use the <code>swap!</code> function on an atom to alter its value with a function. Since Ciri&#8217;s birthday is<br>
today, let&#8217;s increment her age count:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">swap!</span> <span class="tok-nv">ciri</span> <span class="tok-nv">update</span> <span class="tok-ss">:age</span> <span class="tok-nv">inc</span><span class="tok-p">)</span>
<span class="tok-c1">;; {:name &quot;Cirilla&quot;, :lastname &quot;Fiona&quot;, :age 21}</span>

<span class="tok-o">@</span><span class="tok-nv">ciri</span>
<span class="tok-c1">;; {:name &quot;Cirilla&quot;, :lastname &quot;Fiona&quot;, :age 21}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>reset!</code> functions replaces the value contained in the atom with a new one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">reset!</span> <span class="tok-nv">ciri</span> <span class="tok-p">{</span><span class="tok-ss">:name</span> <span class="tok-s">&quot;Cirilla&quot;</span>, <span class="tok-ss">:lastname</span> <span class="tok-s">&quot;Fiona&quot;</span>, <span class="tok-ss">:age</span> <span class="tok-mi">22</span><span class="tok-p">})</span>
<span class="tok-c1">;; {:name &quot;Cirilla&quot;, :lastname &quot;Fiona&quot;, :age 22}</span>

<span class="tok-o">@</span><span class="tok-nv">ciri</span>
<span class="tok-c1">;; {:name &quot;Cirilla&quot;, :lastname &quot;Fiona&quot;, :age 22}</span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="observation"><a class="link" href="#observation">Observation</a></h5>
<div class="paragraph">
<p>We can add and remove watcher functions for atoms. Whenever the atom&#8217;s value is changed through a <code>swap!</code> or <code>reset!</code>,<br>
all the atom&#8217;s watcher functions will be called. Watchers are added with the <code>add-watch</code> function. Notice that each<br>
watcher has a key associated (<code>:logger</code> in the example) to it which is later used to remove the watch from the atom.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">a</span> <span class="tok-p">(</span><span class="tok-nf">atom</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">add-watch</span> <span class="tok-nv">a</span> <span class="tok-ss">:logger</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nb">key </span><span class="tok-nv">the-atom</span> <span class="tok-nv">old-value</span> <span class="tok-nv">new-value</span><span class="tok-p">]</span>
                       <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Key:&quot;</span> <span class="tok-nb">key </span><span class="tok-s">&quot;Old:&quot;</span> <span class="tok-nv">old-value</span> <span class="tok-s">&quot;New:&quot;</span> <span class="tok-nv">new-value</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">reset!</span> <span class="tok-nv">a</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
<span class="tok-c1">;; Key: :logger Old: nil New: 42</span>
<span class="tok-c1">;; =&gt; 42</span>

<span class="tok-p">(</span><span class="tok-nf">swap!</span> <span class="tok-nv">a</span> <span class="tok-nv">inc</span><span class="tok-p">)</span>
<span class="tok-c1">;; Key: :logger Old: 42 New: 43</span>
<span class="tok-c1">;; =&gt; 4</span>

<span class="tok-p">(</span><span class="tok-nf">remove-watch</span> <span class="tok-nv">a</span> <span class="tok-ss">:logger</span><span class="tok-p">)</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="volatiles"><a class="link" href="#volatiles">3.14.3. Volatiles</a></h4>
<div class="paragraph">
<p>Volatiles, like atoms, are objects containing a value that can be altered. However, they don&#8217;t provide<br>
the observation and validation capabilities that atoms provide. This makes them slightly more performant<br>
and a more suitable mutable container to use inside stateful functions that don&#8217;t need observation nor<br>
validation.</p>
</div>
<div class="paragraph">
<p>Their API closely resembles that of atoms. They can be dereferenced to grab the value they contain and<br>
support swapping and resetting with <code>vswap!</code> and <code>vreset!</code> respectively:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ciri</span> <span class="tok-p">(</span><span class="tok-nf">volatile!</span> <span class="tok-p">{</span><span class="tok-ss">:name</span> <span class="tok-s">&quot;Cirilla&quot;</span> <span class="tok-ss">:lastname</span> <span class="tok-s">&quot;Fiona&quot;</span> <span class="tok-ss">:age</span> <span class="tok-mi">20</span><span class="tok-p">}))</span>
<span class="tok-c1">;; #&lt;Volatile: {:name &quot;Cirilla&quot;, :lastname &quot;Fiona&quot;, :age 20}&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">volatile?</span> <span class="tok-nv">ciri</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nb">deref </span><span class="tok-nv">ciri</span><span class="tok-p">)</span>
<span class="tok-c1">;; {:name &quot;Cirilla&quot;, :lastname &quot;Fiona&quot;, :age 20}</span>

<span class="tok-p">(</span><span class="tok-nf">vswap!</span> <span class="tok-nv">ciri</span> <span class="tok-nv">update</span> <span class="tok-ss">:age</span> <span class="tok-nv">inc</span><span class="tok-p">)</span>
<span class="tok-c1">;; {:name &quot;Cirilla&quot;, :lastname &quot;Fiona&quot;, :age 21}</span>

<span class="tok-p">(</span><span class="tok-nf">vreset!</span> <span class="tok-nv">ciri</span> <span class="tok-p">{</span><span class="tok-ss">:name</span> <span class="tok-s">&quot;Cirilla&quot;</span>, <span class="tok-ss">:lastname</span> <span class="tok-s">&quot;Fiona&quot;</span>, <span class="tok-ss">:age</span> <span class="tok-mi">22</span><span class="tok-p">})</span>
<span class="tok-c1">;; {:name &quot;Cirilla&quot;, :lastname &quot;Fiona&quot;, :age 22}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that another difference with atoms is that the constructor of volatiles uses a bang at the end. You create<br>
volatiles with <code>volatile!</code> and atoms with <code>atom</code>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="tooling-compiler"><a class="link" href="#tooling-compiler">4. Tooling &amp; Compiler</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter will cover a little introduction to existing tooling for making things easy<br>
when developing using ClojureScript. It will cover:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Using the repl</p>
</li>
<li>
<p>Leiningen and cljsbuild</p>
</li>
<li>
<p>Google Closure Library</p>
</li>
<li>
<p>Modules</p>
</li>
<li>
<p>Unit testing</p>
</li>
<li>
<p>Library development</p>
</li>
<li>
<p>Browser based development</p>
</li>
<li>
<p>Server based development</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Unlike the previous chapter, this chapter intends to tell different stories each<br>
independent of the other.</p>
</div>
<div class="sect2">
<h3 id="getting-started-with-the-compiler"><a class="link" href="#getting-started-with-the-compiler">4.1. Getting Started with the Compiler</a></h3>
<div class="paragraph">
<p>At this point, you are surely very bored with the constant theoretical explanations about<br>
the language itself and will want to write and execute some code. The goal of this section<br>
is to provide a little practical introduction to the <em>ClojureScript</em> compiler.</p>
</div>
<div class="paragraph">
<p>The <em>ClojureScript</em> compiler takes the source code that has been split over numerous<br>
directories and namespaces and compiles it down to JavaScript. Today, JavaScript has a<br>
great number of different environments where it can be executed - each with its own<br>
peculiarities.</p>
</div>
<div class="paragraph">
<p>This chapter intends to explain how to use <em>ClojureScript</em> without any additional tooling.<br>
This will help you understand how the compiler works and how you can use it when other<br>
tooling is not available (such as <a href="http://leiningen.org/">leiningen</a><br>
<a href="https://github.com/emezeske/lein-cljsbuild">cljsbuild</a> or<br>
<a href="http://boot-clj.com/">boot</a>).</p>
</div>
<div class="sect3">
<h4 id="execution-environments"><a class="link" href="#execution-environments">4.1.1. Execution environments</a></h4>
<div class="paragraph">
<p>What is an execution environment? An execution environment is an engine where JavaScript<br>
can be executed. For example, the most popular execution environment is a browser (Chrome,<br>
Firefox, &#8230;&#8203;) followed by the second most popular - <a href="https://nodejs.org/">nodejs</a>/<br>
<a href="https://iojs.org/en/index.html">iojs</a>.</p>
</div>
<div class="paragraph">
<p>There are others, such as Rhino (JDK 6+), Nashorn (JDK 8), QtQuick (QT),&#8230;&#8203; but none of<br>
them have significant differences from the first two. So, <em>ClojureScript</em> at the moment<br>
may compile code to run in the browser or in nodejs/iojs-like environments out of the box.</p>
</div>
</div>
<div class="sect3">
<h4 id="download-the-compiler"><a class="link" href="#download-the-compiler">4.1.2. Download the compiler</a></h4>
<div class="paragraph">
<p>The <em>ClojureScript</em> compiler is implemented in Java. To use it, you should have jdk8<br>
installed. <em>ClojureScript</em> itself only requires JDK 7, but the standalone compiler that we<br>
are going to use in this chapter requires JDK 8, which can be found at<br>
<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" class="bare">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p>
</div>
<div class="paragraph">
<p>You can download the latest <em>ClojureScript</em> compiler using <code>wget</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash">wget https://github.com/clojure/clojurescript/releases/download/r1.7.28/cljs.jar</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>ClojureScript</em> compiler is packaged in a standalone executable jar file, so this is<br>
the only file (along with JDK 8) that you need to compile your <em>ClojureScript</em> source code<br>
to JavaScript.</p>
</div>
</div>
<div class="sect3">
<h4 id="compile-for-nodejs-iojs"><a class="link" href="#compile-for-nodejs-iojs">4.1.3. Compile for nodejs/iojs</a></h4>
<div class="paragraph">
<p>Let’s start with a practical example compiling code that will target <strong>nodejs</strong>/<strong>iojs</strong>. For<br>
this example, you should have nodejs or iojs (recommended) installed.</p>
</div>
<div class="paragraph">
<p>There are different ways to install iojs, but the recommended way is using nvm (node<br>
version manager). You can read the instructions on how to install and use nvm on its<br>
<a href="https://github.com/creationix/nvm">home page</a>.</p>
</div>
<div class="paragraph">
<p>When you have installed nvm, follow installing the latest version of iojs:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell">nvm install iojs-v2.5.0
nvm alias default iojs-v2.5.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can test if <strong>iojs</strong> is installed in your system with this command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell">$ iojs --version
v2.5.0</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="create-the-example-application"><a class="link" href="#create-the-example-application">Create the example application</a></h5>
<div class="paragraph">
<p>For the first step of our practical example, we will create our application directory<br>
structure and populate it with example code.</p>
</div>
<div class="paragraph">
<p>Start by creating the directory tree structure for our “hello world” application:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash">mkdir -p myapp/src/myapp
touch myapp/src/myapp/core.cljs</code></pre>
</div>
</div>
<div class="paragraph">
<p>Resulting in this directory tree:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="text">myapp
└── src
    └── myapp
        └── core.cljs</code></pre>
</div>
</div>
<div class="paragraph">
<p>Second, write the example code into the previously created <code>myapp/src/myapp/core.cljs</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">myapp.core</span>
  <span class="tok-p">(</span><span class="tok-ss">:require</span> <span class="tok-p">[</span><span class="tok-nv">cljs.nodejs</span> <span class="tok-ss">:as</span> <span class="tok-nv">nodejs</span><span class="tok-p">]))</span>

<span class="tok-p">(</span><span class="tok-nf">nodejs/enable-util-print!</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">-main</span>
  <span class="tok-p">[</span><span class="tok-o">&amp;</span> <span class="tok-nv">args</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Hello world!&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">set!</span> <span class="tok-nv">*main-cli-fn*</span> <span class="tok-nv">-main</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
It is very important that the declared namespace in the file exactly matches the<br>
directory structure. This is the way <em>ClojureScript</em> structures its source code.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="compile-the-example-application"><a class="link" href="#compile-the-example-application">Compile the example application</a></h5>
<div class="paragraph">
<p>In order to compile that source code, we need a simple build script that tells the<br>
<em>ClojureScript</em> compiler the source directory and the output file. <em>ClojureScript</em> has a<br>
lot of other options, but at this moment we can ignore that.</p>
</div>
<div class="paragraph">
<p>Let’s create the <em>myapp/build.clj</em> file with the following content:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.build.api</span> <span class="tok-ss">:as</span> <span class="tok-nv">b</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">b/build</span> <span class="tok-s">&quot;src&quot;</span>
 <span class="tok-p">{</span><span class="tok-ss">:main</span> <span class="tok-ss">&#39;myapp.core</span>
  <span class="tok-ss">:output-to</span> <span class="tok-s">&quot;main.js&quot;</span>
  <span class="tok-ss">:output-dir</span> <span class="tok-s">&quot;out&quot;</span>
  <span class="tok-ss">:target</span> <span class="tok-ss">:nodejs</span>
  <span class="tok-ss">:verbose</span> <span class="tok-nv">true</span><span class="tok-p">})</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a brief explanation of the compiler options used in this example:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>:output-to</code> parameter indicates to the compiler the destination of the compiled<br>
code, in this case to the "main.js" file.</p>
</li>
<li>
<p>The <code>:main</code> property indicates to the compiler the namespace that will act as the entry<br>
point of your application when it&#8217;s executed.</p>
</li>
<li>
<p>The <code>:target</code> property indicates the platform where you want to execute the compiled<br>
code. In this case, we are going to use <strong>iojs</strong> (formerly nodejs). If you omit this<br>
parameter, the source will be compiled to run in the browser environment.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To run the compilation, just execute the following command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nb">cd </span>myapp
java -cp ../cljs.jar:src clojure.main build.clj</code></pre>
</div>
</div>
<div class="paragraph">
<p>And when it finishes, execute the compiled file using <strong>iojs</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell">$ iojs main.js
Hello world!</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="compile-for-the-browser"><a class="link" href="#compile-for-the-browser">4.1.4. Compile for the Browser</a></h4>
<div class="paragraph">
<p>In this section we are going to create an application similar to the "hello world" example<br>
from the previous section to run in the browser environment. The minimal requirement for<br>
this application is just a browser that can execute JavaScript.</p>
</div>
<div class="paragraph">
<p>The process is almost the same, and the directory structure is the same. The only things<br>
that changes is the entry point of the application and the build script. So, start<br>
re-creating the directory tree from previous example in a different directory.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash">mkdir -p mywebapp/src/mywebapp
touch mywebapp/src/mywebapp/core.cljs</code></pre>
</div>
</div>
<div class="paragraph">
<p>Resulting in this directory tree:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="text">mywebapp
└── src
    └── mywebapp
        └── core.cljs</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, write new content to the <code>mywebapp/src/mywebapp/core.cljs</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">mywebapp.core</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-nf">enable-console-print!</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Hello world!&quot;</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the browser environment we do not need a specific entry point for the application, so<br>
the entry point is the entire namespace.</p>
</div>
<div class="sect4">
<h5 id="compile-the-example-application-2"><a class="link" href="#compile-the-example-application-2">Compile the example application</a></h5>
<div class="paragraph">
<p>In order to compile the source code to run properly in a browser, overwrite the<br>
<em>mywebapp/build.clj</em> file with the following content:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.build.api</span> <span class="tok-ss">:as</span> <span class="tok-nv">b</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">b/build</span> <span class="tok-s">&quot;src&quot;</span>
 <span class="tok-p">{</span><span class="tok-ss">:output-to</span> <span class="tok-s">&quot;main.js&quot;</span>
  <span class="tok-ss">:output-dir</span> <span class="tok-s">&quot;out/&quot;</span>
  <span class="tok-ss">:source-map</span> <span class="tok-s">&quot;main.js.map&quot;</span>
  <span class="tok-ss">:main</span> <span class="tok-ss">&#39;mywebapp.core</span>
  <span class="tok-ss">:verbose</span> <span class="tok-nv">true</span>
  <span class="tok-ss">:optimizations</span> <span class="tok-ss">:none</span><span class="tok-p">})</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a brief explanation of the compiler options we&#8217;re using:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>:output-to</code> parameter indicates to the compiler the destination of the compiled<br>
code, in this case the "main.js" file.</p>
</li>
<li>
<p>The <code>:main</code> property indicates to the compiler the namespace that will act as the  entry<br>
point of your application when it&#8217;s executed.</p>
</li>
<li>
<p><code>:source-map</code> indicates the destination of the source map. (The source map connects the<br>
ClojureScript source to the generated JavaScript so that error messages can point you<br>
back to the original source.)</p>
</li>
<li>
<p><code>:output-dir</code> indicates the destination directory for all file sources used in a<br>
compilation. It is just for making source maps work properly with the rest of the code,<br>
not only your source.</p>
</li>
<li>
<p><code>:optimizations</code> indicates the compilation optimization. There are different values for<br>
this option, but that will be covered in subsequent sections in more detail.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To run the compilation, just execute the following command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nb">cd </span>mywebapp<span class="tok-p">;</span>
java -cp ../cljs.jar:src clojure.main build.clj</code></pre>
</div>
</div>
<div class="paragraph">
<p>This process can take some time, so do not worry; wait a little bit. The JVM bootstrap<br>
with the Clojure compiler is slightly slow. In the following sections, we will explain how<br>
to start a watch process to avoid constantly starting and stopping this slow process.</p>
</div>
<div class="paragraph">
<p>While waiting for the compilation, let&#8217;s create a dummy HTML file to make it easy to<br>
execute our example app in the browser. Create the <em>index.html</em> file with the following<br>
content; it goes in the main <em>mywebapp</em> directory.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="html"><span class="tok-cp">&lt;!DOCTYPE html&gt;</span>
<span class="tok-nt">&lt;html&gt;</span>
  <span class="tok-nt">&lt;header&gt;</span>
    <span class="tok-nt">&lt;meta</span> <span class="tok-na">charset=</span><span class="tok-s">&quot;utf-8&quot;</span> <span class="tok-nt">/&gt;</span>
    <span class="tok-nt">&lt;title&gt;</span>Hello World from ClojureScript<span class="tok-nt">&lt;/title&gt;</span>
  <span class="tok-nt">&lt;/header&gt;</span>
  <span class="tok-nt">&lt;body&gt;</span>
    <span class="tok-nt">&lt;script </span><span class="tok-na">src=</span><span class="tok-s">&quot;main.js&quot;</span><span class="tok-nt">&gt;&lt;/script&gt;</span>
  <span class="tok-nt">&lt;/body&gt;</span>
<span class="tok-nt">&lt;/html&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, when the compilation finishes and you have the basic HTML file you can just open it<br>
with your favorite browser and take a look in the development tools console. The<br>
"Hello world!" message should appear there.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="watch-process"><a class="link" href="#watch-process">4.1.5. Watch process</a></h4>
<div class="paragraph">
<p>Surely, you have already experienced the slow startup of the <em>ClojureScript</em> compiler. To<br>
solve this, the <em>ClojureScript</em> standalone compiler also comes with tools to start a<br>
process that watches the changes in some directory and performs an incremental<br>
compilation.</p>
</div>
<div class="paragraph">
<p>Start creating another build script, but in this case, name it <em>watch.clj</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.build.api</span> <span class="tok-ss">:as</span> <span class="tok-nv">b</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">b/watch</span> <span class="tok-s">&quot;src&quot;</span>
 <span class="tok-p">{</span><span class="tok-ss">:output-to</span> <span class="tok-s">&quot;main.js&quot;</span>
  <span class="tok-ss">:output-dir</span> <span class="tok-s">&quot;out/&quot;</span>
  <span class="tok-ss">:source-map</span> <span class="tok-s">&quot;main.js.map&quot;</span>
  <span class="tok-ss">:main</span> <span class="tok-ss">&#39;mywebapp.core</span>
  <span class="tok-ss">:optimizations</span> <span class="tok-ss">:none</span><span class="tok-p">})</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, execute that script like any other that you have executed in previous sections:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nv">$ </span>java -cp ../cljs.jar:src clojure.main watch.clj
Building ...
Reading analysis cache <span class="tok-k">for</span> jar:file:/home/niwi/cljsbook/playground/cljs.jar!/cljs/core.cljs
Compiling src/mywebapp/core.cljs
Compiling out/cljs/core.cljs
Using cached cljs.core out/cljs/core.cljs
... <span class="tok-k">done</span>. Elapsed 0.754487937 seconds
Watching paths: /home/niwi/cljsbook/playground/mywebapp/src</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can observe that in the second compilation, the time is drastically reduced. Another<br>
advantage of this method is that it gives a little bit more output.</p>
</div>
</div>
<div class="sect3">
<h4 id="optimization-levels"><a class="link" href="#optimization-levels">4.1.6. Optimization levels</a></h4>
<div class="paragraph">
<p>The <em>ClojureScript</em> compiler has different levels of optimization. Behind the scenes,<br>
those compilation levels are coming from Google Closure Compiler.</p>
</div>
<div class="paragraph">
<p>A very simplified overview of the compilation process is:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The reader reads the code and makes some analysis. This process can raise some warnings<br>
during this phase.</p>
</li>
<li>
<p>Then, the <em>ClojureScript</em> compiler emits JavaScript code. The result is one JavaScript<br>
file for each cljs file.</p>
</li>
<li>
<p>The generated files passes through the Closure Compiler that, depending on the<br>
optimization level and other options (sourcemaps, output dir output to, &#8230;&#8203;) generates<br>
the final output.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The final output depends strictly on the optimization level.</p>
</div>
<div class="sect4">
<h5 id="none"><a class="link" href="#none">none</a></h5>
<div class="paragraph">
<p>Implies that closure compiler just writes the files as is, without any additional<br>
optimization applied to the source code. This optimization level is mandatory if you are<br>
targeting <strong>nodejs</strong> or <strong>iojs</strong> and is appropiate in development mode when your code targets<br>
the browser.</p>
</div>
</div>
<div class="sect4">
<h5 id="whitespace"><a class="link" href="#whitespace">whitespace</a></h5>
<div class="paragraph">
<p>This optimization level consists of concatenating the compiled files in an appropriate<br>
order, removing line breaks and other whitespace and generating the output as one large<br>
file.</p>
</div>
<div class="paragraph">
<p>It also has some compilation speed penalty, resulting in slower compilations. In any case,<br>
it is not terribly slow and is completely usable in small/medium applications.</p>
</div>
</div>
<div class="sect4">
<h5 id="simple"><a class="link" href="#simple">simple</a></h5>
<div class="paragraph">
<p>The simple compilation level implies (includes) all transformations from whitespace<br>
optimization and additionally performs optimizations within expressions and functions,<br>
including renaming local variables and function parameters to shorter names.</p>
</div>
<div class="paragraph">
<p>Compilation with the <code>:simple</code> optimization always preserves the functionality of<br>
syntactically valid JavaScript, so it does not interfere with the interaction between the<br>
compiled <em>ClojureScript</em> and other JavaScript.</p>
</div>
</div>
<div class="sect4">
<h5 id="advanced"><a class="link" href="#advanced">advanced</a></h5>
<div class="paragraph">
<p>The advanced compilation level includes all transformations from simple<br>
optimization and additionally performs more aggressive optimizations and dead<br>
code elimination. This results in significantly smaller output files.</p>
</div>
<div class="paragraph">
<p>The <code>:advanced</code> optimizations can only work for a strict subset of JavaScript<br>
code that follows the Google Closure Compiler rules.  <em>ClojureScript</em> generates<br>
valid JavaScript within this strict subset, but if you are interacting with<br>
third party JavaScript code, some additional tasks should be done to make<br>
everything work as expected.</p>
</div>
<div class="paragraph">
<p>This interaction with third party javascript libraries will be explained<br>
in later sections.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="working-with-the-repl"><a class="link" href="#working-with-the-repl">4.2. Working with the REPL</a></h3>
<div class="sect3">
<h4 id="introduction-2"><a class="link" href="#introduction-2">4.2.1. Introduction</a></h4>
<div class="paragraph">
<p>Although you can create a source file and compile it every time you want to try something<br>
out in ClojureScript, it&#8217;s easier to use the REPL. REPL stands for:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Read - get input from the keyboard</p>
</li>
<li>
<p>Evaluate the input</p>
</li>
<li>
<p>Print the result</p>
</li>
<li>
<p>Loop back for more input</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In other words, the REPL lets you try out ClojureScript concepts and get immediate<br>
feedback.</p>
</div>
<div class="paragraph">
<p><em>ClojureScript</em> comes with support for executing the REPL in different execution<br>
environments, each one has its own advantages or disadvantages. For example, you can run a<br>
REPL in nodejs but in that environment you don&#8217;t have access to the DOM.</p>
</div>
<div class="paragraph">
<p>In summary: everthing really depends on your needs or requirements.</p>
</div>
</div>
<div class="sect3">
<h4 id="nashorn-repl"><a class="link" href="#nashorn-repl">4.2.2. Nashorn REPL</a></h4>
<div class="paragraph">
<p>The Nashorn REPL is the easiest and maybe most painless REPL environment because it does<br>
not require any special stuff, just the JVM (JDK 8) that you have used in previous<br>
examples for running the <em>ClojureScript</em> compiler.</p>
</div>
<div class="paragraph">
<p>Let’s start creating the <em>repl.clj</em> file with the following content:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.repl</span><span class="tok-p">]</span>
         <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.repl.nashorn</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">cljs.repl/repl</span>
 <span class="tok-p">(</span><span class="tok-nf">cljs.repl.nashorn/repl-env</span><span class="tok-p">)</span>
 <span class="tok-ss">:output-dir</span> <span class="tok-s">&quot;out&quot;</span>
 <span class="tok-ss">:cache-analysis</span> <span class="tok-nv">true</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, execute the following command to get the REPL up and running:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nv">$ </span>java -cp cljs.jar:src clojure.main repl.clj
To quit, <span class="tok-nb">type</span>: :cljs/quit
cljs.user<span class="tok-o">=</span>&gt; <span class="tok-o">(</span>+ <span class="tok-m">1</span> 2<span class="tok-o">)</span>
3</code></pre>
</div>
</div>
<div class="paragraph">
<p>You may have noticed that the REPL does not have support for history and other shell-like<br>
facilities. This is because the default REPL does not comes with "readline" support. But<br>
this problem can be solved using the simple tool called <code>rlwrap</code> that you can certainly<br>
find with the package manager of your operating system.</p>
</div>
<div class="paragraph">
<p>The <code>rlwrap</code> makes the REPL "readline" capable and will allow you to have command history,<br>
code navigation, and other shell-like utilities that will make your REPL experience much<br>
more pleasant. To use it, just prepend it to the previous command that we have used to<br>
execute the REPL:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nv">$ </span>rlwrap java -cp cljs.jar:src clojure.main repl.clj
To quit, <span class="tok-nb">type</span>: :cljs/quit
cljs.user<span class="tok-o">=</span>&gt; <span class="tok-o">(</span>+ <span class="tok-m">1</span> 2<span class="tok-o">)</span>
3</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="node-repl"><a class="link" href="#node-repl">4.2.3. Node REPL</a></h4>
<div class="paragraph">
<p>This REPL uses nodejs/iojs as an execution environment and obviously requires that nodejs<br>
or iojs will be installed in your system.</p>
</div>
<div class="paragraph">
<p>Surely you are asking yourself, why do I need a repl with nodejs when we have nashorn<br>
that does not require any additional dependencies. The answer is very simple: node/iojs<br>
is the most used JavaScript execution environment on the backend, and it has a great<br>
amount of community packages around it.</p>
</div>
<div class="paragraph">
<p>Well, the good news is that starting a nodejs/iojs repl is very easy once you have it<br>
installed in your system. Start writing this content to a new <code>repl.clj</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.repl</span><span class="tok-p">]</span>
         <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.repl.node</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">cljs.repl/repl</span>
 <span class="tok-p">(</span><span class="tok-nf">cljs.repl.node/repl-env</span><span class="tok-p">)</span>
 <span class="tok-ss">:output-dir</span> <span class="tok-s">&quot;out&quot;</span>
 <span class="tok-ss">:cache-analysis</span> <span class="tok-nv">true</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And start the REPL like you have done it previously with nashorn REPL:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nv">$ </span>rlwrap java -cp cljs.jar:src clojure.main repl.clj
To quit, <span class="tok-nb">type</span>: :cljs/quit
cljs.user<span class="tok-o">=</span>&gt; <span class="tok-o">(</span>+ <span class="tok-m">1</span> 2<span class="tok-o">)</span>
3</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="browser-repl"><a class="link" href="#browser-repl">4.2.4. Browser REPL</a></h4>
<div class="paragraph">
<p>This REPL is the most laborious to get up and running. This is because it uses a browser<br>
for its execution environment and it has additional requirements.</p>
</div>
<div class="paragraph">
<p>Let’s start by creating a file named <code>brepl.clj</code> with the following content:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span>
  <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.build.api</span> <span class="tok-ss">:as</span> <span class="tok-nv">b</span><span class="tok-p">]</span>
  <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.repl</span> <span class="tok-ss">:as</span> <span class="tok-nv">repl</span><span class="tok-p">]</span>
  <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.repl.browser</span> <span class="tok-ss">:as</span> <span class="tok-nv">browser</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">b/build</span> <span class="tok-s">&quot;src&quot;</span>
 <span class="tok-p">{</span><span class="tok-ss">:output-to</span> <span class="tok-s">&quot;main.js&quot;</span>
  <span class="tok-ss">:output-dir</span> <span class="tok-s">&quot;out/&quot;</span>
  <span class="tok-ss">:source-map</span> <span class="tok-s">&quot;main.js.map&quot;</span>
  <span class="tok-ss">:main</span> <span class="tok-ss">&#39;myapp.core</span>
  <span class="tok-ss">:verbose</span> <span class="tok-nv">true</span>
  <span class="tok-ss">:optimizations</span> <span class="tok-ss">:none</span><span class="tok-p">})</span>

<span class="tok-p">(</span><span class="tok-nf">repl/repl</span> <span class="tok-p">(</span><span class="tok-nf">browser/repl-env</span><span class="tok-p">)</span>
  <span class="tok-ss">:output-dir</span> <span class="tok-s">&quot;out&quot;</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This script builds the source, just as we did earlier, and then starts the REPL.</p>
</div>
<div class="paragraph">
<p>But the browser REPL also requires that some code be executed in the browser before<br>
getting the REPL working. To do that, just re-create the application structure very<br>
similar to the one that we have used in previous sections:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash">mkdir -p src/myapp
touch src/myapp/core.cljs</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, write new content to the <code>src/myapp/core.cljs</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">myapp.core</span>
 <span class="tok-p">(</span><span class="tok-ss">:require</span> <span class="tok-p">[</span><span class="tok-nv">clojure.browser.repl</span> <span class="tok-ss">:as</span> <span class="tok-nv">repl</span><span class="tok-p">]))</span>

<span class="tok-p">(</span><span class="tok-kd">defonce </span><span class="tok-nv">conn</span>
  <span class="tok-p">(</span><span class="tok-nf">repl/connect</span> <span class="tok-s">&quot;http://localhost:9000/repl&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">enable-console-print!</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Hello, world!&quot;</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And finally, create the missing <em>index.html</em> file that is going to be used as the entry<br>
point for running the browser side code of the REPL:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="html"><span class="tok-cp">&lt;!DOCTYPE html&gt;</span>
<span class="tok-nt">&lt;html&gt;</span>
  <span class="tok-nt">&lt;header&gt;</span>
    <span class="tok-nt">&lt;meta</span> <span class="tok-na">charset=</span><span class="tok-s">&quot;utf-8&quot;</span> <span class="tok-nt">/&gt;</span>
    <span class="tok-nt">&lt;title&gt;</span>Hello World from ClojureScript<span class="tok-nt">&lt;/title&gt;</span>
  <span class="tok-nt">&lt;/header&gt;</span>
  <span class="tok-nt">&lt;body&gt;</span>
    <span class="tok-nt">&lt;script </span><span class="tok-na">src=</span><span class="tok-s">&quot;main.js&quot;</span><span class="tok-nt">&gt;&lt;/script&gt;</span>
  <span class="tok-nt">&lt;/body&gt;</span>
<span class="tok-nt">&lt;/html&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Well, that was a lot of setup! But trust us, it’s all worth it when you see it in action.<br>
To do that, just execute the <code>brepl.clj</code> in the same way that we have done it in previous<br>
examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nv">$ </span>rlwrap java -cp cljs.jar:src clojure.main brepl.clj
Compiling client js ...
Waiting <span class="tok-k">for</span> browser to connect ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>And finally, open your favourite browser and go to <a href="http://localhost:9000/" class="bare">http://localhost:9000/</a>. Once the page<br>
is loaded (the page will be blank), switch back to the console where you have run the REPL<br>
and you will see that it is up and running:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-o">[</span>...<span class="tok-o">]</span>
To quit, <span class="tok-nb">type</span>: :cljs/quit
cljs.user<span class="tok-o">=</span>&gt; <span class="tok-o">(</span>+ <span class="tok-m">14</span> 28<span class="tok-o">)</span>
42</code></pre>
</div>
</div>
<div class="paragraph">
<p>One of the big advantages of this REPL is that you have access to all the browser<br>
environment. To demonstrate it, just enter <code>(js/alert "hello world")</code> in the repl. The<br>
result of that will be the typical browser alert dialog.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="the-closure-library"><a class="link" href="#the-closure-library">4.3. The Closure Library</a></h3>
<div class="paragraph">
<p>The Google Closure Library is a javascript library developed by Google, based on a modular<br>
architecture and provides cross-browser functions for DOM manipulations and events, ajax<br>
and JSON, among other features.</p>
</div>
<div class="paragraph">
<p>It&#8217;s written specifically to take advantage of the Closure Compiler (that is used<br>
internally by the <em>ClojureScript</em> compiler).</p>
</div>
<div class="paragraph">
<p>And <em>ClojureScript</em> is built on Closure Compiler and Closure Library. In fact,<br>
<em>ClojureScript</em> namespaces are Closure modules. This means that<br>
you can interact with the Closure Library in a very easy way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">yourapp.core</span>
  <span class="tok-p">(</span><span class="tok-ss">:require</span> <span class="tok-p">[</span><span class="tok-nv">goog.dom</span> <span class="tok-ss">:as</span> <span class="tok-nv">dom</span><span class="tok-p">]))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">element</span> <span class="tok-p">(</span><span class="tok-nf">dom/getElement</span> <span class="tok-s">&quot;body&quot;</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>With the previous snippet of code you can observe the way you can import the <strong>dom</strong> module of<br>
the closure library and use one function declared in that module.</p>
</div>
<div class="paragraph">
<p>Additionally, the closure library also exposes "special" modules that behave like a<br>
class or object. For importing these kinds of things you should use the <code>:import</code> directive.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">yourapp.core</span>
  <span class="tok-p">(</span><span class="tok-ss">:import</span> <span class="tok-nv">goog.History</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">instance</span> <span class="tok-p">(</span><span class="tok-nf">History.</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If you are familiar with Clojure, it imports Java classes using<br>
the same <code>:import</code> directive. However, if you define types (classes) using <em>ClojureScript</em><br>
primitives, you should not use <code>:import</code> to import them, the standard <code>:require</code><br>
directives should be used.</p>
</div>
</div>
<div class="sect2">
<h3 id="dependency-management"><a class="link" href="#dependency-management">4.4. Dependency management</a></h3>
<div class="paragraph">
<p>Until now, we have used the builtin <em>ClojureScript</em> toolchain to compile our<br>
sources to JavaScript.  This is the minimal setup required for working with and<br>
understanding the compiler, but for larger projects, we often require a larger<br>
build tool that can manage a project&#8217;s dependencies on other libraries.</p>
</div>
<div class="paragraph">
<p>Thus, this chapter intends to explain how you can use <strong>Leiningen</strong>, the de facto clojure build<br>
and dependency management tool, to build <em>ClojureScript</em> projects. There is another<br>
build tool called <strong>boot</strong> that is growing in popularity, but at this moment it will not be<br>
covered in this book.</p>
</div>
<div class="sect3">
<h4 id="installing-leiningen"><a class="link" href="#installing-leiningen">4.4.1. Installing leiningen</a></h4>
<div class="paragraph">
<p>The installation process of leiningen is quite simple; just follow these steps:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash">mkdir ~/bin
<span class="tok-nb">cd</span> ~/bin
wget https://raw.githubusercontent.com/technomancy/leiningen/stable/bin/lein
chmod a+x ./lein
<span class="tok-nb">export </span><span class="tok-nv">PATH</span><span class="tok-o">=</span><span class="tok-nv">$PATH</span>:~/bin</code></pre>
</div>
</div>
<div class="paragraph">
<p>Make sure that the <code>~/bin</code> directory is always set on your path. To make it permanent,<br>
add the line starting with <code>export</code> to your <code>~/.bashrc</code> file (we are supposing that you<br>
are using the bash shell).</p>
</div>
<div class="paragraph">
<p>Now, open another clean terminal and execute <code>lein version</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nv">$ </span>lein version
Leiningen 2.5.1 on Java 1.8.0_45 OpenJDK 64-Bit Server VM</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
We are supposing that you are using a Unix-like system such as Linux or BSD. If you<br>
are a Windows user, please check the instructions on the<br>
<a href="http://leiningen.org/">Leiningen homepage</a>. You can also get the Linux/Mac OSX/BSD<br>
version of the leiningen script at the web site.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="first-project"><a class="link" href="#first-project">4.4.2. First project</a></h4>
<div class="paragraph">
<p>The best way to show how a tool works is by creating a toy project with it. In this case,<br>
we will create a small application that calculates if a year is a leap year or not. To<br>
start, we will use the <strong>mies</strong> leiningen template.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Templates are a facility in leiningen for creating an initial project structure.<br>
The clojure community has a great many of them. In this case<br>
we&#8217;ll use the <strong>mies</strong> template that was started by the clojurescript core developer.  Consult<br>
the leiningen docs to learn more about templates.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let&#8217;s start creating the project layout:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nv">$ </span>lein new mies leapyears
<span class="tok-nv">$ </span><span class="tok-nb">cd </span>leapyears <span class="tok-c"># move into newly created project directory</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The project has the following structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>leapyears
├── index.html
├── project.clj
├── README.md
├── scripts
│   ├── build
│   ├── release
│   ├── watch
│   ├── repl
│   └── brepl
└── src
    └── leapyears
        └── core.cljs</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>project.clj</code> file contains information that Leiningen uses to download dependencies<br>
and build the project. For now, just trust that everything in that file is exactly as it<br>
should be.</p>
</div>
<div class="paragraph">
<p>Open the <code>index.html</code> file and add the following content at the beginning of body:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="html"><span class="tok-nt">&lt;section</span> <span class="tok-na">class=</span><span class="tok-s">&quot;viewport&quot;</span><span class="tok-nt">&gt;</span>
  <span class="tok-nt">&lt;div</span> <span class="tok-na">id=</span><span class="tok-s">&quot;result&quot;</span><span class="tok-nt">&gt;</span>
    ----
  <span class="tok-nt">&lt;/div&gt;</span>
  <span class="tok-nt">&lt;form</span> <span class="tok-na">action=</span><span class="tok-s">&quot;&quot;</span> <span class="tok-na">method=</span><span class="tok-s">&quot;&quot;</span><span class="tok-nt">&gt;</span>
    <span class="tok-nt">&lt;label</span> <span class="tok-na">for=</span><span class="tok-s">&quot;year&quot;</span><span class="tok-nt">&gt;</span>Input a year<span class="tok-nt">&lt;/label&gt;</span>
    <span class="tok-nt">&lt;input</span> <span class="tok-na">id=</span><span class="tok-s">&quot;year&quot;</span> <span class="tok-na">name=</span><span class="tok-s">&quot;year&quot;</span> <span class="tok-nt">/&gt;</span>
  <span class="tok-nt">&lt;/form&gt;</span>
<span class="tok-nt">&lt;/section&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And the next step is adding some code to make the form interactive. Put the following<br>
code into the <code>src/leapyear/core.cljs</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">leapyears.core</span>
  <span class="tok-p">(</span><span class="tok-ss">:require</span> <span class="tok-p">[</span><span class="tok-nv">goog.dom</span> <span class="tok-ss">:as</span> <span class="tok-nv">dom</span><span class="tok-p">]</span>
            <span class="tok-p">[</span><span class="tok-nv">goog.events</span> <span class="tok-ss">:as</span> <span class="tok-nv">events</span><span class="tok-p">]</span>
            <span class="tok-p">[</span><span class="tok-nv">cljs.reader</span> <span class="tok-ss">:refer</span> <span class="tok-p">(</span><span class="tok-nf">read-string</span><span class="tok-p">)]))</span>

<span class="tok-p">(</span><span class="tok-nf">enable-console-print!</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">input</span> <span class="tok-p">(</span><span class="tok-nf">dom/getElement</span> <span class="tok-s">&quot;year&quot;</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">result</span> <span class="tok-p">(</span><span class="tok-nf">dom/getElement</span> <span class="tok-s">&quot;result&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">leap?</span>
  <span class="tok-p">[</span><span class="tok-nv">year</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">and </span><span class="tok-p">(</span><span class="tok-nb">zero? </span><span class="tok-p">(</span><span class="tok-nf">js-mod</span> <span class="tok-nv">year</span> <span class="tok-mi">4</span><span class="tok-p">))</span>
       <span class="tok-p">(</span><span class="tok-nb">pos? </span><span class="tok-p">(</span><span class="tok-nf">js-mod</span> <span class="tok-nv">year</span> <span class="tok-mi">100</span><span class="tok-p">))</span>
       <span class="tok-p">(</span><span class="tok-nb">pos? </span><span class="tok-p">(</span><span class="tok-nf">js-mod</span> <span class="tok-nv">year</span> <span class="tok-mi">400</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">on-change</span>
  <span class="tok-p">[</span><span class="tok-nv">event</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">target</span> <span class="tok-p">(</span><span class="tok-nf">.-target</span> <span class="tok-nv">event</span><span class="tok-p">)</span>
        <span class="tok-nv">value</span> <span class="tok-p">(</span><span class="tok-nf">read-string</span> <span class="tok-p">(</span><span class="tok-nf">.-value</span> <span class="tok-nv">target</span><span class="tok-p">))]</span>
    <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nf">leap?</span> <span class="tok-nv">value</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nf">set!</span> <span class="tok-p">(</span><span class="tok-nf">.-innerHTML</span> <span class="tok-nv">result</span><span class="tok-p">)</span> <span class="tok-s">&quot;YES&quot;</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nf">set!</span> <span class="tok-p">(</span><span class="tok-nf">.-innerHTML</span> <span class="tok-nv">result</span><span class="tok-p">)</span> <span class="tok-s">&quot;NO&quot;</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-nf">events/listen</span> <span class="tok-nv">input</span> <span class="tok-s">&quot;keyup&quot;</span> <span class="tok-nv">on-change</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, compile the clojurescript code with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nv">$ </span>./scripts/watch</code></pre>
</div>
</div>
<div class="paragraph">
<p>This script executes the following behind the scenes, similar to the <code>java</code><br>
build commands from the previous section, but with our <code>lein</code> build tool:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash">rlwrap lein trampoline run -m clojure.main scripts/watch.clj</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
you should have <code>rlwrap</code> installed on your system.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Finally, open the <code>index.html</code> file in a browser.  Typing a year in the textbox<br>
should display an indication of its leap year status.</p>
</div>
<div class="paragraph">
<p>You may have noticed other files in the scripts directory, like <code>build</code> and<br>
<code>release</code>.  These are the same build scripts mentioned in the previous section,<br>
but we will stick with <code>watch</code> here.</p>
</div>
</div>
<div class="sect3">
<h4 id="managing-dependencies"><a class="link" href="#managing-dependencies">4.4.3. Managing dependencies</a></h4>
<div class="paragraph">
<p>The real purpose of using Leiningen for the ClojureScript compilation process is to automate<br>
the retrieval of dependencies.  This is dramatically simpler than retrieving them manually.</p>
</div>
<div class="paragraph">
<p>The dependencies, among other parameters, are declared in the <code>project.clj</code> file and have<br>
this form (from <strong>mies</strong> template):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defproject </span><span class="tok-nv">leapyears</span> <span class="tok-s">&quot;0.1.0-SNAPSHOT&quot;</span>
  <span class="tok-ss">:description</span> <span class="tok-s">&quot;FIXME: write this!&quot;</span>
  <span class="tok-ss">:url</span> <span class="tok-s">&quot;http://example.com/FIXME&quot;</span>
  <span class="tok-ss">:dependencies</span> <span class="tok-p">[[</span><span class="tok-nv">org.clojure/clojure</span> <span class="tok-s">&quot;1.7.0&quot;</span><span class="tok-p">]</span>
                 <span class="tok-p">[</span><span class="tok-nv">org.clojure/clojurescript</span> <span class="tok-s">&quot;0.0-3308&quot;</span> <span class="tok-ss">:classifier</span> <span class="tok-s">&quot;aot&quot;</span>
                  <span class="tok-ss">:exclusion</span> <span class="tok-p">[</span><span class="tok-nv">org.clojure/data.json</span><span class="tok-p">]]</span>
                 <span class="tok-p">[</span><span class="tok-nv">org.clojure/data.json</span> <span class="tok-s">&quot;0.2.6&quot;</span> <span class="tok-ss">:classifier</span> <span class="tok-s">&quot;aot&quot;</span><span class="tok-p">]]</span>
  <span class="tok-ss">:jvm-opts</span> <span class="tok-o">^</span><span class="tok-ss">:replace</span> <span class="tok-p">[</span><span class="tok-s">&quot;-Xmx1g&quot;</span> <span class="tok-s">&quot;-server&quot;</span><span class="tok-p">]</span>
  <span class="tok-ss">:node-dependencies</span> <span class="tok-p">[[</span><span class="tok-nv">source-map-support</span> <span class="tok-s">&quot;0.3.2&quot;</span><span class="tok-p">]]</span>
  <span class="tok-ss">:plugins</span> <span class="tok-p">[[</span><span class="tok-nv">lein-npm</span> <span class="tok-s">&quot;0.5.0&quot;</span><span class="tok-p">]]</span>
  <span class="tok-ss">:source-paths</span> <span class="tok-p">[</span><span class="tok-s">&quot;src&quot;</span> <span class="tok-s">&quot;target/classes&quot;</span><span class="tok-p">]</span>
  <span class="tok-ss">:clean-targets</span> <span class="tok-p">[</span><span class="tok-s">&quot;out&quot;</span> <span class="tok-s">&quot;release&quot;</span><span class="tok-p">]</span>
  <span class="tok-ss">:target-path</span> <span class="tok-s">&quot;target&quot;</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And here is a brief explanation of the properties relevant for ClojureScript:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>:dependencies</code>: a vector of dependencies that your project needs.</p>
</li>
<li>
<p><code>:clean-targets</code>: a vector of paths that <code>lein clean</code> should delete.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The dependencies in ClojureScript are packaged using <code>jar</code> files. If you are coming from<br>
Clojure or any JVM language, <code>jar</code> files will be very familiar to you. But if you<br>
aren&#8217;t familiar with them, do not worry: a .jar file is like a plain zip file that contains<br>
the <code>project.clj</code> for the library, some metadata, and the ClojureScript sources. The<br>
packaging will be explained in another section.</p>
</div>
<div class="paragraph">
<p>Clojure packages are often published on <a href="http://clojars.org">Clojars</a>; also you<br>
can find many different third party libraries on the<br>
<a href="https://github.com/clojure/clojurescript/wiki#libraries">ClojureScript Wiki</a>.</p>
</div>
<div class="paragraph">
<p>To understand dependencies better, we are going to replace the DOM utiltiles of the Google Closure<br>
library with a third party library for interacting with the DOM.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s start by adding <code>[prismatic/dommy "1.1.0"]</code> at the end of the <code>:dependencies</code> vector in<br>
<strong>project.clj</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-ss">:dependencies</span> <span class="tok-p">[[</span><span class="tok-nv">org.clojure/clojure</span> <span class="tok-s">&quot;1.7.0&quot;</span><span class="tok-p">]</span>
               <span class="tok-p">[</span><span class="tok-nv">org.clojure/clojurescript</span> <span class="tok-s">&quot;0.0-3308&quot;</span> <span class="tok-ss">:classifier</span> <span class="tok-s">&quot;aot&quot;</span>
                <span class="tok-ss">:exclusion</span> <span class="tok-p">[</span><span class="tok-nv">org.clojure/data.json</span><span class="tok-p">]]</span>
               <span class="tok-p">[</span><span class="tok-nv">org.clojure/data.json</span> <span class="tok-s">&quot;0.2.6&quot;</span> <span class="tok-ss">:classifier</span> <span class="tok-s">&quot;aot&quot;</span><span class="tok-p">]</span>
               <span class="tok-p">[</span><span class="tok-nv">prismatic/dommy</span> <span class="tok-s">&quot;1.1.0&quot;</span><span class="tok-p">]]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>At this moment you should restart the <code>watch</code> process that we had started at the beginning<br>
of this subchapter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nv">$ </span>./scripts/watch
Retrieving prismatic/dommy/1.1.0/dommy-1.1.0.pom from clojars
Retrieving prismatic/dommy/1.1.0/dommy-1.1.0.jar from clojars
Building ...
... <span class="tok-k">done</span>. Elapsed 0.227999601 seconds
Watching paths: /home/niwi/cljsbook/playground/leapyears/src</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can observe that the dommy dependency is successfully downloaded, and then the<br>
watch process is started.  In fact, Leiningen will ensure all dependencies are<br>
downloaded before performing any tasks.</p>
</div>
<div class="paragraph">
<p>Now it&#8217;s time to write some code. Replace the contents of the <code>src/leapyear/core.cljs</code><br>
with the following content:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">leapyears.core</span>
  <span class="tok-p">(</span><span class="tok-ss">:require</span> <span class="tok-p">[</span><span class="tok-nv">dommy.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">dom</span><span class="tok-p">]</span>
            <span class="tok-p">[</span><span class="tok-nv">cljs.reader</span> <span class="tok-ss">:refer</span> <span class="tok-p">(</span><span class="tok-nf">read-string</span><span class="tok-p">)]))</span>

<span class="tok-p">(</span><span class="tok-nf">enable-console-print!</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">input</span> <span class="tok-p">(</span><span class="tok-nf">dom/sel1</span> <span class="tok-ss">:#year</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">result</span> <span class="tok-p">(</span><span class="tok-nf">dom/sel1</span> <span class="tok-ss">:#result</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">leap?</span>
  <span class="tok-p">[</span><span class="tok-nv">year</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">and </span><span class="tok-p">(</span><span class="tok-nb">zero? </span><span class="tok-p">(</span><span class="tok-nf">js-mod</span> <span class="tok-nv">year</span> <span class="tok-mi">4</span><span class="tok-p">))</span>
       <span class="tok-p">(</span><span class="tok-nb">pos? </span><span class="tok-p">(</span><span class="tok-nf">js-mod</span> <span class="tok-nv">year</span> <span class="tok-mi">100</span><span class="tok-p">))</span>
       <span class="tok-p">(</span><span class="tok-nb">pos? </span><span class="tok-p">(</span><span class="tok-nf">js-mod</span> <span class="tok-nv">year</span> <span class="tok-mi">400</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">on-change</span>
  <span class="tok-p">[</span><span class="tok-nv">event</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">target</span> <span class="tok-p">(</span><span class="tok-nf">.-target</span> <span class="tok-nv">event</span><span class="tok-p">)</span>
        <span class="tok-nv">value</span> <span class="tok-p">(</span><span class="tok-nf">read-string</span> <span class="tok-p">(</span><span class="tok-nf">dom/value</span> <span class="tok-nv">target</span><span class="tok-p">))]</span>
    <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nf">leap?</span> <span class="tok-nv">value</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nf">dom/set-html!</span> <span class="tok-nv">result</span> <span class="tok-s">&quot;YES&quot;</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nf">dom/set-html!</span> <span class="tok-nv">result</span> <span class="tok-s">&quot;NO&quot;</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-nf">dom/listen!</span> <span class="tok-nv">input</span> <span class="tok-ss">:keyup</span> <span class="tok-nv">on-change</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can observe, the code now looks more “Clojure-friendly.” The host<br>
interoperabilty calls have now been replaced by functions provided by this<br>
third-party library.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="using-javascript-libraries"><a class="link" href="#using-javascript-libraries">4.5. Using javascript libraries</a></h3>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect2">
<h3 id="unit-testing"><a class="link" href="#unit-testing">4.6. Unit testing</a></h3>
<div class="paragraph">
<p>As you may expect, testing in <em>ClojureScript</em> consists of the same concepts as<br>
you may know from any other language such as Clojure, Java, Python, JavaScript, etc.</p>
</div>
<div class="paragraph">
<p>Regardless of the language, the main objective of unit testing is to run some test code,<br>
and verify that your code behaves as expected and returns without raising unexpected<br>
exceptions.</p>
</div>
<div class="paragraph">
<p>The immutablity of <em>ClojureScript</em> in fact helps your program to be less<br>
error prone and facilitates testing a little bit. Another advantage of <em>ClojureScript</em><br>
is that it tends to use plain data instead of complex objects. Building "mock" objects<br>
for testing is greatly simplified.</p>
</div>
<div class="sect3">
<h4 id="first-steps"><a class="link" href="#first-steps">4.6.1. First steps</a></h4>
<div class="paragraph">
<p>The "official" <em>ClojureScript</em> testing framework is in the core library under the "cljs.test"<br>
namespace. It is a very simple library, but it should be more than enough for our purposes.</p>
</div>
<div class="paragraph">
<p>There are other libraries that offer additional features or directly different approaches<br>
for testing, such as <a href="https://github.com/clojure/test.check">test.check</a>. However, they<br>
will not be covered in this subchapter.</p>
</div>
<div class="paragraph">
<p>Start creating a new project using the <strong>mies</strong> leiningen template for experimenting with<br>
tests:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nv">$ </span>lein new mies appfortesting
<span class="tok-nv">$ </span><span class="tok-nb">cd </span>appfortesting</code></pre>
</div>
</div>
<div class="paragraph">
<p>This project will contain the same layout as we have seen in the <strong>dependency management</strong><br>
subchapter, so we won’t explain it again.</p>
</div>
<div class="paragraph">
<p>The next step is a creating a directory tree for our tests:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nv">$ </span>mkdir -p <span class="tok-nb">test</span>/appfortesting
<span class="tok-nv">$ </span>touch <span class="tok-nb">test</span>/appfortesting/core_tests.cljs</code></pre>
</div>
</div>
<div class="paragraph">
<p>Also, we should adapt the existing <code>watch.clj</code> script to work with this newly created<br>
test directory:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.build.api</span> <span class="tok-ss">:as</span> <span class="tok-nv">b</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">b/watch</span> <span class="tok-p">(</span><span class="tok-nf">b/inputs</span> <span class="tok-s">&quot;test&quot;</span> <span class="tok-s">&quot;src&quot;</span><span class="tok-p">)</span>
  <span class="tok-p">{</span><span class="tok-ss">:main</span> <span class="tok-ss">&#39;appfortesting.core_tests</span>
   <span class="tok-ss">:target</span> <span class="tok-ss">:nodejs</span>
   <span class="tok-ss">:output-to</span> <span class="tok-s">&quot;out/appfortesting.js&quot;</span>
   <span class="tok-ss">:output-dir</span> <span class="tok-s">&quot;out&quot;</span>
   <span class="tok-ss">:verbose</span> <span class="tok-nv">true</span><span class="tok-p">})</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This new script will compile and watch both directories "src" and "test", and<br>
sets the new entry point to the <code>appfortesting.core_tests</code> namespace.</p>
</div>
<div class="paragraph">
<p>Next, write some test code into the <code>core_tests.cljs</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">appfortesting.core-tests</span>
  <span class="tok-p">(</span><span class="tok-ss">:require</span> <span class="tok-p">[</span><span class="tok-nv">cljs.test</span> <span class="tok-ss">:as</span> <span class="tok-nv">t</span><span class="tok-p">]))</span>

<span class="tok-p">(</span><span class="tok-nf">enable-console-print!</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-nf">t/deftest</span> <span class="tok-nv">my-first-test</span>
  <span class="tok-p">(</span><span class="tok-nf">t/is</span> <span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">set!</span> <span class="tok-nv">*main-cli-fn*</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nf">t/run-tests</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The relevant part of that code snippet is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">t/deftest</span> <span class="tok-nv">my-first-test</span>
  <span class="tok-p">(</span><span class="tok-nf">t/is</span> <span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>deftest</code> macro is a basic primitive for defining our tests. It takes a name as its first<br>
parameter, followed by one or multiple "asserts" using the <code>is</code> macro. In that example,<br>
the assert tries check that <code>(= 1 2)</code> is true.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s try to run this. First start the watch process:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nv">$ </span>./scripts/watch
Building ...
Analyzing jar:file:/home/niwi/.m2/repository/org/clojure/clojurescript/0.0-3308/clojurescript-0.0-3308-aot.jar!/cljs/core.cljs
Compiling out/cljs/core.cljs
Using cached cljs.core out/cljs/core.cljs
... <span class="tok-k">done</span>. Elapsed 3.862126827 seconds
Watching paths: /home/niwi/cljsbook/playground/appfortesting/test, /home/niwi/cljsbook/playground/appfortesting/src</code></pre>
</div>
</div>
<div class="paragraph">
<p>And when the compilation is finished, try to run the compiled file with <code>iojs</code><br>
(or <code>node</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nv">$ </span>iojs out/appfortesting.js

Testing appfortesting.core-tests

FAIL in <span class="tok-o">(</span>my-first-test<span class="tok-o">)</span> <span class="tok-o">(</span>cljs/test.js:374:14<span class="tok-o">)</span>
expected: <span class="tok-o">(=</span> <span class="tok-m">1</span> 2<span class="tok-o">)</span>
  actual: <span class="tok-o">(</span>not <span class="tok-o">(=</span> <span class="tok-m">1</span> 2<span class="tok-o">))</span>

Ran <span class="tok-m">1</span> tests containing <span class="tok-m">1</span> assertions.
<span class="tok-m">1</span> failures, <span class="tok-m">0</span> errors.</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can observe that the expected assert failure is successfully printed in the console. To<br>
fix the test, just change the <code>=</code> with <code>not=</code> and run the file again:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nv">$ </span>iojs out/appfortesting.js

Testing appfortesting.core-tests

Ran <span class="tok-m">1</span> tests containing <span class="tok-m">1</span> assertions.
<span class="tok-m">0</span> failures, <span class="tok-m">0</span> errors.</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is fine to test these kinds of assertions, but they are not very useful. Let&#8217;s go to<br>
test some application code. For this, we will use a function to check if a year is a leap year<br>
or not. Then, write the following content to the <code>src/appfortesting/core.clj</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">leap?</span>
  <span class="tok-p">[</span><span class="tok-nv">year</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">and </span><span class="tok-p">(</span><span class="tok-nb">zero? </span><span class="tok-p">(</span><span class="tok-nf">js-mod</span> <span class="tok-nv">year</span> <span class="tok-mi">4</span><span class="tok-p">))</span>
       <span class="tok-p">(</span><span class="tok-nb">pos? </span><span class="tok-p">(</span><span class="tok-nf">js-mod</span> <span class="tok-nv">year</span> <span class="tok-mi">100</span><span class="tok-p">))</span>
       <span class="tok-p">(</span><span class="tok-nb">pos? </span><span class="tok-p">(</span><span class="tok-nf">js-mod</span> <span class="tok-nv">year</span> <span class="tok-mi">400</span><span class="tok-p">))))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, write a new test case to check that our new function defined in the<br>
<code>appfortesting.core</code> namespace works properly. This is the new content<br>
of the <code>core_tests.cljs</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">appfortesting.core-tests</span>
  <span class="tok-p">(</span><span class="tok-ss">:require</span> <span class="tok-p">[</span><span class="tok-nv">cljs.test</span> <span class="tok-ss">:as</span> <span class="tok-nv">t</span><span class="tok-p">]</span>
            <span class="tok-p">[</span><span class="tok-nv">appfortesting.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">core</span><span class="tok-p">]))</span>

<span class="tok-p">(</span><span class="tok-nf">enable-console-print!</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-nf">t/deftest</span> <span class="tok-nv">my-first-test</span>
  <span class="tok-p">(</span><span class="tok-nf">t/is</span> <span class="tok-p">(</span><span class="tok-nb">not= </span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">t/deftest</span> <span class="tok-nv">my-second-test</span>
  <span class="tok-p">(</span><span class="tok-nf">t/is</span> <span class="tok-p">(</span><span class="tok-nf">core/leap?</span> <span class="tok-mi">1980</span><span class="tok-p">))</span>
  <span class="tok-p">(</span><span class="tok-nf">t/is</span> <span class="tok-p">(</span><span class="tok-nb">not </span><span class="tok-p">(</span><span class="tok-nf">core/leap?</span> <span class="tok-mi">1981</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-nf">set!</span> <span class="tok-nv">*main-cli-fn*</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nf">t/run-tests</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Run the compiled file again to see that there are now two tests running.  The<br>
first test fails as it did before, but our leap year test passes as expected.</p>
</div>
</div>
<div class="sect3">
<h4 id="async-testing"><a class="link" href="#async-testing">4.6.2. Async Testing</a></h4>
<div class="paragraph">
<p>One of the peculiarities of <em>ClojureScript</em> is that it runs on asynchronous,<br>
single-threaded execution environments, and this has its own challenges.</p>
</div>
<div class="paragraph">
<p>In async execution environments, we should be able to test asynchronous<br>
functions.  To this end, the <em>ClojureScript</em> testing library offers the <code>async</code><br>
macro, allowing you to create tests that play well with asynchronous code.</p>
</div>
<div class="paragraph">
<p>First, we need to write a function that works in an asynchronous way. For this<br>
purpose, we will create the <code>async-leap?</code> predicate that will do the same operation but<br>
asychronously return a result using a callback:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">async-leap?</span>
  <span class="tok-p">[</span><span class="tok-nv">year</span> <span class="tok-nv">callback</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">js/setImmediate</span>
   <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[]</span>
     <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">result</span> <span class="tok-p">(</span><span class="tok-nb">and </span><span class="tok-p">(</span><span class="tok-nb">zero? </span><span class="tok-p">(</span><span class="tok-nf">js-mod</span> <span class="tok-nv">year</span> <span class="tok-mi">4</span><span class="tok-p">))</span>
                       <span class="tok-p">(</span><span class="tok-nb">pos? </span><span class="tok-p">(</span><span class="tok-nf">js-mod</span> <span class="tok-nv">year</span> <span class="tok-mi">100</span><span class="tok-p">))</span>
                       <span class="tok-p">(</span><span class="tok-nb">pos? </span><span class="tok-p">(</span><span class="tok-nf">js-mod</span> <span class="tok-nv">year</span> <span class="tok-mi">400</span><span class="tok-p">)))]</span>
       <span class="tok-p">(</span><span class="tok-nf">callback</span> <span class="tok-nv">result</span><span class="tok-p">)))))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The JavaScript function <code>setImmediate</code> is used to emulate an asynchronous task, and the callback<br>
is executed with the result of that predicate.</p>
</div>
<div class="paragraph">
<p>To test it, we should write a test case using the previously mentioned <code>async</code> macro:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">t/deftest</span> <span class="tok-nv">my-async-test</span>
  <span class="tok-p">(</span><span class="tok-nf">t/async</span> <span class="tok-nv">done</span>
    <span class="tok-p">(</span><span class="tok-nf">core/async-leap?</span> <span class="tok-mi">1980</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">result</span><span class="tok-p">]</span>
                             <span class="tok-p">(</span><span class="tok-nf">t/is</span> <span class="tok-p">(</span><span class="tok-nb">true? </span><span class="tok-nv">result</span><span class="tok-p">))</span>
                             <span class="tok-p">(</span><span class="tok-nf">done</span><span class="tok-p">)))))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>done</code> function exposed by the <code>async</code> macro should be called after the asynchronous<br>
operation is finished and all assertions have run.</p>
</div>
<div class="paragraph">
<p>It is very important to execute the <code>done</code> function only once. Omitting or<br>
executing it twice may cause strange behavior and should be avoided.</p>
</div>
</div>
<div class="sect3">
<h4 id="fixtures"><a class="link" href="#fixtures">4.6.3. Fixtures</a></h4>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect3">
<h4 id="integrating-with-ci"><a class="link" href="#integrating-with-ci">4.6.4. Integrating with CI</a></h4>
<div class="paragraph">
<p>Most continuous integration tools and services expect that test scripts you<br>
provide return a standard exit code. But the ClojureScript test framework<br>
cannot customize this exit code without some configuration, because JavaScript<br>
lacks a universal exit code API for ClojureScript to use.</p>
</div>
<div class="paragraph">
<p>To fix this, the <em>ClojureScript</em> test framework provides an avenue for<br>
executing custom code after the tests are done. This is where you are expected<br>
to set the environment-specific exit code depending on the final test status:<br>
<code>0</code> for success, <code>1</code> for failure.</p>
</div>
<div class="paragraph">
<p>Insert this code at the end of <code>core_tests.cljs</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defmethod </span><span class="tok-nv">t/report</span> <span class="tok-p">[</span><span class="tok-ss">::t/default</span> <span class="tok-ss">:end-run-tests</span><span class="tok-p">]</span>
  <span class="tok-p">[</span><span class="tok-nv">m</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nf">t/successful?</span> <span class="tok-nv">m</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nf">set!</span> <span class="tok-p">(</span><span class="tok-nf">.-exitCode</span> <span class="tok-nv">js/process</span><span class="tok-p">)</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nf">set!</span> <span class="tok-p">(</span><span class="tok-nf">.-exitCode</span> <span class="tok-nv">js/process</span><span class="tok-p">)</span> <span class="tok-mi">1</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, you may check the exit code of the test script after running:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nv">$ </span>iojs out/appfortesting.js
<span class="tok-nv">$ </span><span class="tok-nb">echo</span> <span class="tok-nv">$?</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This code snippet obviously assumes that you are running the tests using <strong>iojs</strong> or<br>
<strong>nodejs</strong>. If you are running your script in another execution environment, you should be<br>
aware of how you can set the exit code in that environment and modify the previous snippet<br>
accordingly.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="language-advanced-topics"><a class="link" href="#language-advanced-topics">5. Language (advanced topics)</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter intends to explain some advanced topics that are part of the language and<br>
that does not fits in the first chapter. The good candidates for this section are<br>
transducers, core protocols, transients, metadata. In summary: topics that are not<br>
mandatory for understand the language.</p>
</div>
<div class="sect2">
<h3 id="transducers"><a class="link" href="#transducers">5.1. Transducers</a></h3>
<div class="sect3">
<h4 id="data-transformation"><a class="link" href="#data-transformation">5.1.1. Data transformation</a></h4>
<div class="paragraph">
<p>ClojureScript offers a rich vocabulary for data transformation in terms of the sequence abstraction,<br>
which makes such transformations highly general and composable. Let&#8217;s see how we can combine several<br>
collection processing functions to build new ones. We will be using a simple problem throughout this<br>
section: splitting grape clusters, filtering out the rotten ones, and cleaning them. We have a collection<br>
of grape clusters like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">grape-clusters</span> <span class="tok-p">[{</span><span class="tok-ss">:grapes</span> <span class="tok-p">[{</span><span class="tok-ss">:rotten?</span> <span class="tok-nv">false</span> <span class="tok-ss">:clean?</span> <span class="tok-nv">false</span><span class="tok-p">}</span>
                               <span class="tok-p">{</span><span class="tok-ss">:rotten?</span> <span class="tok-nv">true</span> <span class="tok-ss">:clean?</span> <span class="tok-nv">false</span><span class="tok-p">}]</span>
                      <span class="tok-ss">:color</span> <span class="tok-ss">:green</span><span class="tok-p">}</span>
                     <span class="tok-p">{</span><span class="tok-ss">:grapes</span> <span class="tok-p">[{</span><span class="tok-ss">:rotten?</span> <span class="tok-nv">true</span> <span class="tok-ss">:clean?</span> <span class="tok-nv">false</span><span class="tok-p">}</span>
                               <span class="tok-p">{</span><span class="tok-ss">:rotten?</span> <span class="tok-nv">false</span> <span class="tok-ss">:clean?</span> <span class="tok-nv">false</span><span class="tok-p">}]</span>
                      <span class="tok-ss">:color</span> <span class="tok-ss">:black</span><span class="tok-p">}])</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We are interested in splitting the grape clusters into individual grapes, discarding the rotten ones<br>
and cleaning the remaining grapes so they are ready for eating. We are well-equipped in ClojureScript<br>
for this data transformation task; we could implement it using the familiar <code>map</code>, <code>filter</code> and <code>mapcat</code><br>
functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">split-cluster</span>
  <span class="tok-p">[</span><span class="tok-nv">c</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-ss">:grapes</span> <span class="tok-nv">c</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">not-rotten</span>
  <span class="tok-p">[</span><span class="tok-nv">g</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">not </span><span class="tok-p">(</span><span class="tok-ss">:rotten?</span> <span class="tok-nv">g</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">clean-grape</span>
  <span class="tok-p">[</span><span class="tok-nv">g</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">assoc </span><span class="tok-nv">g</span> <span class="tok-ss">:clean?</span> <span class="tok-nv">true</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-nv">grape-clusters</span>
     <span class="tok-p">(</span><span class="tok-nb">mapcat </span><span class="tok-nv">split-cluster</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nb">filter </span><span class="tok-nv">not-rotten</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-nv">clean-grape</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; ({rotten? false :clean? true} {:rotten? false :clean? true})</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example we succintly solved the problem of selecting and cleaning the grapes, and<br>
we can even abstract such transformations by combining the <code>mapcat</code>, <code>filter</code> and <code>map</code> operations<br>
using partial application and function composition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">process-clusters</span>
  <span class="tok-p">(</span><span class="tok-nf">comp</span>
    <span class="tok-p">(</span><span class="tok-nb">partial map </span><span class="tok-nv">clean-grape</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nb">partial filter </span><span class="tok-nv">not-rotten</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nb">partial mapcat </span><span class="tok-nv">split-cluster</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">process-clusters</span> <span class="tok-nv">grape-clusters</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; ({rotten? false :clean? true} {:rotten? false :clean? true})</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The code is very clean, but it has a few problems. For example, each call to <code>map</code>, <code>filter</code> and<br>
<code>mapcat</code> consumes and produces a sequence that, although lazy, generates intermediate results<br>
that will be discarded. Each sequence is fed to the next step, which also returns a<br>
sequence. Wouldn&#8217;t be great if we could do the transformation in a single transversal of the <code>grape-cluster</code><br>
collection?</p>
</div>
<div class="paragraph">
<p>Another problem is that even though our <code>process-clusters</code> function works with any sequence, we<br>
can&#8217;t reuse it with anything that is not a sequence. Imagine that instead of having the grape cluster<br>
collection available in memory it is being pushed to us asynchronously in a stream. In that situation<br>
we couldn&#8217;t reuse <code>process-clusters</code> since usually <code>map</code>, <code>filter</code> and <code>mapcat</code> have concrete<br>
implementations depending on the type.</p>
</div>
</div>
<div class="sect3">
<h4 id="generalizing-to-process-transformations"><a class="link" href="#generalizing-to-process-transformations">5.1.2. Generalizing to process transformations</a></h4>
<div class="paragraph">
<p>The process of mapping, filtering or mapcatting isn&#8217;t necesarily tied to a concrete type, but we<br>
keep reimplementing them for different types. Let&#8217;s see how we can generalize such processes to<br>
be context independent. We&#8217;ll start by implementing naive versions of <code>map</code> and <code>filter</code> first to<br>
see how they work internally:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">my-map</span>
  <span class="tok-p">[</span><span class="tok-nv">f</span> <span class="tok-nv">coll</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">when-let </span><span class="tok-p">[</span><span class="tok-nv">s</span> <span class="tok-p">(</span><span class="tok-nb">seq </span><span class="tok-nv">coll</span><span class="tok-p">)]</span>
    <span class="tok-p">(</span><span class="tok-nb">cons </span><span class="tok-p">(</span><span class="tok-nf">f</span> <span class="tok-p">(</span><span class="tok-nb">first </span><span class="tok-nv">s</span><span class="tok-p">))</span> <span class="tok-p">(</span><span class="tok-nf">my-map</span> <span class="tok-nv">f</span> <span class="tok-p">(</span><span class="tok-nb">rest </span><span class="tok-nv">s</span><span class="tok-p">)))))</span>

<span class="tok-p">(</span><span class="tok-nf">my-map</span> <span class="tok-nb">inc </span><span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; (1 2 3)</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">my-filter</span>
  <span class="tok-p">[</span><span class="tok-nv">pred</span> <span class="tok-nv">coll</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">when-let </span><span class="tok-p">[</span><span class="tok-nv">s</span> <span class="tok-p">(</span><span class="tok-nb">seq </span><span class="tok-nv">coll</span><span class="tok-p">)]</span>
    <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">f</span> <span class="tok-p">(</span><span class="tok-nb">first </span><span class="tok-nv">s</span><span class="tok-p">)</span>
          <span class="tok-nv">r</span> <span class="tok-p">(</span><span class="tok-nb">rest </span><span class="tok-nv">s</span><span class="tok-p">)]</span>
      <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nf">pred</span> <span class="tok-nv">f</span><span class="tok-p">)</span>
        <span class="tok-p">(</span><span class="tok-nb">cons </span><span class="tok-nv">f</span> <span class="tok-p">(</span><span class="tok-nf">my-filter</span> <span class="tok-nv">pred</span> <span class="tok-nv">r</span><span class="tok-p">))</span>
        <span class="tok-p">(</span><span class="tok-nf">my-filter</span> <span class="tok-nv">pred</span> <span class="tok-nv">r</span><span class="tok-p">)))))</span>

<span class="tok-p">(</span><span class="tok-nf">my-filter</span> <span class="tok-nv">odd?</span> <span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; (1)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As we can see, they both assume that they receive a seqable and return a sequence. Like many recursive<br>
functions they can be implemented in terms of the already familiar <code>reduce</code> function. Note that functions<br>
that are given to reduce receive an accumulator and an input and return the next accumulator. We&#8217;ll call<br>
these types of functions reducing functions from now on.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">my-mapr</span>
  <span class="tok-p">[</span><span class="tok-nv">f</span> <span class="tok-nv">coll</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">reduce </span><span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">acc</span> <span class="tok-nv">input</span><span class="tok-p">]</span>         <span class="tok-c1">;; reducing function</span>
            <span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-nv">acc</span> <span class="tok-p">(</span><span class="tok-nf">f</span> <span class="tok-nv">input</span><span class="tok-p">)))</span>
          <span class="tok-p">[]</span>                      <span class="tok-c1">;; initial value</span>
          <span class="tok-nv">coll</span><span class="tok-p">))</span>                  <span class="tok-c1">;; collection to reduce</span>

<span class="tok-p">(</span><span class="tok-nf">my-mapr</span> <span class="tok-nb">inc </span><span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; [1 2 3]</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">my-filterr</span>
  <span class="tok-p">[</span><span class="tok-nv">pred</span> <span class="tok-nv">coll</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">reduce </span><span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">acc</span> <span class="tok-nv">input</span><span class="tok-p">]</span>         <span class="tok-c1">;; reducing function</span>
            <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nf">pred</span> <span class="tok-nv">input</span><span class="tok-p">)</span>
              <span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-nv">acc</span> <span class="tok-nv">input</span><span class="tok-p">)</span>
              <span class="tok-nv">acc</span><span class="tok-p">))</span>
          <span class="tok-p">[]</span>                      <span class="tok-c1">;; initial value</span>
          <span class="tok-nv">coll</span><span class="tok-p">))</span>                  <span class="tok-c1">;; collection to reduce</span>

<span class="tok-p">(</span><span class="tok-nf">my-filterr</span> <span class="tok-nv">odd?</span> <span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; [1]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;ve made the previous versions more general since using <code>reduce</code> makes our functions work on any thing<br>
that is reducible, not just sequences. However you may have noticed that, even though <code>my-mapr</code> and <code>my-filterr</code><br>
don&#8217;t know anything about the source (<code>coll</code>) they are still tied to the output they produce (a vector) both<br>
with the initial value of the reduce (<code>[]</code>) and the hardcoded <code>conj</code> operation in the body of the reducing<br>
function. We could have accumulated results in another data structure, for example a lazy sequence, but<br>
we&#8217;d have to rewrite the functions in order to do so.</p>
</div>
<div class="paragraph">
<p>How can we make these functions truly generic? They shouldn&#8217;t know about either the source of inputs they<br>
are transforming nor the output that is generated. Have you noticed that <code>conj</code> is just another reducing<br>
function? It takes an accumulator and an input and returns another accumulator. So, if we parameterise<br>
the reducing function that <code>my-mapr</code> and <code>my-filterr</code> use, they won&#8217;t know anything about the type of the<br>
result they are building. Let&#8217;s give it a shot:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">my-mapt</span>
  <span class="tok-p">[</span><span class="tok-nv">f</span><span class="tok-p">]</span>                         <span class="tok-c1">;; function to map over inputs</span>
  <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">rfn</span><span class="tok-p">]</span>                   <span class="tok-c1">;; parameterised reducing function</span>
    <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">acc</span> <span class="tok-nv">input</span><span class="tok-p">]</span>           <span class="tok-c1">;; transformed reducing function, now it maps `f`!</span>
      <span class="tok-p">(</span><span class="tok-nf">rfn</span> <span class="tok-nv">acc</span> <span class="tok-p">(</span><span class="tok-nf">f</span> <span class="tok-nv">input</span><span class="tok-p">)))))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">incer</span> <span class="tok-p">(</span><span class="tok-nf">my-mapt</span> <span class="tok-nv">inc</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nb">reduce </span><span class="tok-p">(</span><span class="tok-nf">incer</span> <span class="tok-nv">conj</span><span class="tok-p">)</span> <span class="tok-p">[]</span> <span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; [1 2 3]</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">my-filtert</span>
  <span class="tok-p">[</span><span class="tok-nv">pred</span><span class="tok-p">]</span>                      <span class="tok-c1">;; predicate to filter out inputs</span>
  <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">rfn</span><span class="tok-p">]</span>                   <span class="tok-c1">;; parameterised reducing function</span>
    <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">acc</span> <span class="tok-nv">input</span><span class="tok-p">]</span>           <span class="tok-c1">;; transformed reducing function, now it discards values based on `pred`!</span>
      <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nf">pred</span> <span class="tok-nv">input</span><span class="tok-p">)</span>
        <span class="tok-p">(</span><span class="tok-nf">rfn</span> <span class="tok-nv">acc</span> <span class="tok-nv">input</span><span class="tok-p">)</span>
        <span class="tok-nv">acc</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">only-odds</span> <span class="tok-p">(</span><span class="tok-nf">my-filtert</span> <span class="tok-nv">odd?</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nb">reduce </span><span class="tok-p">(</span><span class="tok-nf">only-odds</span> <span class="tok-nv">conj</span><span class="tok-p">)</span> <span class="tok-p">[]</span> <span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; [1]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>That&#8217;s a lot of higher-order functions so let&#8217;s break it down for a better understanding of what&#8217;s going<br>
on. We&#8217;ll examine how <code>my-mapt</code> works step by step. The mechanics are similar for <code>my-filtert</code>, so we&#8217;ll<br>
leave it out for now.</p>
</div>
<div class="paragraph">
<p>First of all, <code>my-mapt</code> takes a mapping function; in the example we are giving it <code>inc</code> and getting<br>
another function back. Let&#8217;s replace <code>f</code> with <code>inc</code> to see what we are building:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">incer</span> <span class="tok-p">(</span><span class="tok-nf">my-mapt</span> <span class="tok-nv">inc</span><span class="tok-p">))</span>
<span class="tok-c1">;; (fn [rfn]</span>
<span class="tok-c1">;;   (fn [acc input]</span>
<span class="tok-c1">;;     (rfn acc (inc input))))</span>
<span class="tok-c1">;;               ^^^</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The resulting function is still parameterised to receive a reducing function to which it will delegate,<br>
let&#8217;s see what happens when we call it with <code>conj</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">incer</span> <span class="tok-nv">conj</span><span class="tok-p">)</span>
<span class="tok-c1">;; (fn [acc input]</span>
<span class="tok-c1">;;   (conj acc (inc input)))</span>
<span class="tok-c1">;;    ^^^^</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We get back a reducing function which uses <code>inc</code> to transform the inputs and the <code>conj</code> reducing function<br>
to accumulate the results. In essence, we have defined map as the transformation of a reducing function.<br>
The functions that transform one reducing function into another are called transducers in ClojureScript.</p>
</div>
<div class="paragraph">
<p>To ilustrate the generality of transducers, let&#8217;s use different sources and destinations in our call<br>
to <code>reduce</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">reduce </span><span class="tok-p">(</span><span class="tok-nf">incer</span> <span class="tok-nv">str</span><span class="tok-p">)</span> <span class="tok-s">&quot;&quot;</span> <span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; &quot;123&quot;</span>

<span class="tok-p">(</span><span class="tok-nb">reduce </span><span class="tok-p">(</span><span class="tok-nf">only-odds</span> <span class="tok-nv">str</span><span class="tok-p">)</span> <span class="tok-s">&quot;&quot;</span> <span class="tok-o">&#39;</span><span class="tok-p">(</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; &quot;1&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The transducer versions of <code>map</code> and <code>filter</code> transform a process that carries inputs from a source to a<br>
destination but don&#8217;t know anything about where the inputs come from and where they end up. In their<br>
implementation they contain the <em>essence</em> of what they accomplish, independent of context.</p>
</div>
<div class="paragraph">
<p>Now that we know more about transducers we can try to implement our own version of <code>mapcat</code>. We already have<br>
a fundamental piece of it: the <code>map</code> transducer. What <code>mapcat</code> does is map a function over an input and flatten<br>
the resulting structure one level. Let&#8217;s try to implement the catenation part as a transducer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">my-cat</span>
  <span class="tok-p">[</span><span class="tok-nv">rfn</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">acc</span> <span class="tok-nv">input</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nb">reduce </span><span class="tok-nv">rfn</span> <span class="tok-nv">acc</span> <span class="tok-nv">input</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nb">reduce </span><span class="tok-p">(</span><span class="tok-nf">my-cat</span> <span class="tok-nv">conj</span><span class="tok-p">)</span> <span class="tok-p">[]</span> <span class="tok-p">[[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">]</span> <span class="tok-p">[</span><span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">]])</span>
<span class="tok-c1">;; =&gt; [0 1 2 3 4 5]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>my-cat</code> transducer returns a reducing function that catenates its inputs into the accumulator. It does so<br>
reducing the <code>input</code> reducible with the <code>rfn</code> reducing function and using the accumulator (<code>acc</code>) as the<br>
initial value for such reduction. <code>mapcat</code> is simply the composition of <code>map</code> and <code>cat</code>. The order in which<br>
transducers are composed may seem backwards but it&#8217;ll become clear in a moment.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">my-mapcat</span>
  <span class="tok-p">[</span><span class="tok-nv">f</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">comp </span><span class="tok-p">(</span><span class="tok-nf">my-mapt</span> <span class="tok-nv">f</span><span class="tok-p">)</span> <span class="tok-nv">my-cat</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">dupe</span>
  <span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span>
  <span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-nv">x</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">duper</span> <span class="tok-p">(</span><span class="tok-nf">my-mapcat</span> <span class="tok-nv">dupe</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nb">reduce </span><span class="tok-p">(</span><span class="tok-nf">duper</span> <span class="tok-nv">conj</span><span class="tok-p">)</span> <span class="tok-p">[]</span> <span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; [0 0 1 1 2 2]</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="transducers-in-clojurescript-core"><a class="link" href="#transducers-in-clojurescript-core">5.1.3. Transducers in ClojureScript core</a></h4>
<div class="paragraph">
<p>Some of the ClojureScript core functions like <code>map</code>, <code>filter</code> and <code>mapcat</code> support an arity 1 version<br>
that returns a transducer. Let&#8217;s revisit our definition of <code>process-cluster</code> and define it in terms of<br>
transducers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">process-clusters</span>
  <span class="tok-p">(</span><span class="tok-nf">comp</span>
    <span class="tok-p">(</span><span class="tok-nb">mapcat </span><span class="tok-nv">split-cluster</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nb">filter </span><span class="tok-nv">not-rotten</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-nv">clean-grape</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A few things changed since our previous definition <code>process-clusters</code>. First of all, we are using the<br>
transducer-returning versions of <code>mapcat</code>, <code>filter</code> and <code>map</code> instead of partially applying them for<br>
working on sequences.</p>
</div>
<div class="paragraph">
<p>Also you may have noticed that the order in which they are composed is reversed, they appear in the order<br>
they are executed. Note that all <code>map</code>, <code>filter</code> and <code>mapcat</code> return a transducer. <code>filter</code> transforms the<br>
reducing function returned by <code>map</code>, applying the filtering before proceeding; <code>mapcat</code> transforms the reducing<br>
function returned by <code>filter</code>, applying the mapping and catenation before proceeding.</p>
</div>
<div class="paragraph">
<p>One of the powerful properties of transducers is that they are combined using regular function composition.<br>
What&#8217;s even more elegant is that the composition of various transducers is itself a transducer! This means<br>
that our <code>process-cluster</code> is a transducer too, so we have defined a composable and context-independent<br>
algorithmic transformation.</p>
</div>
<div class="paragraph">
<p>Many of the core ClojureScript functions accept a transducer, let&#8217;s look at some examples with our newly<br>
created <code>process-cluster</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">into </span><span class="tok-p">[]</span> <span class="tok-nv">process-clusters</span> <span class="tok-nv">grape-clusters</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [{:rotten? false, :clean? true} {:rotten? false, :clean? true}]</span>

<span class="tok-p">(</span><span class="tok-nf">sequence</span> <span class="tok-nv">process-clusters</span> <span class="tok-nv">grape-clusters</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; ({:rotten? false, :clean? true} {:rotten? false, :clean? true})</span>

<span class="tok-p">(</span><span class="tok-nb">reduce </span><span class="tok-p">(</span><span class="tok-nf">process-clusters</span> <span class="tok-nv">conj</span><span class="tok-p">)</span> <span class="tok-p">[]</span> <span class="tok-nv">grape-clusters</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [{:rotten? false, :clean? true} {:rotten? false, :clean? true}]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Since using <code>reduce</code> with the reducing function returned from a transducer is so common, there is<br>
a function for reducing with a transformation called <code>transduce</code>. We can now rewrite the previous call<br>
to <code>reduce</code> using <code>transduce</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">transduce</span> <span class="tok-nv">process-clusters</span> <span class="tok-nb">conj </span><span class="tok-p">[]</span> <span class="tok-nv">grape-clusters</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [{:rotten? false, :clean? true} {:rotten? false, :clean? true}]</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="initialisation"><a class="link" href="#initialisation">5.1.4. Initialisation</a></h4>
<div class="paragraph">
<p>In the last example we provided an initial value to the <code>transduce</code> function (<code>[]</code>) but we can omit it<br>
and get the same result:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">transduce</span> <span class="tok-nv">process-clusters</span> <span class="tok-nb">conj </span><span class="tok-nv">grape-clusters</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [{:rotten? false, :clean? true} {:rotten? false, :clean? true}]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>What&#8217;s going on here? How can <code>transduce</code> know what initial value use as an accumulator when we haven&#8217;t<br>
specified it? Try calling <code>conj</code> without any arguments and see what happens:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">conj</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; []</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>conj</code> function has a arity 0 version that returns an empty vector but is not the only reducing function<br>
that supports arity 0. Let&#8217;s explore some others:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">+</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 0</span>

<span class="tok-p">(</span><span class="tok-nf">*</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 1</span>

<span class="tok-p">(</span><span class="tok-nf">str</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;&quot;</span>

<span class="tok-p">(</span><span class="tok-nb">= identity </span><span class="tok-p">(</span><span class="tok-nf">comp</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; true</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The reducing function returned by transducers must support the arity 0 as well, which will typically delegate<br>
to the transformed reducing function. There is no sensible implementation of the arity 0 for the transducers<br>
we have implemented so far, so we&#8217;ll simply call the reducing function without arguments. Here&#8217;s how our<br>
modified <code>my-mapt</code> could look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">my-mapt</span>
  <span class="tok-p">[</span><span class="tok-nv">f</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">rfn</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nf">fn</span>
      <span class="tok-p">([]</span> <span class="tok-p">(</span><span class="tok-nf">rfn</span><span class="tok-p">))</span>                <span class="tok-c1">;; arity 0 that delegates to the reducing fn</span>
      <span class="tok-p">([</span><span class="tok-nv">acc</span> <span class="tok-nv">input</span><span class="tok-p">]</span>
        <span class="tok-p">(</span><span class="tok-nf">rfn</span> <span class="tok-nv">acc</span> <span class="tok-p">(</span><span class="tok-nf">f</span> <span class="tok-nv">input</span><span class="tok-p">))))))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The call to the arity 0 of the reducing function returned by a transducer will call the arity 0 version of<br>
every nested reducing function, eventually calling the outermost reducing function. Let&#8217;s see an example with<br>
our already defined <code>process-clusters</code> transducer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">((</span><span class="tok-nf">process-clusters</span> <span class="tok-nv">conj</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; []</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The call to the arity 0 flows through the transducer stack, eventually calling <code>(conj)</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="stateful-transducers"><a class="link" href="#stateful-transducers">5.1.5. Stateful transducers</a></h4>
<div class="paragraph">
<p>So far we&#8217;ve only seen purely functional transducer; they don&#8217;t have any implicit state and are very<br>
predictable. However, there are many data transformation functions that are inherently stateful, like<br>
<code>take</code>. <code>take</code> receives a number <code>n</code> of elements to keep and a collection and returns a collection with at<br>
most <code>n</code> elements.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">take </span><span class="tok-mi">10</span> <span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">100</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; (0 1 2 3 4 5 6 7 8 9)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s step back for a bit and learn about the early termination of the <code>reduce</code> function. We can wrap an<br>
accumulator in a type called <code>reduced</code> for telling <code>reduce</code> that the reduction process should terminate<br>
immediately. Let&#8217;s see an example of a reduction that aggregates the inputs in a collection and finishes<br>
as soon as there are 10 elements in the accumulator:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">reduce </span><span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">acc</span> <span class="tok-nv">input</span><span class="tok-p">]</span>
          <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-p">(</span><span class="tok-nb">count </span><span class="tok-nv">acc</span><span class="tok-p">)</span> <span class="tok-mi">10</span><span class="tok-p">)</span>
            <span class="tok-p">(</span><span class="tok-nf">reduced</span> <span class="tok-nv">acc</span><span class="tok-p">)</span>
            <span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-nv">acc</span> <span class="tok-nv">input</span><span class="tok-p">)))</span>
         <span class="tok-p">[]</span>
         <span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">100</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; [0 1 2 3 4 5 6 7 8 9]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Since transducers are modifications of reducing functions they also use <code>reduced</code> for early termination.<br>
Note that stateful transducers may need to do some cleanup before the process terminates, so they<br>
must support an arity 1 as a "completion" step. Usually, like with arity 0, this arity will simply delegate<br>
to the transformed reducing function&#8217;s arity 1.</p>
</div>
<div class="paragraph">
<p>Knowing this we are able to write stateful transducers like <code>take</code>. We&#8217;ll be using mutable state internally<br>
for tracking the number of inputs we have seen so far, and wrap the accumulator in a <code>reduced</code> as soon as<br>
we&#8217;ve seen enough elements:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">my-take</span>
  <span class="tok-p">[</span><span class="tok-nv">n</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">rfn</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">remaining</span> <span class="tok-p">(</span><span class="tok-nf">volatile!</span> <span class="tok-nv">n</span><span class="tok-p">)]</span>
      <span class="tok-p">(</span><span class="tok-nf">fn</span>
        <span class="tok-p">([]</span> <span class="tok-p">(</span><span class="tok-nf">rfn</span><span class="tok-p">))</span>
        <span class="tok-p">([</span><span class="tok-nv">acc</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nf">rfn</span> <span class="tok-nv">acc</span><span class="tok-p">))</span>
        <span class="tok-p">([</span><span class="tok-nv">acc</span> <span class="tok-nv">input</span><span class="tok-p">]</span>
          <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nb">rem </span><span class="tok-o">@</span><span class="tok-nv">remaining</span>
                <span class="tok-nv">nr</span> <span class="tok-p">(</span><span class="tok-nf">vswap!</span> <span class="tok-nv">remaining</span> <span class="tok-nv">dec</span><span class="tok-p">)</span>
                <span class="tok-nv">result</span> <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">pos? </span><span class="tok-nv">rem</span><span class="tok-p">)</span>
                         <span class="tok-p">(</span><span class="tok-nf">rfn</span> <span class="tok-nv">acc</span> <span class="tok-nv">input</span><span class="tok-p">)</span>   <span class="tok-c1">;; we still have items to take</span>
                         <span class="tok-nv">acc</span><span class="tok-p">)]</span>             <span class="tok-c1">;; we&#39;re done, acc becomes the result</span>
            <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">not </span><span class="tok-p">(</span><span class="tok-nb">pos? </span><span class="tok-nv">nr</span><span class="tok-p">))</span>
              <span class="tok-p">(</span><span class="tok-nf">ensure-reduced</span> <span class="tok-nv">result</span><span class="tok-p">)</span>      <span class="tok-c1">;; wrap result in reduced if not already</span>
              <span class="tok-nv">result</span><span class="tok-p">)))))))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a simplified version of the <code>take</code> function present in ClojureScript core. There are<br>
a few things to note here so let&#8217;s break it up in pieces to understand it better.</p>
</div>
<div class="paragraph">
<p>The first thing to notice is that we are creating a mutable value inside the transducer. Note<br>
that we don&#8217;t create it until we receive a reducing function to transform. If we created it before<br>
returning the transducer we couldn&#8217;t use <code>my-take</code> more than once. Since the transducer is handed<br>
a reducing function to transform each time it is used, we can use it multiple times and the mutable<br>
variable will be created in every use.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">rfn</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">remaining</span> <span class="tok-p">(</span><span class="tok-nf">volatile!</span> <span class="tok-nv">n</span><span class="tok-p">)]</span> <span class="tok-c1">;; make sure to create mutable variables inside the transducer</span>
    <span class="tok-p">(</span><span class="tok-nf">fn</span>
      <span class="tok-c1">;; ...</span>
<span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">take-five</span> <span class="tok-p">(</span><span class="tok-nf">my-take</span> <span class="tok-mi">5</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">transduce</span> <span class="tok-nv">take-five</span> <span class="tok-nb">conj </span><span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">100</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; [0 1 2 3 4]</span>

<span class="tok-p">(</span><span class="tok-nf">transduce</span> <span class="tok-nv">take-five</span> <span class="tok-nb">conj </span><span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">100</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; [0 1 2 3 4]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s now dig into the reducing function returned from <code>my-take</code>. First of all we <code>deref</code> the volatile<br>
to get the number of elements that remain to be taken and decrement it to get the next remaining value.<br>
If there are still remaining items to take, we call <code>rfn</code> passing the accumulator and input; if not, we<br>
already have the final result.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">([</span><span class="tok-nv">acc</span> <span class="tok-nv">input</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nb">rem </span><span class="tok-o">@</span><span class="tok-nv">remaining</span>
        <span class="tok-nv">nr</span> <span class="tok-p">(</span><span class="tok-nf">vswap!</span> <span class="tok-nv">remaining</span> <span class="tok-nv">dec</span><span class="tok-p">)</span>
        <span class="tok-nv">result</span> <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">pos? </span><span class="tok-nv">rem</span><span class="tok-p">)</span>
                 <span class="tok-p">(</span><span class="tok-nf">rfn</span> <span class="tok-nv">acc</span> <span class="tok-nv">input</span><span class="tok-p">)</span>
                 <span class="tok-nv">acc</span><span class="tok-p">)]</span>
    <span class="tok-c1">;; ...</span>
<span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The body of <code>my-take</code> should be obvious by now. We check whether there are still items to be processed<br>
using the next remainder (<code>nr</code>) and, if not, wrap the result in a <code>reduced</code> using the <code>ensure-reduced</code><br>
function. <code>ensure-reduced</code> will wrap the value in a <code>reduced</code> if it&#8217;s not reduced already or simply return<br>
the value if it&#8217;s already reduced. In case we are not done yet, we return the accumulated <code>result</code> for<br>
further processing.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">not </span><span class="tok-p">(</span><span class="tok-nb">pos? </span><span class="tok-nv">nr</span><span class="tok-p">))</span>
  <span class="tok-p">(</span><span class="tok-nf">ensure-reduced</span> <span class="tok-nv">result</span><span class="tok-p">)</span>
  <span class="tok-nv">result</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;ve seen an example of a stateful transducer but it didn&#8217;t do anything in its completion step. Let&#8217;s<br>
see an example of a transducer that uses the completion step to flush an accumulated value. We&#8217;ll<br>
implement a simplified version of <code>partition-all</code>, which given a <code>n</code> number of elements converts the inputs<br>
in vectors of size <code>n</code>. For understanding its purpose better let&#8217;s see what the arity 2 version gives us when<br>
providing a number and a collection:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">partition-all</span> <span class="tok-mi">3</span> <span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">10</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; ((0 1 2) (3 4 5) (6 7 8) (9))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The transducer returning function of <code>partition-all</code> will take a number <code>n</code> and return a transducer that groups<br>
inputs in vectors of size <code>n</code>. In the completion step it will check if there is an accumulated result and, if so,<br>
add it to the result. Here&#8217;s a simplified version of ClojureScript core <code>partition-all</code> function, where <code>array-list</code><br>
is a wrapper for a mutable JavaScript array:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">my-partition-all</span>
  <span class="tok-p">[</span><span class="tok-nv">n</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">rfn</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">a</span> <span class="tok-p">(</span><span class="tok-nf">array-list</span><span class="tok-p">)]</span>
      <span class="tok-p">(</span><span class="tok-nf">fn</span>
        <span class="tok-p">([]</span> <span class="tok-p">(</span><span class="tok-nf">rfn</span><span class="tok-p">))</span>
        <span class="tok-p">([</span><span class="tok-nv">result</span><span class="tok-p">]</span>
          <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">result</span> <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nf">.isEmpty</span> <span class="tok-nv">a</span><span class="tok-p">)</span>                  <span class="tok-c1">;; no inputs accumulated, don&#39;t have to modify result</span>
                         <span class="tok-nv">result</span>
                         <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">v</span> <span class="tok-p">(</span><span class="tok-nf">vec</span> <span class="tok-p">(</span><span class="tok-nf">.toArray</span> <span class="tok-nv">a</span><span class="tok-p">))]</span>
                           <span class="tok-p">(</span><span class="tok-nf">.clear</span> <span class="tok-nv">a</span><span class="tok-p">)</span>                    <span class="tok-c1">;; flush array contents for garbage collection</span>
                           <span class="tok-p">(</span><span class="tok-nf">unreduced</span> <span class="tok-p">(</span><span class="tok-nf">rfn</span> <span class="tok-nv">result</span> <span class="tok-nv">v</span><span class="tok-p">))))]</span> <span class="tok-c1">;; pass to `rfn`, removing the reduced wrapper if present</span>
            <span class="tok-p">(</span><span class="tok-nf">rfn</span> <span class="tok-nv">result</span><span class="tok-p">)))</span>
        <span class="tok-p">([</span><span class="tok-nv">acc</span> <span class="tok-nv">input</span><span class="tok-p">]</span>
          <span class="tok-p">(</span><span class="tok-nf">.add</span> <span class="tok-nv">a</span> <span class="tok-nv">input</span><span class="tok-p">)</span>
          <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">== </span><span class="tok-nv">n</span> <span class="tok-p">(</span><span class="tok-nf">.size</span> <span class="tok-nv">a</span><span class="tok-p">))</span>                           <span class="tok-c1">;; got enough results for a chunk</span>
            <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">v</span> <span class="tok-p">(</span><span class="tok-nf">vec</span> <span class="tok-p">(</span><span class="tok-nf">.toArray</span> <span class="tok-nv">a</span><span class="tok-p">))]</span>
              <span class="tok-p">(</span><span class="tok-nf">.clear</span> <span class="tok-nv">a</span><span class="tok-p">)</span>
              <span class="tok-p">(</span><span class="tok-nf">rfn</span> <span class="tok-nv">acc</span> <span class="tok-nv">v</span><span class="tok-p">))</span>                               <span class="tok-c1">;; the accumulated chunk becomes input to `rfn`</span>
            <span class="tok-nv">acc</span><span class="tok-p">))))))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">triples</span> <span class="tok-p">(</span><span class="tok-nf">my-partition-all</span> <span class="tok-mi">3</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">transduce</span> <span class="tok-nv">triples</span> <span class="tok-nb">conj </span><span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">10</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; [[0 1 2] [3 4 5] [6 7 8] [9]]</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="eductions"><a class="link" href="#eductions">5.1.6. Eductions</a></h4>
<div class="paragraph">
<p>Eductions are a way to combine a collection and one or more transformations that can be reduced and iterated over,<br>
and that apply the transformations every time we do so. If we have a collection that we want to process and a<br>
transformation over it that we want others to extend, we can hand them a eduction, encapsulating the source<br>
collection and our transformation. We can create an eduction with the <code>eduction</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ed</span> <span class="tok-p">(</span><span class="tok-nf">eduction</span> <span class="tok-p">(</span><span class="tok-nb">filter </span><span class="tok-nv">odd?</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nb">take </span><span class="tok-mi">5</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">100</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nb">reduce + </span><span class="tok-mi">0</span> <span class="tok-nv">ed</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 25</span>

<span class="tok-p">(</span><span class="tok-nf">transduce</span> <span class="tok-p">(</span><span class="tok-nf">partition-all</span> <span class="tok-mi">2</span><span class="tok-p">)</span> <span class="tok-nb">conj </span><span class="tok-nv">ed</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [[1 3] [5 7] [9]]</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="more-transducers-in-clojurescript-core"><a class="link" href="#more-transducers-in-clojurescript-core">5.1.7. More transducers in ClojureScript core</a></h4>
<div class="paragraph">
<p>We learned about <code>map</code>, <code>filter</code>, <code>mapcat</code>, <code>take</code> and <code>partition-all</code>, but there are a lot more transducers<br>
available in ClojureScript. Here is an incomplete list of some other intersting ones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>drop</code> is the dual of <code>take</code>, dropping up to <code>n</code> values before passing inputs to the reducing function</p>
</li>
<li>
<p><code>distinct</code> only allows inputs to occur once</p>
</li>
<li>
<p><code>dedupe</code> removes succesive duplicates in input values</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We encourage you to explore ClojureScript core to see what other transducers are out there.</p>
</div>
</div>
<div class="sect3">
<h4 id="defining-our-own-transducers"><a class="link" href="#defining-our-own-transducers">5.1.8. Defining our own transducers</a></h4>
<div class="paragraph">
<p>Since most transducers are only interesting in the reducing step implementation and often delegate to the<br>
reducing function in arities 0 and 1, there is a little helper called <code>completing</code> that fills those arities<br>
for you:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-c1">;; if a completing function is not defined, identity will be used</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">my-transducer</span>
  <span class="tok-p">(</span><span class="tok-nf">completing</span>
    <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">acc</span> <span class="tok-nv">input</span><span class="tok-p">]</span>
     <span class="tok-c1">;; ...</span>
     <span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">my-transducer-with-completion</span>
  <span class="tok-p">(</span><span class="tok-nf">completing</span>
    <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">acc</span> <span class="tok-nv">input</span><span class="tok-p">]</span>
     <span class="tok-c1">;; ...</span>
     <span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">result</span><span class="tok-p">]</span>
     <span class="tok-c1">;; ...</span>
    <span class="tok-p">)))</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="transducible-processes"><a class="link" href="#transducible-processes">5.1.9. Transducible processes</a></h4>
<div class="paragraph">
<p>A transducible process is any process that is defined in terms of a succession of steps ingesting input values.<br>
The source of input varies from one process to another. Most of our examples dealt with inputs from a collection<br>
or a lazy sequence, but it could be an asynchronous stream of values or a <code>core.async</code> channel. The outputs produced<br>
by each step are also different for every process; <code>into</code> creates a collection with every output of the transducer,<br>
<code>sequence</code> yields a lazy sequence, and asynchronous streams would probably push the outputs to their listeners.</p>
</div>
<div class="paragraph">
<p>In order to improve our understanding of transducible processes, we&#8217;re going to implement an unbounded queue, since adding<br>
values to a queue can be thought in terms of a succession of steps ingesting input. First of all we&#8217;ll define a<br>
protocol and a data type that implements the unbounded queue:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defprotocol </span><span class="tok-nv">Queue</span>
  <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-p">[</span><span class="tok-nv">q</span> <span class="tok-nv">item</span><span class="tok-p">]</span> <span class="tok-s">&quot;put an item into the queue&quot;</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-p">[</span><span class="tok-nv">q</span><span class="tok-p">]</span> <span class="tok-s">&quot;take an item from the queue&quot;</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">shutdown!</span> <span class="tok-p">[</span><span class="tok-nv">q</span><span class="tok-p">]</span> <span class="tok-s">&quot;stop accepting puts in the queue&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-kd">deftype </span><span class="tok-nv">UnboundedQueue</span> <span class="tok-p">[</span><span class="tok-o">^</span><span class="tok-ss">:mutable</span> <span class="tok-nv">arr</span> <span class="tok-o">^</span><span class="tok-ss">:mutable</span> <span class="tok-nv">closed</span><span class="tok-p">]</span>
  <span class="tok-nv">Queue</span>
  <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-p">[</span><span class="tok-nv">_</span> <span class="tok-nv">item</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nb">assert </span><span class="tok-p">(</span><span class="tok-nb">not </span><span class="tok-nv">closed</span><span class="tok-p">))</span>
    <span class="tok-p">(</span><span class="tok-nb">assert </span><span class="tok-p">(</span><span class="tok-nb">not </span><span class="tok-p">(</span><span class="tok-nb">nil? </span><span class="tok-nv">item</span><span class="tok-p">)))</span>
    <span class="tok-p">(</span><span class="tok-nf">.push</span> <span class="tok-nv">arr</span> <span class="tok-nv">item</span><span class="tok-p">)</span>
    <span class="tok-nv">item</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-p">[</span><span class="tok-nv">_</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nb">aget </span><span class="tok-p">(</span><span class="tok-nf">.splice</span> <span class="tok-nv">arr</span> <span class="tok-mi">0</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-mi">0</span><span class="tok-p">))</span>
  <span class="tok-p">(</span><span class="tok-nf">shutdown!</span> <span class="tok-p">[</span><span class="tok-nv">_</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nf">set!</span> <span class="tok-nv">closed</span> <span class="tok-nv">true</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We defined the <code>Queue</code> protocol and as you may have noticed the implementation of <code>UnboundedQueue</code> doesn&#8217;t<br>
know about transducers at all. It has a <code>put!</code> operation as its step function and we&#8217;re going to implement<br>
the transducible process on top of that interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">unbounded-queue</span>
  <span class="tok-p">([]</span>
   <span class="tok-p">(</span><span class="tok-nf">queue</span> <span class="tok-nv">nil</span><span class="tok-p">))</span>
  <span class="tok-p">([</span><span class="tok-nv">xform</span><span class="tok-p">]</span>
   <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">put!</span> <span class="tok-p">(</span><span class="tok-nf">completing</span> <span class="tok-nv">put!</span><span class="tok-p">)</span>
         <span class="tok-nv">xput!</span> <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-nv">xform</span> <span class="tok-p">(</span><span class="tok-nf">xform</span> <span class="tok-nv">put!</span><span class="tok-p">)</span> <span class="tok-nv">put!</span><span class="tok-p">)</span>
         <span class="tok-nv">q</span> <span class="tok-p">(</span><span class="tok-nf">UnboundedQueue.</span> <span class="tok-o">#</span><span class="tok-nv">js</span> <span class="tok-p">[]</span> <span class="tok-nv">false</span><span class="tok-p">)]</span>
     <span class="tok-p">(</span><span class="tok-nf">reify</span>
       <span class="tok-nv">Queue</span>
       <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-p">[</span><span class="tok-nv">_</span> <span class="tok-nv">item</span><span class="tok-p">]</span>
         <span class="tok-p">(</span><span class="tok-nb">when-not </span><span class="tok-p">(</span><span class="tok-nf">.-closed</span> <span class="tok-nv">q</span><span class="tok-p">)</span>
           <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nb">val </span><span class="tok-p">(</span><span class="tok-nf">xput!</span> <span class="tok-nv">q</span> <span class="tok-nv">item</span><span class="tok-p">)]</span>
             <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nf">reduced?</span> <span class="tok-nv">val</span><span class="tok-p">)</span>
               <span class="tok-p">(</span><span class="tok-nf">do</span>
                 <span class="tok-p">(</span><span class="tok-nf">xput!</span> <span class="tok-o">@</span><span class="tok-nv">val</span><span class="tok-p">)</span>  <span class="tok-c1">;; call completion step</span>
                 <span class="tok-p">(</span><span class="tok-nf">shutdown!</span> <span class="tok-nv">q</span><span class="tok-p">)</span> <span class="tok-c1">;; respect reduced</span>
                 <span class="tok-o">@</span><span class="tok-nv">val</span><span class="tok-p">)</span>
               <span class="tok-nv">val</span><span class="tok-p">))))</span>
       <span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-p">[</span><span class="tok-nv">_</span><span class="tok-p">]</span>
         <span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">q</span><span class="tok-p">))</span>
       <span class="tok-p">(</span><span class="tok-nf">shutdown!</span> <span class="tok-p">[</span><span class="tok-nv">_</span><span class="tok-p">]</span>
         <span class="tok-p">(</span><span class="tok-nf">shutdown!</span> <span class="tok-nv">q</span><span class="tok-p">))))))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, the <code>unbounded-queue</code> constructor uses an <code>UnboundedQueue</code> instance internally, proxying the<br>
<code>take!</code> and <code>shutdown!</code> calls and implementing the transducible process logic in the <code>put!</code> function. Let&#8217;s<br>
deconstruct it to understand what&#8217;s going on.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">put!</span> <span class="tok-p">(</span><span class="tok-nf">completing</span> <span class="tok-nv">put!</span><span class="tok-p">)</span>
      <span class="tok-nv">xput!</span> <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-nv">xform</span> <span class="tok-p">(</span><span class="tok-nf">xform</span> <span class="tok-nv">put!</span><span class="tok-p">)</span> <span class="tok-nv">put!</span><span class="tok-p">)</span>
      <span class="tok-nv">q</span> <span class="tok-p">(</span><span class="tok-nf">UnboundedQueue.</span> <span class="tok-o">#</span><span class="tok-nv">js</span> <span class="tok-p">[]</span> <span class="tok-nv">false</span><span class="tok-p">)]</span>
  <span class="tok-c1">;; ...</span>
<span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>First of all, we use <code>completing</code> for adding the arity 0 and arity 1 to the <code>Queue</code> protocol&#8217;s <code>put!</code> function.<br>
This will make it play nicely with transducers in case we give this reducing function to <code>xform</code> to derive another.<br>
After that, if a transducer (<code>xform</code>) was provided, we derive a reducing function applying the transducer to <code>put!</code>.<br>
If we&#8217;re not handed a transducer we will just use <code>put!</code>. <code>q</code> is the internal instance of <code>UnboundedQueue</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">reify</span>
  <span class="tok-nv">Queue</span>
  <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-p">[</span><span class="tok-nv">_</span> <span class="tok-nv">item</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nb">when-not </span><span class="tok-p">(</span><span class="tok-nf">.-closed</span> <span class="tok-nv">q</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nb">val </span><span class="tok-p">(</span><span class="tok-nf">xput!</span> <span class="tok-nv">q</span> <span class="tok-nv">item</span><span class="tok-p">)]</span>
        <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nf">reduced?</span> <span class="tok-nv">val</span><span class="tok-p">)</span>
          <span class="tok-p">(</span><span class="tok-nf">do</span>
            <span class="tok-p">(</span><span class="tok-nf">xput!</span> <span class="tok-o">@</span><span class="tok-nv">val</span><span class="tok-p">)</span>  <span class="tok-c1">;; call completion step</span>
            <span class="tok-p">(</span><span class="tok-nf">shutdown!</span> <span class="tok-nv">q</span><span class="tok-p">)</span> <span class="tok-c1">;; respect reduced</span>
            <span class="tok-o">@</span><span class="tok-nv">val</span><span class="tok-p">)</span>
          <span class="tok-nv">val</span><span class="tok-p">))))</span>
  <span class="tok-c1">;; ...</span>
<span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The exposed <code>put!</code> operation will only be performed if the queue hasn&#8217;t been shut down. Notice that the <code>put!</code><br>
implementation of <code>UnboundedQueue</code> uses an assert to verify that we can still put values to it and we don&#8217;t<br>
want to break that invariant. If the queue isn&#8217;t closed we can put values into it, we use the possibly transformed<br>
<code>xput!</code> for doing so.</p>
</div>
<div class="paragraph">
<p>If the put operation gives back a reduced value it&#8217;s telling us that we should terminate the transducible process.<br>
In this case that means shutting down the queue to not accept more values. If we didn&#8217;t get a reduced value we can<br>
happily continue accepting puts.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see how our queue behaves without transducers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">q</span> <span class="tok-p">(</span><span class="tok-nf">queue</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;[object Object]&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">q</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 1</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">q</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 2</span>

<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">q</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 1</span>
<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">q</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 2</span>
<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">q</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Pretty much what we expected, let&#8217;s now try with a stateless transducer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">incq</span> <span class="tok-p">(</span><span class="tok-nf">queue</span> <span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-nv">inc</span><span class="tok-p">)))</span>
<span class="tok-c1">;; =&gt; #&lt;[object Object]&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">incq</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 2</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">incq</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 3</span>

<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">incq</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 2</span>
<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">incq</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 3</span>
<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">incq</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>To check that we&#8217;ve implemented the transducible process, let&#8217;s use a stateful transducer. We&#8217;ll use a transducer<br>
that will accept values while they aren&#8217;t equal to 4 and will partition inputs in chunks of 2 elements:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">xq</span> <span class="tok-p">(</span><span class="tok-nf">queue</span> <span class="tok-p">(</span><span class="tok-nf">comp</span>
                 <span class="tok-p">(</span><span class="tok-nb">take-while </span><span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">not= </span><span class="tok-nv">%</span> <span class="tok-mi">4</span><span class="tok-p">))</span>
                 <span class="tok-p">(</span><span class="tok-nf">partition-all</span> <span class="tok-mi">2</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">xq</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">xq</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [1 2]</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">xq</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">xq</span> <span class="tok-mi">4</span><span class="tok-p">)</span> <span class="tok-c1">;; shouldn&#39;t accept more values from here on</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">xq</span> <span class="tok-mi">5</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; nil</span>

<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">xq</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [1 2]</span>
<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">xq</span><span class="tok-p">)</span> <span class="tok-c1">;; seems like `partition-all` flushed correctly!</span>
<span class="tok-c1">;; =&gt; [3]</span>
<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">xq</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The example of the queue was heavily inspired by how <code>core.async</code> channels use transducers in their internal<br>
step. We&#8217;ll discuss channels and their usage with transducers in a later section.</p>
</div>
<div class="paragraph">
<p>Transducible processes must respect <code>reduced</code> as a way for signaling early termination. For example,<br>
building a collection stops when encountering a <code>reduced</code> and <code>core.async</code> channels with transducers are closed.<br>
The <code>reduced</code> value must be unwrapped with <code>deref</code> and passed to the completion step, which must be called exactly<br>
once.</p>
</div>
<div class="paragraph">
<p>Transducible processes shouldn&#8217;t expose the reducing function they generate when calling the transducer with their<br>
own step function since it may be stateful and unsafe to use from elsewhere.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="transients"><a class="link" href="#transients">5.2. Transients</a></h3>
<div class="paragraph">
<p>Although ClojureScript&#8217;s immutable and persistent data structures are reasonably performant<br>
there are situations in which we are transforming large data structures using multiple steps<br>
to only share the final result. For example, the core <code>into</code> function takes a collection and eagerly<br>
populates it with the contents of a sequence:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">into </span><span class="tok-p">[]</span> <span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">100</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; [0 1 2 ... 98 99]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example we are generating a vector of 100 elements <code>conj</code>-ing one at a time. Every<br>
intermediate vector that is not the final result won&#8217;t be seen by anybody except the <code>into</code><br>
function and the array copying required for persistence is an unnecesary overhead.</p>
</div>
<div class="paragraph">
<p>For these situations ClojureScript provides a special version of some of its persistent data<br>
structures, which are called transients. Maps, vectors and sets have a transient counterpart.<br>
Transients are always derived from a persistent data structure using the <code>transient</code> function,<br>
which creates a transient version in constant time:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">tv</span> <span class="tok-p">(</span><span class="tok-nf">transient</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]))</span>
<span class="tok-c1">;; =&gt; #&lt;[object Object]&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Transients support the read API of their persistent counterparts:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">tv</span> <span class="tok-p">(</span><span class="tok-nf">transient</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]))</span>

<span class="tok-p">(</span><span class="tok-nb">nth </span><span class="tok-nv">tv</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 1</span>

<span class="tok-p">(</span><span class="tok-nb">get </span><span class="tok-nv">tv</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 3</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">tm</span> <span class="tok-p">(</span><span class="tok-nf">transient</span> <span class="tok-p">{</span><span class="tok-ss">:language</span> <span class="tok-s">&quot;ClojureScript&quot;</span><span class="tok-p">}))</span>

<span class="tok-p">(</span><span class="tok-ss">:language</span> <span class="tok-nv">tm</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;ClojureScript&quot;</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ts</span> <span class="tok-p">(</span><span class="tok-nf">transient</span> <span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-ss">:a</span> <span class="tok-ss">:b</span> <span class="tok-ss">:c</span><span class="tok-p">}))</span>

<span class="tok-p">(</span><span class="tok-nb">contains? </span><span class="tok-nv">ts</span> <span class="tok-ss">:a</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-ss">:a</span> <span class="tok-nv">ts</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; :a</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Since transients don&#8217;t have persistent and immutable semantics for updates they can&#8217;t be transformed<br>
using the already familiar <code>conj</code> or <code>assoc</code> functions. Instead, the transforming functions that work<br>
on transients end with a bang. Let&#8217;s look at an example using <code>conj!</code> on a transient:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">tv</span> <span class="tok-p">(</span><span class="tok-nf">transient</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]))</span>

<span class="tok-p">(</span><span class="tok-nf">conj!</span> <span class="tok-nv">tv</span> <span class="tok-mi">4</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;[object Object]&gt;</span>

<span class="tok-p">(</span><span class="tok-nb">nth </span><span class="tok-nv">tv</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 4</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, the transient version of the vector is neither immutable or persistent. Instead, the<br>
vector is mutated in place. Although we could transform <code>tv</code> repeatedly using <code>conj!</code> on it we shouldn&#8217;t<br>
abandon the idioms used with the persistent data structures: when transforming a transient, use the<br>
returned version of it for further modifications like in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">-&gt; </span><span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]</span>
  <span class="tok-nv">transient</span>
  <span class="tok-p">(</span><span class="tok-nf">conj!</span> <span class="tok-mi">4</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">conj!</span> <span class="tok-mi">5</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;[object Object]&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We can convert a transient back to a persistent and immutable data structure by calling <code>persistent!</code> on<br>
it. This operation, like deriving a transient from a persistent data structure, is done in constant time.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">-&gt; </span><span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]</span>
  <span class="tok-nv">transient</span>
  <span class="tok-p">(</span><span class="tok-nf">conj!</span> <span class="tok-mi">4</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">conj!</span> <span class="tok-mi">5</span><span class="tok-p">)</span>
  <span class="tok-nv">persistent!</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [1 2 3 4 5]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A peculiarity of transforming transients into persistent structures is that the transient version is<br>
invalidated after being converted to a persistent data structure and we can&#8217;t do further transformations<br>
to it. This happens because the derived persistent data structure uses the transient&#8217;s internal nodes<br>
and mutating them would break the immutability and persistent guarantees:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">tm</span> <span class="tok-p">(</span><span class="tok-nf">transient</span> <span class="tok-p">{}))</span>
<span class="tok-c1">;; =&gt; #&lt;[object Object]&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">assoc!</span> <span class="tok-nv">tm</span> <span class="tok-ss">:foo</span> <span class="tok-ss">:bar</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;[object Object]&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">persistent!</span> <span class="tok-nv">tm</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:foo :bar}</span>

<span class="tok-p">(</span><span class="tok-nf">assoc!</span> <span class="tok-nv">tm</span> <span class="tok-ss">:baz</span> <span class="tok-ss">:frob</span><span class="tok-p">)</span>
<span class="tok-c1">;; Error: assoc! after persistent!</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Going back to our initial example with <code>into</code>, here&#8217;s a very simplified implementation of it that uses<br>
a transient for performance, returning a persistent data structure and thus exposing a purely functional<br>
interface although it uses mutation internally:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">my-into</span>
  <span class="tok-p">[</span><span class="tok-nv">to</span> <span class="tok-nv">from</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">persistent!</span> <span class="tok-p">(</span><span class="tok-nb">reduce </span><span class="tok-nv">conj!</span> <span class="tok-p">(</span><span class="tok-nf">transient</span> <span class="tok-nv">to</span><span class="tok-p">)</span> <span class="tok-nv">from</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">my-into</span> <span class="tok-p">[]</span> <span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">100</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; [0 1 2 ... 98 99]</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="metadata"><a class="link" href="#metadata">5.3. Metadata</a></h3>
<div class="paragraph">
<p><a id="metadata-section"></a></p>
</div>
<div class="paragraph">
<p>ClojureScript symbols, vars and persistent collections support attaching metadata to them. Metadata is<br>
a map with information about the entity it&#8217;s attached to. The ClojureScript compiler uses metadata for<br>
several purposes such as type hints, and the metadata system can be used by tooling, library and application<br>
developers too.</p>
</div>
<div class="paragraph">
<p>There may not be many cases in day-to-day ClojureScript programming where you need metadata, but it is a<br>
nice language feature to have and know about; it may come in handy at some point. It makes things like<br>
runtime code introspection and documentation generation very easy. You&#8217;ll see why throughout this section.</p>
</div>
<div class="sect3">
<h4 id="vars-3"><a class="link" href="#vars-3">5.3.1. Vars</a></h4>
<div class="paragraph">
<p>Let&#8217;s define a var and see what metadata is attached to it by default. Note that this code is executed in<br>
a REPL, and thus the metadata of a var defined in a source file may vary. We&#8217;ll use the <code>meta</code> function to<br>
retrieve the metadata of the given value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">answer-to-everything</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 42</span>

<span class="tok-o">#</span><span class="tok-ss">&#39;answer-to-everything</span>
<span class="tok-c1">;; =&gt; #&#39;cljs.user/answer-to-everyhing</span>

<span class="tok-p">(</span><span class="tok-nb">meta </span><span class="tok-o">#</span><span class="tok-ss">&#39;answer-to-everything</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:ns cljs.user,</span>
<span class="tok-c1">;;     :name answer-to-everything,</span>
<span class="tok-c1">;;     :file &quot;NO_SOURCE_FILE&quot;,</span>
<span class="tok-c1">;;     :source &quot;answer-to-everything&quot;,</span>
<span class="tok-c1">;;     :column 6,</span>
<span class="tok-c1">;;     :end-column 26,</span>
<span class="tok-c1">;;     :line 1,</span>
<span class="tok-c1">;;     :end-line 1,</span>
<span class="tok-c1">;;     :arglists (),</span>
<span class="tok-c1">;;     :doc nil,</span>
<span class="tok-c1">;;     :test nil}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Few things to note here. First of all, <code>#'answer-to-everything</code> gives us a reference to the <code>Var</code> that holds<br>
the value of the <code>answer-to-everything</code> symbol. We see that it includes information about the namespace (<code>:ns</code>) in<br>
which it was defined, its name, file (although, since it was defined at a REPL doesn&#8217;t have a source file),<br>
source, position in the file where it was defined, argument list (which only makes sense for functions),<br>
documentation string and test function.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s take a look at a function var&#8217;s metadata:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">add</span>
  <span class="tok-s">&quot;A function that adds two numbers.&quot;</span>
  <span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nb">meta </span><span class="tok-o">#</span><span class="tok-ss">&#39;add</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:ns cljs.user,</span>
<span class="tok-c1">;;     :name add,</span>
<span class="tok-c1">;;     :file &quot;NO_SOURCE_FILE&quot;,</span>
<span class="tok-c1">;;     :source &quot;add&quot;,</span>
<span class="tok-c1">;;     :column 7,</span>
<span class="tok-c1">;;     :end-column 10,</span>
<span class="tok-c1">;;     :line 1,</span>
<span class="tok-c1">;;     :end-line 1,</span>
<span class="tok-c1">;;     :arglists (quote ([x y])),</span>
<span class="tok-c1">;;     :doc &quot;A function that adds two numbers.&quot;,</span>
<span class="tok-c1">;;     :test nil}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We see that the argument lists are stored in the <code>:arglists</code> field of the var&#8217;s metadata and its documentation<br>
in the <code>:doc</code> field. We&#8217;ll now define a test function to learn about what <code>:test</code> is used for:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.test</span> <span class="tok-ss">:as</span> <span class="tok-nv">t</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">t/deftest</span> <span class="tok-nv">i-pass</span>
  <span class="tok-p">(</span><span class="tok-nf">t/is</span> <span class="tok-nv">true</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nb">meta </span><span class="tok-o">#</span><span class="tok-ss">&#39;i-pass</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:ns cljs.user,</span>
<span class="tok-c1">;;     :name i-pass,</span>
<span class="tok-c1">;;     :file &quot;NO_SOURCE_FILE&quot;,</span>
<span class="tok-c1">;;     :source &quot;i-pass&quot;,</span>
<span class="tok-c1">;;     :column 12,</span>
<span class="tok-c1">;;     :end-column 18,</span>
<span class="tok-c1">;;     :line 1,</span>
<span class="tok-c1">;;     :end-line 1,</span>
<span class="tok-c1">;;     :arglists (),</span>
<span class="tok-c1">;;     :doc &quot;A function that adds two numbers.&quot;,</span>
<span class="tok-c1">;;     :test #&lt;function (){ ... }&gt;}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>:test</code> attribute (truncated for brevity) in the <code>i-pass</code> var&#8217;s metadata is a test function. This is used<br>
by the <code>cljs.test</code> library for discovering and running tests in the namespaces you tell it to.</p>
</div>
</div>
<div class="sect3">
<h4 id="values"><a class="link" href="#values">5.3.2. Values</a></h4>
<div class="paragraph">
<p>We learned that vars can have metadata and what kind of metadata is added to them for consumption by the<br>
compiler and the <code>cljs.test</code> testing library. Persistent collections can have metadata too, although they don&#8217;t<br>
have any by default. We can use the <code>with-meta</code> function to derive an object with the same value and type with<br>
the given metadata attached. Let&#8217;s see how:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">map-without-metadata</span> <span class="tok-p">{</span><span class="tok-ss">:language</span> <span class="tok-s">&quot;ClojureScript&quot;</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; {:language &quot;ClojureScript&quot;}</span>

<span class="tok-p">(</span><span class="tok-nb">meta </span><span class="tok-nv">map-without-metadata</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; nil</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">map-with-metadata</span> <span class="tok-p">(</span><span class="tok-nb">with-meta </span><span class="tok-nv">map-without-metadata</span>
                                  <span class="tok-p">{</span><span class="tok-ss">:answer-to-everything</span> <span class="tok-mi">42</span><span class="tok-p">}))</span>
<span class="tok-c1">;; =&gt; {:language &quot;ClojureScript&quot;}</span>

<span class="tok-p">(</span><span class="tok-nb">meta </span><span class="tok-nv">map-with-metadata</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:answer-to-everything 42}</span>

<span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">map-with-metadata</span>
   <span class="tok-nv">map-without-metadata</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nb">identical? </span><span class="tok-nv">map-with-metadata</span>
            <span class="tok-nv">map-without-metadata</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; false</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>It shouldn&#8217;t come as a surprise that metadata doesn&#8217;t affect equality between two data structures since<br>
equality in ClojureScript is based on value. Another interesting thing is that <code>with-meta</code> creates another<br>
object of the same type and value as the given one and attaches the given metadata to it.</p>
</div>
<div class="paragraph">
<p>Another open question is what happens with metadata when deriving new values from a persistent data structure.<br>
Let&#8217;s find out:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">derived-map</span> <span class="tok-p">(</span><span class="tok-nb">assoc </span><span class="tok-nv">map-with-metadata</span> <span class="tok-ss">:language</span> <span class="tok-s">&quot;Clojure&quot;</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; {:language &quot;Clojure&quot;}</span>

<span class="tok-p">(</span><span class="tok-nb">meta </span><span class="tok-nv">derived-map</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:answer-to-everything 42}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see in the example above, metadata is preserved in derived versions of persistent data structures. There<br>
are some subtleties, though. As long as the functions that derive new data structures return collections with the<br>
same type, metadata will be preserved; this is not true if the types change due to the transformation. To<br>
ilustrate this point, let&#8217;s see what happens when we derive a seq or a subvector from a vector:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">v</span> <span class="tok-p">(</span><span class="tok-nb">with-meta </span><span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]</span> <span class="tok-p">{</span><span class="tok-ss">:foo</span> <span class="tok-ss">:bar</span><span class="tok-p">}))</span>
<span class="tok-c1">;; =&gt; [0 1 2 3]</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">sv</span> <span class="tok-p">(</span><span class="tok-nb">subvec </span><span class="tok-nv">v</span> <span class="tok-mi">0</span> <span class="tok-mi">2</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; [0 1]</span>

<span class="tok-p">(</span><span class="tok-nb">meta </span><span class="tok-nv">sv</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; nil</span>

<span class="tok-p">(</span><span class="tok-nb">meta </span><span class="tok-p">(</span><span class="tok-nb">seq </span><span class="tok-nv">v</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="syntax-for-metadata"><a class="link" href="#syntax-for-metadata">5.3.3. Syntax for metadata</a></h4>
<div class="paragraph">
<p>The ClojureScript reader has syntactic support for metadata annotations, which can be written in different ways. We<br>
can prepend var definitions or collections with a caret (<code>^</code>) followed by a map for annotating it with the given<br>
metadata map:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-o">^</span><span class="tok-p">{</span><span class="tok-ss">:doc</span> <span class="tok-s">&quot;The answer to Life, Universe and Everything.&quot;</span><span class="tok-p">}</span> <span class="tok-nv">answer-to-everything</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 42</span>

<span class="tok-p">(</span><span class="tok-nb">meta </span><span class="tok-o">#</span><span class="tok-ss">&#39;answer-to-everything</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:ns cljs.user,</span>
<span class="tok-c1">;;     :name answer-to-everything,</span>
<span class="tok-c1">;;     :file &quot;NO_SOURCE_FILE&quot;,</span>
<span class="tok-c1">;;     :source &quot;answer-to-everything&quot;,</span>
<span class="tok-c1">;;     :column 6,</span>
<span class="tok-c1">;;     :end-column 26,</span>
<span class="tok-c1">;;     :line 1,</span>
<span class="tok-c1">;;     :end-line 1,</span>
<span class="tok-c1">;;     :arglists (),</span>
<span class="tok-c1">;;     :doc &quot;The answer to Life, Universe and Everything.&quot;,</span>
<span class="tok-c1">;;     :test nil}</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">map-with-metadata</span> <span class="tok-o">^</span><span class="tok-p">{</span><span class="tok-ss">:answer-to-everything</span> <span class="tok-mi">42</span><span class="tok-p">}</span> <span class="tok-p">{</span><span class="tok-ss">:language</span> <span class="tok-s">&quot;ClojureScript&quot;</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; {:language &quot;ClojureScript&quot;}</span>

<span class="tok-p">(</span><span class="tok-nb">meta </span><span class="tok-nv">map-with-metadata</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:answer-to-everything 42}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice how the metadata given in the <code>answer-to-everything</code> var definition is merged with the var metadata.</p>
</div>
<div class="paragraph">
<p>A very common use of metadata is to set certain keys to a <code>true</code> value. For example we may want to add to a<br>
var&#8217;s metadata that the variable is dynamic or a constant. For such cases, we have a shorthand notation that<br>
uses a caret followed by a keyword. Here are some examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-o">^</span><span class="tok-ss">:dynamic</span> <span class="tok-nv">*foo*</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 42</span>

<span class="tok-p">(</span><span class="tok-ss">:dynamic</span> <span class="tok-p">(</span><span class="tok-nb">meta </span><span class="tok-o">#</span><span class="tok-ss">&#39;*foo*</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-o">^</span><span class="tok-ss">:foo</span> <span class="tok-o">^</span><span class="tok-ss">:bar</span> <span class="tok-nv">answer</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 42</span>

<span class="tok-p">(</span><span class="tok-nb">select-keys </span><span class="tok-p">(</span><span class="tok-nb">meta </span><span class="tok-o">#</span><span class="tok-ss">&#39;answer</span><span class="tok-p">)</span> <span class="tok-p">[</span><span class="tok-ss">:foo</span> <span class="tok-ss">:bar</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; {:foo true, :bar true}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>There is another shorthand notation for attaching metadata. If we use a caret followed by a symbol it will<br>
be added to the metadata map under the <code>:tag</code> key. Using tags such as <code>^boolean</code> gives the ClojureScript<br>
compiler hints about the type of expressions or function return types.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-o">^</span><span class="tok-nb">boolean </span><span class="tok-nv">will-it-blend?</span> <span class="tok-p">[</span><span class="tok-nv">_</span><span class="tok-p">]</span> <span class="tok-nv">true</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;function ... &gt;</span>

<span class="tok-p">(</span><span class="tok-ss">:tag</span> <span class="tok-p">(</span><span class="tok-nb">meta </span><span class="tok-o">#</span><span class="tok-ss">&#39;will-it-blend?</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; boolean</span>

<span class="tok-p">(</span><span class="tok-nb">not </span><span class="tok-o">^</span><span class="tok-nb">boolean </span><span class="tok-p">(</span><span class="tok-nf">js/isNaN</span> <span class="tok-nv">js/NaN</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; false</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="functions-for-working-with-metadata"><a class="link" href="#functions-for-working-with-metadata">5.3.4. Functions for working with metadata</a></h4>
<div class="paragraph">
<p>We&#8217;ve learned about <code>meta</code> and <code>with-meta</code> so far but ClojureScript offers a few functions for transforming<br>
metadata. There is <code>vary-meta</code> which is similar to <code>with-meta</code> in that it derives a new object with the same<br>
type and value as the original but it doesn&#8217;t take the metadata to attach directly. Instead, it takes a function<br>
to apply to the metadata of the given object to transform it for deriving new metadata. This is how it works:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">map-with-metadata</span> <span class="tok-o">^</span><span class="tok-p">{</span><span class="tok-ss">:foo</span> <span class="tok-mi">40</span><span class="tok-p">}</span> <span class="tok-p">{</span><span class="tok-ss">:language</span> <span class="tok-s">&quot;ClojureScript&quot;</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; {:language &quot;ClojureScript&quot;}</span>

<span class="tok-p">(</span><span class="tok-nb">meta </span><span class="tok-nv">map-with-metadata</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:foo 40}</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">derived-map</span> <span class="tok-p">(</span><span class="tok-nf">vary-meta</span> <span class="tok-nv">map-with-metadata</span> <span class="tok-nv">update</span> <span class="tok-ss">:foo</span> <span class="tok-nb">+ </span><span class="tok-mi">2</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; {:language &quot;ClojureScript&quot;}</span>

<span class="tok-p">(</span><span class="tok-nb">meta </span><span class="tok-nv">derived-map</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:foo 42}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If instead we want to change the metadata of an existing var or value we can use <code>alter-meta!</code> for changing it<br>
by applying a function or <code>reset-meta!</code> for replacing it with another map:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">map-with-metadata</span> <span class="tok-o">^</span><span class="tok-p">{</span><span class="tok-ss">:foo</span> <span class="tok-mi">40</span><span class="tok-p">}</span> <span class="tok-p">{</span><span class="tok-ss">:language</span> <span class="tok-s">&quot;ClojureScript&quot;</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; {:language &quot;ClojureScript&quot;}</span>

<span class="tok-p">(</span><span class="tok-nb">meta </span><span class="tok-nv">map-with-metadata</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:foo 40}</span>

<span class="tok-p">(</span><span class="tok-nf">alter-meta!</span> <span class="tok-nv">map-with-metadata</span> <span class="tok-nv">update</span> <span class="tok-ss">:foo</span> <span class="tok-nb">+ </span><span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:foo 42}</span>

<span class="tok-p">(</span><span class="tok-nb">meta </span><span class="tok-nv">map-with-metadata</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:foo 42}</span>

<span class="tok-p">(</span><span class="tok-nf">reset-meta!</span> <span class="tok-nv">map-with-metadata</span> <span class="tok-p">{</span><span class="tok-ss">:foo</span> <span class="tok-mi">40</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; {:foo 40}</span>

<span class="tok-p">(</span><span class="tok-nb">meta </span><span class="tok-nv">map-with-metadata</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:foo 40}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="macros"><a class="link" href="#macros">5.4. Macros</a></h3>
<div class="paragraph">
<p><a id="macros-section"></a></p>
</div>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect2">
<h3 id="core-protocols"><a class="link" href="#core-protocols">5.5. Core protocols</a></h3>
<div class="paragraph">
<p><a id="core-protocols"></a></p>
</div>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect2">
<h3 id="the-reader"><a class="link" href="#the-reader">5.6. The Reader</a></h3>
<div class="paragraph">
<p><a id="the-reader"></a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="appendix"><a class="link" href="#appendix">6. Appendix</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="appendix-a-interactive-development-with-figwheel"><a class="link" href="#appendix-a-interactive-development-with-figwheel">6.1. Appendix A: Interactive development with Figwheel</a></h3>
<div class="sect3">
<h4 id="introduction-3"><a class="link" href="#introduction-3">6.1.1. Introduction</a></h4>
<div class="paragraph">
<p>In this project, we will <strong>not</strong> do “Hello World”&#8212; that has been done to death.<br>
Instead, this project will be a web page that asks you for your age in years and<br>
tells you how many days that is, using an approximation of 365 days per year.</p>
</div>
<div class="paragraph">
<p>And for it, we will use the figwheel leiningen plugin. That plugin enables a fully<br>
interactive, repl based and autoreloading experience.</p>
</div>
</div>
<div class="sect3">
<h4 id="first-steps-2"><a class="link" href="#first-steps-2">6.1.2. First steps</a></h4>
<div class="paragraph">
<p>In this project, we will use the <em>figwheel</em> template to build the project structure.<br>
Let’s call the project <code>age</code> and create it by typing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nv">$ </span>lein new figwheel age
Retrieving figwheel/lein-template/0.3.5/lein-template-0.3.5.pom from clojars
Retrieving figwheel/lein-template/0.3.5/lein-template-0.3.5.jar from clojars
Generating fresh <span class="tok-s1">&#39;lein new&#39;</span> figwheel project.
<span class="tok-nv">$ </span><span class="tok-nb">cd </span>age <span class="tok-c"># move into newly created project directory</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The project has the following structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>age
├── .gitignore
├── project.clj
├── README.md
├── resources
│   └── public
│       ├── css
│       │   └── style.css
│       └── index.html
└── src
    └── age
        └── core.cljs</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>project.clj</code> file contains information that Leiningen uses to download<br>
dependencies and build the project. For now, just trust that everything in that<br>
file is exactly as it should be.</p>
</div>
<div class="paragraph">
<p>Open the <code>index.html</code> file and add the <code>&lt;meta&gt;</code> element to the head of the document,<br>
and modify the body as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="html"><span class="tok-cp">&lt;!DOCTYPE html&gt;</span>
<span class="tok-nt">&lt;html&gt;</span>
  <span class="tok-nt">&lt;head&gt;</span>
    <span class="tok-nt">&lt;link</span> <span class="tok-na">href=</span><span class="tok-s">&quot;css/style.css&quot;</span> <span class="tok-na">rel=</span><span class="tok-s">&quot;stylesheet&quot;</span> <span class="tok-na">type=</span><span class="tok-s">&quot;text/css&quot;</span><span class="tok-nt">&gt;</span>
    <span class="tok-nt">&lt;meta</span> <span class="tok-na">http-equiv=</span><span class="tok-s">&quot;Content-Type&quot;</span> <span class="tok-na">content=</span><span class="tok-s">&quot;text/html;charset=utf-8&quot;</span> <span class="tok-nt">/&gt;</span>
  <span class="tok-nt">&lt;/head&gt;</span>
  <span class="tok-nt">&lt;body&gt;</span>
    <span class="tok-nt">&lt;div</span> <span class="tok-na">id=</span><span class="tok-s">&quot;app&quot;</span><span class="tok-nt">&gt;</span>
      <span class="tok-nt">&lt;h1&gt;</span>Age in Days<span class="tok-nt">&lt;/h1&gt;</span>
      <span class="tok-nt">&lt;p&gt;</span>Enter your age in years:
        <span class="tok-nt">&lt;input</span> <span class="tok-na">type=</span><span class="tok-s">&quot;text&quot;</span> <span class="tok-na">size=</span><span class="tok-s">&quot;5&quot;</span> <span class="tok-na">id=</span><span class="tok-s">&quot;years&quot;</span> <span class="tok-nt">/&gt;&lt;/p&gt;</span>
      <span class="tok-nt">&lt;p</span> <span class="tok-na">id=</span><span class="tok-s">&quot;feedback&quot;</span><span class="tok-nt">&gt;&lt;/p&gt;</span>
    <span class="tok-nt">&lt;/div&gt;</span>
    <span class="tok-nt">&lt;script </span><span class="tok-na">src=</span><span class="tok-s">&quot;js/compiled/age.js&quot;</span> <span class="tok-na">type=</span><span class="tok-s">&quot;text/javascript&quot;</span><span class="tok-nt">&gt;&lt;/script&gt;</span>
  <span class="tok-nt">&lt;/body&gt;</span>
<span class="tok-nt">&lt;/html&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>core.cljs</code> file is where all the action takes place. For now, leave it exactly<br>
as it is, and start the figwheel environment, which will load a large number of<br>
dependencies and start a server.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nv">$ </span>lein fighwheel
<span class="tok-c"># much output</span>
Prompt will show when figwheel connects to your application</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you are using Linux or Mac OS X, type the command as <code>rlwrap lein figwheel</code>.<br>
In your browser, go to URL <code><a href="http://localhost:3449" class="bare">http://localhost:3449</a></code>, and you will see something<br>
like the following screenshot if you open up the web console.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/localhost1.png" alt="Screenshot of web page and console">
</div>
</div>
<div class="paragraph">
<p>The terminal will then give you a REPL prompt:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nv">$ </span>rlwrap lein figwheel
To quit, <span class="tok-nb">type</span>: :cljs/quit
cljs.user<span class="tok-o">=</span>&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>For now, do what it says in the <code>core.cljs</code> file&#8201;&#8212;&#8201;change the <code>(println&#8230;&#8203;)</code> and<br>
then save the file. When you do so, you will see the change reflected immediately<br>
in the browser.</p>
</div>
<div class="paragraph">
<p>Then make an error by adding an extra closing parenthesis to the <code>println</code>. When<br>
you save the file, will see a compile error in the browser window.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/localhost2.png" alt="Screenshot of browser error message">
</div>
</div>
</div>
<div class="sect3">
<h4 id="interacting-with-javascript"><a class="link" href="#interacting-with-javascript">6.1.3. Interacting with JavaScript</a></h4>
<div class="paragraph">
<p>In the REPL window, type the following to invoke JavaScript’s <code>window.alert()</code><br>
function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">.alert</span> <span class="tok-nv">js/window</span> <span class="tok-s">&quot;It works!&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The general format for invoking a JavaScript function from ClojureScript is to<br>
give the function name (preceded by a dot), the object that “owns” the function,<br>
and any parameters to that function. You should see an alert appear in your<br>
browser winodw; when you dismiss the alert, the REPL will print <code>nil</code> and give<br>
you another prompt. You can also do it this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">js/alert</span> <span class="tok-s">&quot;It works!&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>However, the first version always works, so, for consistency, we will use that<br>
notation throughout. You can create objects by using their class name followed by<br>
a dot, and you can call methods on any JavaScript objects:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">d</span> <span class="tok-p">(</span><span class="tok-nf">js/Date.</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #inst &quot;2015-06-30T01:38:21.764-00:00&quot;</span>

<span class="tok-p">(</span><span class="tok-nf">.getFullYear</span> <span class="tok-nv">d</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 2015</span>

<span class="tok-p">(</span><span class="tok-nf">.toUpperCase</span> <span class="tok-s">&quot;abc&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;ABC&quot;</span>

<span class="tok-p">(</span><span class="tok-nf">.getElementById</span> <span class="tok-nv">js/document</span> <span class="tok-s">&quot;years&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;[object HTMLInputElement]&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>From that last example, you can see where we’re going. To retrieve an object’s<br>
property, use a <code>.-</code> before the property name. In the browser window, type a number<br>
into the input field (in the example, we typed <code>24</code>), then do this in the REPL.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-c1">;; for convenience define a variable</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">year-field</span> <span class="tok-p">(</span><span class="tok-nf">.getElementById</span> <span class="tok-nv">js/document</span> <span class="tok-s">&quot;years&quot;</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;[object HTMLInputElement]&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">.-value</span> <span class="tok-nv">year-field</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;24&quot;</span>

<span class="tok-p">(</span><span class="tok-nf">set!</span> <span class="tok-p">(</span><span class="tok-nf">.-value</span> <span class="tok-nv">year-field</span><span class="tok-p">)</span> <span class="tok-s">&quot;25&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;25&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This works, but it is little more than direct translation of JavaScript to<br>
ClojureScript. The next step is to add event handling to the button. Event handling<br>
is loaded with all sorts of cross-platform compatibility issues, so we’d like one<br>
step up from plain ClojureScript.</p>
</div>
<div class="paragraph">
<p>The solution is the Google Closure library. To use it, you have to modify the<br>
<code>:require</code> clause at the beginning of <code>core.cljs</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-o">^</span><span class="tok-ss">:figwheel-always</span> <span class="tok-nv">age.core</span>
  <span class="tok-p">(</span><span class="tok-ss">:require</span> <span class="tok-p">[</span><span class="tok-nv">goog.dom</span> <span class="tok-ss">:as</span> <span class="tok-nv">dom</span><span class="tok-p">]</span>
            <span class="tok-p">[</span><span class="tok-nv">goog.events</span> <span class="tok-ss">:as</span> <span class="tok-nv">events</span><span class="tok-p">]))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Getting an element and setting its value is slightly easier. Do this in the REPL<br>
and see the results in the browser window.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">in-ns </span><span class="tok-ss">&#39;age.core</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">y</span> <span class="tok-p">(</span><span class="tok-nf">dom/getElement</span> <span class="tok-s">&quot;years&quot;</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;[object HTMLInputElement]&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">set!</span> <span class="tok-p">(</span><span class="tok-nf">.-value</span> <span class="tok-nv">y</span><span class="tok-p">)</span> <span class="tok-s">&quot;26&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; &quot;26&quot;</span>

<span class="tok-p">(</span><span class="tok-nf">dom/setTextContent</span> <span class="tok-p">(</span><span class="tok-nf">dom/getElement</span> <span class="tok-s">&quot;feedback&quot;</span><span class="tok-p">)</span> <span class="tok-s">&quot;This works!&quot;</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>To add an event, you define a function that takes a single argument (the event to<br>
be handled), and then tell the appropriate HTML element to listen for it. the<br>
<code>events/listen</code> function takes three arguments: the element to listen to, the<br>
event to listen for, and the function that will handle the event.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">testing</span> <span class="tok-p">[</span><span class="tok-nv">evt</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nf">js/alert</span> <span class="tok-s">&quot;Responding to click&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">events/listen</span> <span class="tok-p">(</span><span class="tok-nf">dom/getElement</span> <span class="tok-s">&quot;calculate&quot;</span><span class="tok-p">)</span> <span class="tok-s">&quot;click&quot;</span> <span class="tok-nv">testing</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;[object Object]&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>After doing this, the browser should respond to a click on the button.<br>
If you would like to remove the listener, use <code>unlisten</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">events/unlisten</span> <span class="tok-p">(</span><span class="tok-nf">dom/getElement</span> <span class="tok-s">&quot;calculate&quot;</span><span class="tok-p">)</span> <span class="tok-s">&quot;click&quot;</span> <span class="tok-nv">testing</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, put that all together in the <code>core.cljs</code> file as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-o">^</span><span class="tok-ss">:figwheel-always</span> <span class="tok-nv">age.core</span>
  <span class="tok-p">(</span><span class="tok-ss">:require</span> <span class="tok-p">[</span><span class="tok-nv">goog.dom</span> <span class="tok-ss">:as</span> <span class="tok-nv">dom</span><span class="tok-p">]</span>
            <span class="tok-p">[</span><span class="tok-nv">goog.events</span> <span class="tok-ss">:as</span> <span class="tok-nv">events</span><span class="tok-p">]))</span>

<span class="tok-p">(</span><span class="tok-nf">enable-console-print!</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">calculate</span>
  <span class="tok-p">[</span><span class="tok-nv">event</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">years</span> <span class="tok-p">(</span><span class="tok-nf">.parseInt</span> <span class="tok-nv">js/window</span> <span class="tok-p">(</span><span class="tok-nf">.-value</span> <span class="tok-p">(</span><span class="tok-nf">dom/getElement</span> <span class="tok-s">&quot;years&quot;</span><span class="tok-p">)))</span>
        <span class="tok-nv">days</span> <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-mi">365</span> <span class="tok-nv">years</span><span class="tok-p">)]</span>
    <span class="tok-p">(</span><span class="tok-nf">dom/setTextContent</span> <span class="tok-p">(</span><span class="tok-nf">dom/getElement</span> <span class="tok-s">&quot;feedback&quot;</span><span class="tok-p">)</span>
                        <span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-s">&quot;That is &quot;</span> <span class="tok-nv">days</span> <span class="tok-s">&quot; days old.&quot;</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">on-js-reload</span> <span class="tok-p">[])</span>

<span class="tok-p">(</span><span class="tok-nf">events/listen</span> <span class="tok-p">(</span><span class="tok-nf">dom/getElement</span> <span class="tok-s">&quot;calculate&quot;</span><span class="tok-p">)</span> <span class="tok-s">&quot;click&quot;</span> <span class="tok-nv">calculate</span><span class="tok-p">)</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="appendix-b-csp-and-core-async"><a class="link" href="#appendix-b-csp-and-core-async">6.2. Appendix B: CSP and core.async</a></h3>
<div class="paragraph">
<p>CSP stands for Communicating Sequential Processes, which is a formalism for describing<br>
concurrent systems pioneered by C. A. R. Hoare in 1978. It is a concurrency model based<br>
on message passing and synchronization through channels. An in-depth look at the<br>
theoretical model behind CSP is out of the scope of this book, instead we&#8217;ll focus on<br>
presenting the concurrency primitives that <code>core.async</code> offers.</p>
</div>
<div class="paragraph">
<p><code>core.async</code> is not part of ClojureScript core but it&#8217;s implemented as a library. Even<br>
though is not part of the core language it&#8217;s widely used and many libraries build on top<br>
of its primitives so we think is worth covering in the book. It&#8217;s also a good example of<br>
the syntactic abstractions that can be achieved transforming code with ClojureScript<br>
macros, so let&#8217;s jump right in. You&#8217;ll need to have <code>core.async</code> installed to run the<br>
examples presented in this section.</p>
</div>
<div class="sect3">
<h4 id="channels"><a class="link" href="#channels">6.2.1. Channels</a></h4>
<div class="paragraph">
<p>Channels are like conveyor belts, we can put and take a single value at a time from them.<br>
They can have multiple readers and writers and are the message-passing primitive of<br>
<code>core.async</code>. Let&#8217;s create a channel do some operations on it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">put!</span> <span class="tok-nv">take!</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-nf">enable-console-print!</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">ch</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Got a value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; nil</span>

<span class="tok-c1">;; there is a now a pending take operation, let&#39;s put something on the channel</span>

<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
<span class="tok-c1">;; Got a value: 42</span>
<span class="tok-c1">;; =&gt; 42</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example we created a channel (<code>ch</code>) using the <code>chan</code> constructor. After that<br>
we performed a take operation on the channel, providing a callback that will be invoked<br>
when the take operation succeeds. After using <code>put!</code> to put a value on the channel the<br>
take operation completed and the <code>"Got a value: 42"</code> string was printed. Note that <code>put!</code><br>
returned the value that was just put to the channel.</p>
</div>
<div class="paragraph">
<p>The <code>put!</code> function also accepts a callback like <code>take!</code> does but we didn&#8217;t provide any in<br>
the last example. For puts the callback will be called whenever the value we provided has<br>
been taken. Puts and takes can happen in any order, let&#8217;s do a few puts followed by<br>
takes to illustrate the point:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">put!</span> <span class="tok-nv">take!</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-mi">42</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Just put 42&quot;</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; true</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-mi">43</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Just put 43&quot;</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">ch</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; Got 42</span>
<span class="tok-c1">;; Just put 42</span>
<span class="tok-c1">;; =&gt; nil</span>

<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">ch</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; Got 43</span>
<span class="tok-c1">;; Just put 43</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>You may be asking yourself why the <code>put!</code> operations return <code>true</code>. It signals that the<br>
put operation could be performed, even though the value hasn&#8217;t yet been taken. Channels<br>
can be closed, which will cause the put operations to not succeed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">put!</span> <span class="tok-nv">close!</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">close!</span> <span class="tok-nv">ch</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; nil</span>

<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; false</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The above example was the simplest possible situation but what happens with pending<br>
operations when a channel is closed? Let&#8217;s do a few takes and close the channel and see<br>
what happens:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">put!</span> <span class="tok-nv">take!</span> <span class="tok-nv">close!</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">ch</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Got value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; nil</span>
<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">ch</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Got value:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; nil</span>

<span class="tok-p">(</span><span class="tok-nf">close!</span> <span class="tok-nv">ch</span><span class="tok-p">)</span>
<span class="tok-c1">;; Got value: nil</span>
<span class="tok-c1">;; Got value: nil</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We see that if the channel is closed all the <code>take!</code> operations receive a <code>nil</code> value.<br>
<code>nil</code> in channels is a sentinel value that signals to takers that the channel has been<br>
closed. Because of that, putting a <code>nil</code> value on a channel is not allowed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">put!</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-nv">nil</span><span class="tok-p">)</span>
<span class="tok-c1">;; Error: Assert failed: Can&#39;t put nil in on a channel</span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="buffers"><a class="link" href="#buffers">Buffers</a></h5>
<div class="paragraph">
<p>We&#8217;ve seen that pending take and put operations are enqueued in a channel but, what<br>
happens when there are many pending take or put operations? Let&#8217;s find out by hammering a<br>
channel with many puts and takes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">put!</span> <span class="tok-nv">take!</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nb">dotimes </span><span class="tok-p">[</span><span class="tok-nv">n</span> <span class="tok-mi">1025</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-nv">n</span><span class="tok-p">))</span>
<span class="tok-c1">;; Error: Assert failed: No more than 1024 pending puts are allowed on a single channel.</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nb">dotimes </span><span class="tok-p">[</span><span class="tok-nv">n</span> <span class="tok-mi">1025</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">ch</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">%</span><span class="tok-p">)))</span>
<span class="tok-c1">;; Error: Assert failed: No more than 1024 pending takes are allowed on a single channel.</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As the example above shows there&#8217;s a limit of pending puts or takes on a channel, it&#8217;s<br>
currently 1024 but that is an implementation detail that may change. Note that there can&#8217;t<br>
be both pending puts and pending takes on a channel since puts will immediately succeed<br>
if there are pending takes and viceversa.</p>
</div>
<div class="paragraph">
<p>Channels support buffering of put operations. If we create a channel with a buffer the put<br>
operations will succeed immediately if there&#8217;s room in the buffer and be enqueued<br>
otherwise. Let&#8217;s illustrate the point creating a channel with a buffer of one element. The<br>
<code>chan</code> constructors accepts a number as its first argument which will cause it to have<br>
a buffer with the given size:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">put!</span> <span class="tok-nv">take!</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span> <span class="tok-mi">1</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-mi">42</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Put succeeded!&quot;</span><span class="tok-p">))</span>
<span class="tok-c1">;; Put succeeded!</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nb">dotimes </span><span class="tok-p">[</span><span class="tok-nv">n</span> <span class="tok-mi">1024</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-nv">n</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; nil</span>

<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
<span class="tok-c1">;; Error: Assert failed: No more than 1024 pending puts are allowed on a single channel.</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>What happened in the example above? We created a channel with a buffer of size 1 and<br>
performed a put operation on it that succeeded immediately because the value was buffered.<br>
After that we did another 1024 puts to fill the pending put queue and, when trying to put<br>
one value more the channel complained about not being able to enqueue more puts.</p>
</div>
<div class="paragraph">
<p>Now that we know about how channels work and what are buffers used for let&#8217;s explore the<br>
different buffers that <code>core.async</code> implements. Different buffers have different policies<br>
and it&#8217;s interesting to know all of them to know when to use what. Channels are unbuffered<br>
by default.</p>
</div>
<div class="sect5">
<h6 id="fixed"><a class="link" href="#fixed">Fixed</a></h6>
<div class="paragraph">
<p>The fixed size buffer is the one that is created when we give the <code>chan</code> constructor a<br>
number and it will have the size specified by the given number. It is the simplest<br>
possible buffer: when full, puts will be enqueued.</p>
</div>
<div class="paragraph">
<p>The <code>chan</code> constructor accepts either a number or a buffer as its first argument. The two<br>
channels created in the following example both use a fixed buffer of size 32:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">buffer</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">a-ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span> <span class="tok-mi">32</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">another-ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span> <span class="tok-p">(</span><span class="tok-nf">buffer</span> <span class="tok-mi">32</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="dropping"><a class="link" href="#dropping">Dropping</a></h6>
<div class="paragraph">
<p>The fixed buffer allows put operations to be enqueued. However, as we saw before, puts<br>
are still queued when the fixed buffer is full. If we wan&#8217;t to discard the put operations<br>
that happen when the buffer is full we can use a dropping buffer.</p>
</div>
<div class="paragraph">
<p>Dropping buffers have a fixed size and, when they are full puts will complete but their<br>
value will be discarded. Let&#8217;s illustrate the point with an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">dropping-buffer</span> <span class="tok-nv">put!</span> <span class="tok-nv">take!</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span> <span class="tok-p">(</span><span class="tok-nf">dropping-buffer</span> <span class="tok-mi">2</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-mi">40</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-mi">41</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">ch</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; Got 40</span>
<span class="tok-c1">;; =&gt; nil</span>
<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">ch</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; Got 41</span>
<span class="tok-c1">;; =&gt; nil</span>
<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">ch</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We performed three put operations and the three of them succeded but, since the dropping<br>
buffer of the channel has size 2, only the first two values were delivered to the takers.<br>
As you can observe the third take is enqueued since there is no value available, the third<br>
put&#8217;s value (42) was discarded.</p>
</div>
</div>
<div class="sect5">
<h6 id="sliding"><a class="link" href="#sliding">Sliding</a></h6>
<div class="paragraph">
<p>The sliding buffer has the opposite policy than the dropping buffer. When full puts will<br>
complete and the oldest value will be discarded in favor of the new one. The sliding<br>
buffer is useful when we are interested in processing the last puts only and we can afford<br>
discarding old values.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">sliding-buffer</span> <span class="tok-nv">put!</span> <span class="tok-nv">take!</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span> <span class="tok-p">(</span><span class="tok-nf">sliding-buffer</span> <span class="tok-mi">2</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-mi">40</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-mi">41</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">ch</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; Got 41</span>
<span class="tok-c1">;; =&gt; nil</span>
<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">ch</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; Got 42</span>
<span class="tok-c1">;; =&gt; nil</span>
<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">ch</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We performed three put operations and the three of them succeded but, since the sliding<br>
buffer of the channel has size 2, only the last two values were delivered to the takers.<br>
As you can observe the third take is enqueued since there is no value available since the<br>
first put&#8217;s value was discarded.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="transducers-2"><a class="link" href="#transducers-2">Transducers</a></h5>
<div class="paragraph">
<p>As mentioned in the section about transducers, putting values in a channel can be thought<br>
as a transducible process. This means that we can create channels and hand them a<br>
transducer, giving us the ability to transform the input values before being put in the<br>
channel.</p>
</div>
<div class="paragraph">
<p>If we want to use a transducer with a channel we must supply a buffer since the reducing<br>
function that will be modified by the transducer will be the buffer&#8217;s add function.<br>
A buffer&#8217;s add function is a reducing function since it takes a buffer and an input and<br>
returns a buffer with such input incorporated.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">put!</span> <span class="tok-nv">take!</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span> <span class="tok-mi">1</span> <span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-nv">inc</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-mi">41</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">ch</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; Got 42</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>You may be wondering what happens to a channel when the reducing function returns a<br>
reduced value. It turns out that the notion of termination for channels is being closed,<br>
so channels will be closed when a reduced value is encountered:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">put!</span> <span class="tok-nv">take!</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span> <span class="tok-mi">1</span> <span class="tok-p">(</span><span class="tok-nb">take </span><span class="tok-mi">2</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">ch</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; nil</span>
<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">ch</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; nil</span>
<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">ch</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; nil</span>

<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-mi">41</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
<span class="tok-c1">;; Got 41</span>
<span class="tok-c1">;; =&gt; true</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-mi">43</span><span class="tok-p">)</span>
<span class="tok-c1">;; Got 42</span>
<span class="tok-c1">;; Got nil</span>
<span class="tok-c1">;; =&gt; false</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We used the <code>take</code> stateful transducer to allow maximum 2 puts into the channel. We then<br>
performed three take operations on the channel and we expect only two to receive a value.<br>
As you can see in the above example the third take got the sentinel <code>nil</code> value which<br>
indicates that the channel was closed. Also, the third put operation returned <code>false</code><br>
indicating that it didn&#8217;t take place.</p>
</div>
</div>
<div class="sect4">
<h5 id="handling-exceptions"><a class="link" href="#handling-exceptions">Handling exceptions</a></h5>
<div class="paragraph">
<p>If adding a value to a buffer throws an exception <code>core.async</code> the operation will fail and<br>
the exception will be logged to the console. However, channel constructors accept a third<br>
argument: a function for handling exceptions.</p>
</div>
<div class="paragraph">
<p>When creating a channel with an exception handler it will be called with the exception<br>
whenever an exception occurs. If the handler returns <code>nil</code> the operation will fail<br>
silently and if it returns another value the add operation will be retried with such<br>
value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">put!</span> <span class="tok-nv">take!</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-nf">enable-console-print!</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">exception-xform</span>
  <span class="tok-p">[</span><span class="tok-nv">rfn</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">acc</span> <span class="tok-nv">input</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nf">throw</span> <span class="tok-p">(</span><span class="tok-nf">js/Error.</span> <span class="tok-s">&quot;I fail!&quot;</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">handle-exception</span>
  <span class="tok-p">[</span><span class="tok-nv">ex</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Exception message:&quot;</span> <span class="tok-p">(</span><span class="tok-nf">.-message</span> <span class="tok-nv">ex</span><span class="tok-p">))</span>
  <span class="tok-mi">42</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span> <span class="tok-mi">1</span> <span class="tok-nv">exception-xform</span> <span class="tok-nv">handle-exception</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
<span class="tok-c1">;; Exception message: I fail!</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nf">take!</span> <span class="tok-nv">ch</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Got:&quot;</span> <span class="tok-nv">%</span><span class="tok-p">))</span>
<span class="tok-c1">;; Got: 42</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="processes"><a class="link" href="#processes">6.2.2. Processes</a></h4>
<div class="paragraph">
<p>We learned all about channels but there is still a missing piece in the puzzle: processes.<br>
Processes are pieces of logic that run independently and use channels for communication<br>
and coordination. Puts and takes inside a process will stop the process until the<br>
operation completes. Stopping a process doesn&#8217;t block the only thread we have in the<br>
environments where ClojureScript runs. Instead, it will be resumed at a later time when<br>
the operation is waiting for has been performed.</p>
</div>
<div class="paragraph">
<p>Processes are launched using the <code>go</code> macro and puts and takes use the <code>&lt;!</code> and <code>&gt;!</code><br>
placeholders. The <code>go</code> macro rewrites your code to use callbacks but inside <code>go</code><br>
everything looks like synchronous code, which makes understanding it straightforward:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">&lt;!</span> <span class="tok-nv">&gt;!</span><span class="tok-p">]])</span>
<span class="tok-p">(</span><span class="tok-nf">require-macros</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async.macros</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">go</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-nf">enable-console-print!</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">go</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Gonna take from channel&quot;</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Got&quot;</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">ch</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">go</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:b</span><span class="tok-p">]</span> <span class="tok-s">&quot;Gonna put on channel&quot;</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">&gt;!</span> <span class="tok-nv">ch</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:b</span><span class="tok-p">]</span> <span class="tok-s">&quot;Just put 42&quot;</span><span class="tok-p">))</span>

<span class="tok-c1">;; [:a] Gonna take from channel</span>
<span class="tok-c1">;; [:b] Gonna put on channel</span>
<span class="tok-c1">;; [:b] Just put 42</span>
<span class="tok-c1">;; [:a] Got 42</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example we are launching a process with <code>go</code> that takes a value from <code>ch</code> and<br>
prints it to the console. Since the value isn&#8217;t immediately available it will park until<br>
it can resume. After that we launch another process that puts a value on the channel.<br>
Since there is a pending take the put operation succeeds and the value is delivered to<br>
the first process, then both processes terminate.</p>
</div>
<div class="paragraph">
<p>Both <code>go</code> blocks run independently and, even though they are executed asynchronously, they<br>
look like they synchronous code. The above go blocks are fairly simple but being able to<br>
write concurrent processes that coordinate via channels is a very powerful tool for<br>
implementing complex asynchronous workflows. Channels also offer a great decoupling of<br>
producers and consumers.</p>
</div>
<div class="paragraph">
<p>Processes can wait for an arbitrary amount of time too, there is a <code>timeout</code> function<br>
that return a channel that will be closed after the given amount of miliseconds. Combining<br>
a timeout channel with a take operation inside a go block gives us the ability to sleep:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">&lt;!</span> <span class="tok-nv">timeout</span><span class="tok-p">]])</span>
<span class="tok-p">(</span><span class="tok-nf">require-macros</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async.macros</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">go</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-nf">enable-console-print!</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">seconds</span>
  <span class="tok-p">[]</span>
  <span class="tok-p">(</span><span class="tok-nf">.getSeconds</span> <span class="tok-p">(</span><span class="tok-nf">js/Date.</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Launching go block&quot;</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-nf">go</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Gonna take a nap&quot;</span> <span class="tok-p">(</span><span class="tok-nf">seconds</span><span class="tok-p">))</span>
  <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-p">(</span><span class="tok-nf">timeout</span> <span class="tok-mi">1000</span><span class="tok-p">))</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;I slept one second, bye!&quot;</span> <span class="tok-p">(</span><span class="tok-nf">seconds</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Block launched&quot;</span><span class="tok-p">)</span>

<span class="tok-c1">;; Launching go block</span>
<span class="tok-c1">;; Block launched</span>
<span class="tok-c1">;; [:a] Gonna take a nap 9</span>
<span class="tok-c1">;; [:a] I slept one second, bye! 10</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As we can see in the messages printed, the process does nothing for one second when it<br>
blocks in the take operation of the timeout channel. The program continues and after one<br>
second the process resumes and terminates.</p>
</div>
<div class="sect4">
<h5 id="choice"><a class="link" href="#choice">Choice</a></h5>
<div class="paragraph">
<p>Apart from putting and taking one value at a time inside a go block we can also make a<br>
non-deterministic choice on multiple channel operations using <code>alts!</code>. <code>alts!</code> is given<br>
a series of channel put or take operations (note that we can also try to put and take in<br>
a channel at the same time) and only performs one as soon as is ready; if multiple<br>
operations can be performed when calling <code>alts!</code> it will do a pseudo random choice by<br>
default.</p>
</div>
<div class="paragraph">
<p>We can easily try an operation on a channel and cancel it after a certain amount of time<br>
combining the <code>timeout</code> function and <code>alts!</code>. Let&#8217;s see how:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">&lt;!</span> <span class="tok-nv">timeout</span> <span class="tok-nv">alts!</span><span class="tok-p">]])</span>
<span class="tok-p">(</span><span class="tok-nf">require-macros</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async.macros</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">go</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-nf">enable-console-print!</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">go</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Gonna take a nap&quot;</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-p">(</span><span class="tok-nf">timeout</span> <span class="tok-mi">1000</span><span class="tok-p">))</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;I slept one second, trying to put a value on channel&quot;</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">&gt;!</span> <span class="tok-nv">ch</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;I&#39;m done!&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">go</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:b</span><span class="tok-p">]</span> <span class="tok-s">&quot;Gonna try taking from channel&quot;</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">cancel</span> <span class="tok-p">(</span><span class="tok-nf">timeout</span> <span class="tok-mi">300</span><span class="tok-p">)</span>
        <span class="tok-p">[</span><span class="tok-nv">value</span> <span class="tok-nv">ch</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nf">alts!</span> <span class="tok-p">[</span><span class="tok-nv">ch</span> <span class="tok-nv">cancel</span><span class="tok-p">])]</span>
    <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">ch</span> <span class="tok-nv">cancel</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:b</span><span class="tok-p">]</span> <span class="tok-s">&quot;Too slow, take from channel cancelled&quot;</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:b</span><span class="tok-p">]</span> <span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">value</span><span class="tok-p">))))</span>

<span class="tok-c1">;; [:a] Gonna take a nap</span>
<span class="tok-c1">;; [:b] Gonna try taking from channel</span>
<span class="tok-c1">;; [:b] Too slow, take from channel cancelled</span>
<span class="tok-c1">;; [:a] I slept one second, trying to put a value on channel</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example above we launched a go block that, after waiting for a second, puts a value<br>
in the <code>ch</code> channel. The other go block creates a <code>cancel</code> channel, which will be closed<br>
after 300 miliseconds. After that, it tries to read from both <code>ch</code> and <code>cancel</code> at the same<br>
time using <code>alts!</code>, which will succeed whenever it can take a value from either of those<br>
channels. Since <code>cancel</code> is closed after 300 miliseconds, <code>alts!</code> will succeed since takes<br>
from closed channel return the <code>nil</code> sentinel. Note that <code>alts!</code> returns a two-element<br>
vector with the returned value of the operation and the channel where it was performed.<br>
This is why we are able to detect whether the read operation was performed in the <code>cancel</code><br>
channel or in <code>ch</code>. I suggest you copy this example and set the first process timeout to<br>
100 miliseconds to see how the read operation on <code>ch</code> succeeds.</p>
</div>
<div class="paragraph">
<p>We&#8217;ve learned how to choose between read operations so let&#8217;s look at how to express a<br>
conditional write operation in <code>alts!</code>. Since we need to provide the channel and a value<br>
to try to put on it, we&#8217;ll use a two element vector with the channel and the value for<br>
representing write operations. Let&#8217;s see an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">&lt;!</span> <span class="tok-nv">alts!</span><span class="tok-p">]])</span>
<span class="tok-p">(</span><span class="tok-nf">require-macros</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async.macros</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">go</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-nf">enable-console-print!</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">a-ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">another-ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">go</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Take a value from `a-ch`&quot;</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Got&quot;</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">a-ch</span><span class="tok-p">))</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;I&#39;m done!&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">go</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:b</span><span class="tok-p">]</span> <span class="tok-s">&quot;Take a value from `another-ch`&quot;</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Got&quot;</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">another-ch</span><span class="tok-p">))</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:b</span><span class="tok-p">]</span> <span class="tok-s">&quot;I&#39;m done!&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">go</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:c</span><span class="tok-p">]</span> <span class="tok-s">&quot;Gonna try putting in both channels simultaneously&quot;</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[[</span><span class="tok-nv">value</span> <span class="tok-nv">ch</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nf">alts!</span> <span class="tok-p">[[</span><span class="tok-nv">a-ch</span> <span class="tok-mi">42</span><span class="tok-p">]</span>
                           <span class="tok-p">[</span><span class="tok-nv">another-ch</span> <span class="tok-mi">99</span><span class="tok-p">]])]</span>
    <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">ch</span> <span class="tok-nv">a-ch</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:c</span><span class="tok-p">]</span> <span class="tok-s">&quot;Put a value in `a-ch`&quot;</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:c</span><span class="tok-p">]</span> <span class="tok-s">&quot;Put a value in `another-ch`&quot;</span><span class="tok-p">))))</span>

<span class="tok-c1">;; [:a] Take a value from `a-ch`</span>
<span class="tok-c1">;; [:b] Take a value from `another-ch`</span>
<span class="tok-c1">;; [:c] Gonna try putting in both channels simultaneously</span>
<span class="tok-c1">;; [:c] Put a value in `a-ch`</span>
<span class="tok-c1">;; [:a] Got 42</span>
<span class="tok-c1">;; [:a] I&#39;m done!</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>When running the above example only the put operation on the <code>a-ch</code> channel has succeeded.<br>
Since both channels are ready to take a value when the <code>alts!</code> occurs you may get<br>
different results when running this code.</p>
</div>
</div>
<div class="sect4">
<h5 id="priority"><a class="link" href="#priority">Priority</a></h5>
<div class="paragraph">
<p><code>alts!</code> default is to make a non-deterministic choice whenever several operations are<br>
ready to be performed. We can instead give priority to the operations passing the<br>
<code>:priority</code> option to <code>alts!</code>. Whenever <code>:priority</code> is <code>true</code>, if more than one operation<br>
is ready they will be tried in order.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">&gt;!</span> <span class="tok-nv">alts!</span><span class="tok-p">]])</span>
<span class="tok-p">(</span><span class="tok-nf">require-macros</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async.macros</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">go</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-nf">enable-console-print!</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">a-ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">another-ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">go</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Put a value on `a-ch`&quot;</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">&gt;!</span> <span class="tok-nv">a-ch</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;I&#39;m done!&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">go</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:b</span><span class="tok-p">]</span> <span class="tok-s">&quot;Put a value on `another-ch`&quot;</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">&gt;!</span> <span class="tok-nv">another-ch</span> <span class="tok-mi">99</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:b</span><span class="tok-p">]</span> <span class="tok-s">&quot;I&#39;m done!&quot;</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">go</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:c</span><span class="tok-p">]</span> <span class="tok-s">&quot;Gonna try taking from both channels with priority&quot;</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[[</span><span class="tok-nv">value</span> <span class="tok-nv">ch</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nf">alts!</span> <span class="tok-p">[</span><span class="tok-nv">a-ch</span> <span class="tok-nv">another-ch</span><span class="tok-p">]</span> <span class="tok-ss">:priority</span> <span class="tok-nv">true</span><span class="tok-p">)]</span>
    <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">ch</span> <span class="tok-nv">a-ch</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:c</span><span class="tok-p">]</span> <span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">value</span> <span class="tok-s">&quot;from `a-ch`&quot;</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:c</span><span class="tok-p">]</span> <span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">value</span> <span class="tok-s">&quot;from `another-ch`&quot;</span><span class="tok-p">))))</span>

<span class="tok-c1">;; [:a] Put a value on `a-ch`</span>
<span class="tok-c1">;; [:a] I&#39;m done!</span>
<span class="tok-c1">;; [:b] Put a value on `another-ch`</span>
<span class="tok-c1">;; [:b] I&#39;m done!</span>
<span class="tok-c1">;; [:c] Gonna try taking from both channels with priority</span>
<span class="tok-c1">;; [:c] Got 42 from `a-ch`</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Since both <code>a-ch</code> and <code>another-ch</code> had a value to read when the <code>alts!</code> was executed and<br>
we set the <code>:priority</code> option to true, <code>a-ch</code> has preference. You can try deleting the<br>
<code>:priority</code> option and running the example multiple times to see that, without priority,<br>
<code>alts!</code> makes a non-deterministic choice.</p>
</div>
</div>
<div class="sect4">
<h5 id="defaults"><a class="link" href="#defaults">Defaults</a></h5>
<div class="paragraph">
<p>Another interesting bit of <code>alts!</code> is that it can return immediately if no operation is<br>
ready and we provide a default value. We can conditionally do a choice on the operations<br>
if and only if any of them is ready, returning a default value if it&#8217;s not.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">alts!</span><span class="tok-p">]])</span>
<span class="tok-p">(</span><span class="tok-nf">require-macros</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async.macros</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">go</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">a-ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">another-ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">go</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Gonna try taking from any of the channels without blocking&quot;</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[[</span><span class="tok-nv">value</span> <span class="tok-nv">ch</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nf">alts!</span> <span class="tok-p">[</span><span class="tok-nv">a-ch</span> <span class="tok-nv">another-ch</span><span class="tok-p">]</span> <span class="tok-ss">:default</span> <span class="tok-ss">:not-ready</span><span class="tok-p">)]</span>
    <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">and </span><span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">value</span> <span class="tok-ss">:not-ready</span><span class="tok-p">)</span>
             <span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">ch</span> <span class="tok-ss">:default</span><span class="tok-p">))</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;No operation is ready, aborting&quot;</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">value</span><span class="tok-p">))))</span>

<span class="tok-c1">;; [:a] Gonna try taking from any of the channels without blocking</span>
<span class="tok-c1">;; [:a] No operation is ready, aborting</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see in the above example, if no operation is ready the value returned by<br>
<code>alts!</code> is the one we supplied after the <code>:default</code> key when calling it and the channel is<br>
the <code>:default</code> keyword itself.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="combinators"><a class="link" href="#combinators">6.2.3. Combinators</a></h4>
<div class="paragraph">
<p>Now that we&#8217;re acquainted with channels and processes it&#8217;s time to explore some interesting<br>
combinators for working with channels that are present in <code>core.async</code>. This section<br>
includes a brief description of all of them together with a simple example of their usage.</p>
</div>
<div class="sect4">
<h5 id="pipe"><a class="link" href="#pipe">pipe</a></h5>
<div class="paragraph">
<p><code>pipe</code> takes an input and output channels and pipes all the values put on the input channel<br>
to the output one. The output channel is closed whenever the source is closed unless we<br>
provide a <code>false</code> third argument:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">pipe</span> <span class="tok-nv">put!</span> <span class="tok-nv">&lt;!</span> <span class="tok-nv">close!</span><span class="tok-p">]])</span>
<span class="tok-p">(</span><span class="tok-nf">require-macros</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async.macros</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">go-loop</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">in</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">out</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">pipe</span> <span class="tok-nv">in</span> <span class="tok-nv">out</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-nf">go-loop</span> <span class="tok-p">[</span><span class="tok-nv">value</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">out</span><span class="tok-p">)]</span>
  <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">nil? </span><span class="tok-nv">value</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;I&#39;m done!&quot;</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nf">do</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">value</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Waiting for a value&quot;</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nf">recur</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">out</span><span class="tok-p">)))))</span>

<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>
<span class="tok-p">(</span><span class="tok-nf">close!</span> <span class="tok-nv">in</span><span class="tok-p">)</span>

<span class="tok-c1">;; [:a] Got 0</span>
<span class="tok-c1">;; [:a] Waiting for a value</span>
<span class="tok-c1">;; [:a] Got 1</span>
<span class="tok-c1">;; [:a] Waiting for a value</span>
<span class="tok-c1">;; [:a] I&#39;m done!</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example we used the <code>go-loop</code> macro for reading values recursively until the<br>
<code>out</code> channel is closed. Notice that when we close the <code>in</code> channel the <code>out</code> channel is<br>
closed too, making the <code>go-loop</code> terminate.</p>
</div>
</div>
<div class="sect4">
<h5 id="pipeline-async"><a class="link" href="#pipeline-async">pipeline-async</a></h5>
<div class="paragraph">
<p><code>pipeline-async</code> takes a number for controlling parallelism, an output channel, an<br>
asynchronous function and an input channel. The asynchronous function has two arguments:<br>
the value put in the input channel and a channel where it should put the result of its<br>
asynchronous operation, closing the result channel after finishing. The number controls<br>
the number of concurrent go blocks that will be used for calling the asynchronous function<br>
with the inputs.</p>
</div>
<div class="paragraph">
<p>The output channel will receive outputs in an order relative to the input channel,<br>
regardless the time each asynchronous function call takes to complete. It has an optional<br>
last parameter that controls whether the output channel will be closed when the input<br>
channel is closed, which defaults to <code>true</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">pipeline-async</span> <span class="tok-nv">put!</span> <span class="tok-nv">&lt;!</span> <span class="tok-nv">close!</span><span class="tok-p">]])</span>
<span class="tok-p">(</span><span class="tok-nf">require-macros</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async.macros</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">go-loop</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">in</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">out</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">parallelism</span> <span class="tok-mi">3</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">wait-and-put</span> <span class="tok-p">[</span><span class="tok-nv">value</span> <span class="tok-nv">ch</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">wait</span> <span class="tok-p">(</span><span class="tok-nb">rand-int </span><span class="tok-mi">1000</span><span class="tok-p">)]</span>
    <span class="tok-p">(</span><span class="tok-nf">js/setTimeout</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[]</span>
                     <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Waiting&quot;</span> <span class="tok-nv">wait</span> <span class="tok-s">&quot;miliseconds for value&quot;</span> <span class="tok-nv">value</span><span class="tok-p">)</span>
                     <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">ch</span> <span class="tok-nv">wait</span><span class="tok-p">)</span>
                     <span class="tok-p">(</span><span class="tok-nf">close!</span> <span class="tok-nv">ch</span><span class="tok-p">))</span>
                   <span class="tok-nv">wait</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">pipeline-async</span> <span class="tok-nv">parallelism</span> <span class="tok-nv">out</span> <span class="tok-nv">wait-and-put</span> <span class="tok-nv">in</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-nf">go-loop</span> <span class="tok-p">[</span><span class="tok-nv">value</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">out</span><span class="tok-p">)]</span>
  <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">nil? </span><span class="tok-nv">value</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;I&#39;m done!&quot;</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nf">do</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">value</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Waiting for a value&quot;</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nf">recur</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">out</span><span class="tok-p">)))))</span>

<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">close!</span> <span class="tok-nv">in</span><span class="tok-p">)</span>

<span class="tok-c1">;; Waiting 164 miliseconds for value 3</span>
<span class="tok-c1">;; Waiting 304 miliseconds for value 2</span>
<span class="tok-c1">;; Waiting 908 miliseconds for value 1</span>
<span class="tok-c1">;; [:a] Got 908</span>
<span class="tok-c1">;; [:a] Waiting for a value</span>
<span class="tok-c1">;; [:a] Got 304</span>
<span class="tok-c1">;; [:a] Waiting for a value</span>
<span class="tok-c1">;; [:a] Got 164</span>
<span class="tok-c1">;; [:a] Waiting for a value</span>
<span class="tok-c1">;; [:a] I&#39;m done!</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="pipeline"><a class="link" href="#pipeline">pipeline</a></h5>
<div class="paragraph">
<p><code>pipeline</code> is similar to <code>pipeline-async</code> but instead of taking and asynchronous function<br>
it takes a transducer instead. The transducer will be applied independently to each input.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">pipeline</span> <span class="tok-nv">put!</span> <span class="tok-nv">&lt;!</span> <span class="tok-nv">close!</span><span class="tok-p">]])</span>
<span class="tok-p">(</span><span class="tok-nf">require-macros</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async.macros</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">go-loop</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">in</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">out</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">parallelism</span> <span class="tok-mi">3</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-nf">pipeline</span> <span class="tok-nv">parallelism</span> <span class="tok-nv">out</span> <span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-nv">inc</span><span class="tok-p">)</span> <span class="tok-nv">in</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-nf">go-loop</span> <span class="tok-p">[</span><span class="tok-nv">value</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">out</span><span class="tok-p">)]</span>
  <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">nil? </span><span class="tok-nv">value</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;I&#39;m done!&quot;</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nf">do</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">value</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Waiting for a value&quot;</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nf">recur</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">out</span><span class="tok-p">)))))</span>

<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">close!</span> <span class="tok-nv">in</span><span class="tok-p">)</span>

<span class="tok-c1">;; [:a] Got 2</span>
<span class="tok-c1">;; [:a] Waiting for a value</span>
<span class="tok-c1">;; [:a] Got 3</span>
<span class="tok-c1">;; [:a] Waiting for a value</span>
<span class="tok-c1">;; [:a] Got 4</span>
<span class="tok-c1">;; [:a] Waiting for a value</span>
<span class="tok-c1">;; [:a] I&#39;m done!</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="split"><a class="link" href="#split">split</a></h5>
<div class="paragraph">
<p><code>split</code> takes a predicate and a channel and returns a vector with two channels, the first<br>
of which will receive the values for which the predicate is true, the second will receive<br>
those for which the predicate is false. We can optionally pass a buffer or number for the<br>
channels with the third (true channel) and fourth (false channel) arguments.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">split</span> <span class="tok-nv">put!</span> <span class="tok-nv">&lt;!</span> <span class="tok-nv">close!</span><span class="tok-p">]])</span>
<span class="tok-p">(</span><span class="tok-nf">require-macros</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async.macros</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">go-loop</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">in</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">chans</span> <span class="tok-p">(</span><span class="tok-nf">split</span> <span class="tok-nv">even?</span> <span class="tok-nv">in</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">even-ch</span> <span class="tok-p">(</span><span class="tok-nb">first </span><span class="tok-nv">chans</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">odd-ch</span> <span class="tok-p">(</span><span class="tok-nb">second </span><span class="tok-nv">chans</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">go-loop</span> <span class="tok-p">[</span><span class="tok-nv">value</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">even-ch</span><span class="tok-p">)]</span>
  <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">nil? </span><span class="tok-nv">value</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:evens</span><span class="tok-p">]</span> <span class="tok-s">&quot;I&#39;m done!&quot;</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nf">do</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:evens</span><span class="tok-p">]</span> <span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">value</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:evens</span><span class="tok-p">]</span> <span class="tok-s">&quot;Waiting for a value&quot;</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nf">recur</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">even-ch</span><span class="tok-p">)))))</span>

<span class="tok-p">(</span><span class="tok-nf">go-loop</span> <span class="tok-p">[</span><span class="tok-nv">value</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">odd-ch</span><span class="tok-p">)]</span>
  <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">nil? </span><span class="tok-nv">value</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:odds</span><span class="tok-p">]</span> <span class="tok-s">&quot;I&#39;m done!&quot;</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nf">do</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:odds</span><span class="tok-p">]</span> <span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">value</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:odds</span><span class="tok-p">]</span> <span class="tok-s">&quot;Waiting for a value&quot;</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nf">recur</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">odd-ch</span><span class="tok-p">)))))</span>

<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">close!</span> <span class="tok-nv">in</span><span class="tok-p">)</span>

<span class="tok-c1">;; [:evens] Got 0</span>
<span class="tok-c1">;; [:evens] Waiting for a value</span>
<span class="tok-c1">;; [:odds] Got 1</span>
<span class="tok-c1">;; [:odds] Waiting for a value</span>
<span class="tok-c1">;; [:odds] Got 3</span>
<span class="tok-c1">;; [:odds] Waiting for a value</span>
<span class="tok-c1">;; [:evens] Got 2</span>
<span class="tok-c1">;; [:evens] Waiting for a value</span>
<span class="tok-c1">;; [:evens] I&#39;m done!</span>
<span class="tok-c1">;; [:odds] I&#39;m done!</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="reduce"><a class="link" href="#reduce">reduce</a></h5>
<div class="paragraph">
<p><code>reduce</code> takes a reducing function, initial value and an input channel. It returns a<br>
channel with the result of reducing over all the values put on the input channel before<br>
closing it using the given initial value as the seed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:as</span> <span class="tok-nv">async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">put!</span> <span class="tok-nv">&lt;!</span> <span class="tok-nv">close!</span><span class="tok-p">]])</span>
<span class="tok-p">(</span><span class="tok-nf">require-macros</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async.macros</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">go</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">in</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">go</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Result&quot;</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-p">(</span><span class="tok-nf">async/reduce</span> <span class="tok-nb">+ </span><span class="tok-p">(</span><span class="tok-nf">+</span><span class="tok-p">)</span> <span class="tok-nv">in</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">close!</span> <span class="tok-nv">in</span><span class="tok-p">)</span>

<span class="tok-c1">;; Result: 6</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="onto-chan"><a class="link" href="#onto-chan">onto-chan</a></h5>
<div class="paragraph">
<p><code>onto-chan</code> takes a channel and a collection and puts the contents of the collection into<br>
the channel. It closes the channel after finishing although it accepts a third argument for<br>
specifying if it should close it or not. Let&#8217;s rewrite the <code>reduce</code> example using<br>
<code>onto-chan</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:as</span> <span class="tok-nv">async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">put!</span> <span class="tok-nv">&lt;!</span> <span class="tok-nv">close!</span> <span class="tok-nv">onto-chan</span><span class="tok-p">]])</span>
<span class="tok-p">(</span><span class="tok-nf">require-macros</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async.macros</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">go</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">in</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">go</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Result&quot;</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-p">(</span><span class="tok-nf">async/reduce</span> <span class="tok-nb">+ </span><span class="tok-p">(</span><span class="tok-nf">+</span><span class="tok-p">)</span> <span class="tok-nv">in</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-nf">onto-chan</span> <span class="tok-nv">in</span> <span class="tok-p">[</span><span class="tok-mi">0</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>

<span class="tok-c1">;; Result: 6</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="to-chan"><a class="link" href="#to-chan">to-chan</a></h5>
<div class="paragraph">
<p><code>to-chan</code> takes a collection and returns a channel where it will put every value in the<br>
collection, closing the channel afterwards.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">put!</span> <span class="tok-nv">&lt;!</span> <span class="tok-nv">close!</span> <span class="tok-nv">to-chan</span><span class="tok-p">]])</span>
<span class="tok-p">(</span><span class="tok-nf">require-macros</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async.macros</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">go-loop</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">ch</span> <span class="tok-p">(</span><span class="tok-nf">to-chan</span> <span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">3</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">go-loop</span> <span class="tok-p">[</span><span class="tok-nv">value</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">ch</span><span class="tok-p">)]</span>
  <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">nil? </span><span class="tok-nv">value</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;I&#39;m done!&quot;</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nf">do</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">value</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Waiting for a value&quot;</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nf">recur</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">ch</span><span class="tok-p">)))))</span>

<span class="tok-c1">;; [:a] Got 0</span>
<span class="tok-c1">;; [:a] Waiting for a value</span>
<span class="tok-c1">;; [:a] Got 1</span>
<span class="tok-c1">;; [:a] Waiting for a value</span>
<span class="tok-c1">;; [:a] Got 2</span>
<span class="tok-c1">;; [:a] Waiting for a value</span>
<span class="tok-c1">;; [:a] I&#39;m done!</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="merge"><a class="link" href="#merge">merge</a></h5>
<div class="paragraph">
<p><code>merge</code> takes a collection of input channels and returns a channel where it will put every<br>
value that is put on the input channels. The returned channel will be closed when all the<br>
input channels have been closed. The returned channel will be unbuffered by default but a<br>
number or buffer can be provided as the last argument.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">put!</span> <span class="tok-nv">&lt;!</span> <span class="tok-nv">close!</span> <span class="tok-nv">merge</span><span class="tok-p">]])</span>
<span class="tok-p">(</span><span class="tok-nf">require-macros</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async.macros</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">go-loop</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">in1</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">in2</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">in3</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">out</span> <span class="tok-p">(</span><span class="tok-nb">merge </span><span class="tok-p">[</span><span class="tok-nv">in1</span> <span class="tok-nv">in2</span> <span class="tok-nv">in3</span><span class="tok-p">]))</span>

<span class="tok-p">(</span><span class="tok-nf">go-loop</span> <span class="tok-p">[</span><span class="tok-nv">value</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">out</span><span class="tok-p">)]</span>
  <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">nil? </span><span class="tok-nv">value</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;I&#39;m done!&quot;</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nf">do</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">value</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Waiting for a value&quot;</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nf">recur</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">out</span><span class="tok-p">)))))</span>

<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in1</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">close!</span> <span class="tok-nv">in1</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in2</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">close!</span> <span class="tok-nv">in2</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in3</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">close!</span> <span class="tok-nv">in3</span><span class="tok-p">)</span>

<span class="tok-c1">;; [:a] Got 3</span>
<span class="tok-c1">;; [:a] Waiting for a value</span>
<span class="tok-c1">;; [:a] Got 2</span>
<span class="tok-c1">;; [:a] Waiting for a value</span>
<span class="tok-c1">;; [:a] Got 1</span>
<span class="tok-c1">;; [:a] Waiting for a value</span>
<span class="tok-c1">;; [:a] I&#39;m done!</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="higher-level-abstractions"><a class="link" href="#higher-level-abstractions">6.2.4. Higher-level abstractions</a></h4>
<div class="paragraph">
<p>We&#8217;ve learned the about the low-level primitives of <code>core.async</code> and the combinators that it offers<br>
for working with channels. <code>core.async</code> also offers some useful, higher-level abstractions on top of<br>
channels that can serve as building blocks for more advanced functionality.</p>
</div>
<div class="sect4">
<h5 id="mult"><a class="link" href="#mult">Mult</a></h5>
<div class="paragraph">
<p>Whenever we have a channel whose values have to be broadcasted to many others, we can use <code>mult</code> for<br>
creating a multiple of the supplied channel. Once we have a mult, we can attach channels to it using<br>
<code>tap</code> and dettach them using <code>untap</code>. Mults also support removing all tapped channels at once with<br>
<code>untap-all</code>.</p>
</div>
<div class="paragraph">
<p>Every value put in the source channel of a mult is broadcasted to all the tapped channels, and all of<br>
them must accept it before the next item is broadcasted. For preventing slow takers from blocking the<br>
mult&#8217;s values we must use buffering on the tapped channels judiciously.</p>
</div>
<div class="paragraph">
<p>Closed tapped channels are removed automatically from the mult. When putting a value in the source<br>
channels when there are still no taps such value will be dropped.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">put!</span> <span class="tok-nv">&lt;!</span> <span class="tok-nv">close!</span> <span class="tok-nv">timeout</span> <span class="tok-nv">mult</span> <span class="tok-nv">tap</span><span class="tok-p">]])</span>
<span class="tok-p">(</span><span class="tok-nf">require-macros</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async.macros</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">go-loop</span><span class="tok-p">]])</span>

<span class="tok-c1">;; Source channel and mult</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">in</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">m-in</span> <span class="tok-p">(</span><span class="tok-nf">mult</span> <span class="tok-nv">in</span><span class="tok-p">))</span>

<span class="tok-c1">;; Sink channels</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">a-ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">another-ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>

<span class="tok-c1">;; Taker for `a-ch`</span>
<span class="tok-p">(</span><span class="tok-nf">go-loop</span> <span class="tok-p">[</span><span class="tok-nv">value</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">a-ch</span><span class="tok-p">)]</span>
  <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">nil? </span><span class="tok-nv">value</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;I&#39;m done!&quot;</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nf">do</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">value</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nf">recur</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">a-ch</span><span class="tok-p">)))))</span>

<span class="tok-c1">;; Taker for `another-ch`, which sleeps for 3 seconds between takes</span>
<span class="tok-p">(</span><span class="tok-nf">go-loop</span> <span class="tok-p">[</span><span class="tok-nv">value</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">another-ch</span><span class="tok-p">)]</span>
  <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">nil? </span><span class="tok-nv">value</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:b</span><span class="tok-p">]</span> <span class="tok-s">&quot;I&#39;m done!&quot;</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nf">do</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:b</span><span class="tok-p">]</span> <span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">value</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:b</span><span class="tok-p">]</span> <span class="tok-s">&quot;Resting 3 seconds&quot;</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-p">(</span><span class="tok-nf">timeout</span> <span class="tok-mi">3000</span><span class="tok-p">))</span>
      <span class="tok-p">(</span><span class="tok-nf">recur</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">another-ch</span><span class="tok-p">)))))</span>

<span class="tok-c1">;; Tap the two channels to the mult</span>
<span class="tok-p">(</span><span class="tok-nf">tap</span> <span class="tok-nv">m-in</span> <span class="tok-nv">a-ch</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">tap</span> <span class="tok-nv">m-in</span> <span class="tok-nv">another-ch</span><span class="tok-p">)</span>

<span class="tok-c1">;; See how the values are delivered to `a-ch` and `another-ch`</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in</span> <span class="tok-mi">2</span><span class="tok-p">)</span>

<span class="tok-c1">;; [:a] Got 1</span>
<span class="tok-c1">;; [:b] Got 2</span>
<span class="tok-c1">;; [:b] Resting for 3 seconds</span>
<span class="tok-c1">;; [:a] Got 2</span>
<span class="tok-c1">;; [:b] Got 2</span>
<span class="tok-c1">;; [:b] Resting for 3 seconds</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="pub-sub"><a class="link" href="#pub-sub">Pub-sub</a></h5>
<div class="paragraph">
<p>After learning about mults you could imagine how to implement a pub-sub abstraction on top of <code>mult</code>, <code>tap</code> and<br>
<code>untap</code> but since it&#8217;s a widely used communication mechanism <code>core.async</code> already implements this functionality.<br>
Instead of creating a mult from a source channel, we create a publication with <code>pub</code> giving it a channel and a<br>
function that will be used for extracting the topic of the messages.</p>
</div>
<div class="paragraph">
<p>We can subscribe to a publication with <code>sub</code>, giving it the publication we want to subscribe to, the topic we<br>
are interested in and a channel to put the messages that have the given topic. Note that we can subscribe a<br>
channel to multiple topics.</p>
</div>
<div class="paragraph">
<p><code>unsub</code> can be given a publication, topic and channel for unsubscribing such channel from the topic.<br>
<code>unsub-all</code> can be given a publication and a topic to unsubscribe every channel from the given topic.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">put!</span> <span class="tok-nv">&lt;!</span> <span class="tok-nv">close!</span> <span class="tok-nv">pub</span> <span class="tok-nv">sub</span><span class="tok-p">]])</span>
<span class="tok-p">(</span><span class="tok-nf">require-macros</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async.macros</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">go-loop</span><span class="tok-p">]])</span>

<span class="tok-c1">;; Source channel and publication</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">in</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">publication</span> <span class="tok-p">(</span><span class="tok-nf">pub</span> <span class="tok-nv">in</span> <span class="tok-ss">:action</span><span class="tok-p">))</span>

<span class="tok-c1">;; Sink channels</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">a-ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">another-ch</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>

<span class="tok-c1">;; Channel with `:increment` action</span>
<span class="tok-p">(</span><span class="tok-nf">sub</span> <span class="tok-nv">publication</span> <span class="tok-ss">:increment</span> <span class="tok-nv">a-ch</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-nf">go-loop</span> <span class="tok-p">[</span><span class="tok-nv">value</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">a-ch</span><span class="tok-p">)]</span>
  <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">nil? </span><span class="tok-nv">value</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;I&#39;m done!&quot;</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nf">do</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Increment:&quot;</span> <span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-p">(</span><span class="tok-ss">:value</span> <span class="tok-nv">value</span><span class="tok-p">)))</span>
      <span class="tok-p">(</span><span class="tok-nf">recur</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">a-ch</span><span class="tok-p">)))))</span>

<span class="tok-c1">;; Channel with `:double` action</span>
<span class="tok-p">(</span><span class="tok-nf">sub</span> <span class="tok-nv">publication</span> <span class="tok-ss">:double</span> <span class="tok-nv">another-ch</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-nf">go-loop</span> <span class="tok-p">[</span><span class="tok-nv">value</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">another-ch</span><span class="tok-p">)]</span>
  <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">nil? </span><span class="tok-nv">value</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:b</span><span class="tok-p">]</span> <span class="tok-s">&quot;I&#39;m done!&quot;</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nf">do</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:b</span><span class="tok-p">]</span> <span class="tok-s">&quot;Double:&quot;</span> <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-mi">2</span> <span class="tok-p">(</span><span class="tok-ss">:value</span> <span class="tok-nv">value</span><span class="tok-p">)))</span>
      <span class="tok-p">(</span><span class="tok-nf">recur</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">another-ch</span><span class="tok-p">)))))</span>

<span class="tok-c1">;; See how values are delivered to `a-ch` and `another-ch` depending on their action</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in</span> <span class="tok-p">{</span><span class="tok-ss">:action</span> <span class="tok-ss">:increment</span> <span class="tok-ss">:value</span> <span class="tok-mi">98</span><span class="tok-p">})</span>
<span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in</span> <span class="tok-p">{</span><span class="tok-ss">:action</span> <span class="tok-ss">:double</span> <span class="tok-ss">:value</span> <span class="tok-mi">21</span><span class="tok-p">})</span>

<span class="tok-c1">;; [:a] Increment: 99</span>
<span class="tok-c1">;; [:b] Double: 42</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mixer"><a class="link" href="#mixer">Mixer</a></h5>
<div class="paragraph">
<p>As we learned in the section about <code>core.async</code> combinators, we can use the <code>merge</code> function for combining<br>
multiple channels into one. When merging multiple channels, every value put in the input channels will end up<br>
in the merged channel. However, we may want more finer-grained control over which values put in the input<br>
channels end up in the output channel, that&#8217;s where mixers come in handy.</p>
</div>
<div class="paragraph">
<p><code>core.async</code> gives us the mixer abstraction, which we can use to combine multiple input channnels into an output<br>
channel. The interesting part of the mixer is that we can mute, pause and listen exclusively to certain input<br>
channels.</p>
</div>
<div class="paragraph">
<p>We can create a mixer given an output channel with <code>mix</code>. Once we have a mixer we can add input channels into the<br>
mix using <code>admix</code>, remove it using <code>unmix</code> or remove every input channel with <code>unmix-all</code>.</p>
</div>
<div class="paragraph">
<p>For controlling the state of the input channel we use the <code>toggle</code> function giving it the mixer and a map from<br>
channels to their states. Note that we can add channels to the mix using <code>toggle</code>, since the map will be merged<br>
with the current state of the mix. The state of a channel is a map which can have the keys <code>:mute</code>, <code>:pause</code> and<br>
<code>:solo</code> mapped to a boolean.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see what muting, pausing and soloing channels means:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A muted input channel means that, while still taking values from it, they won&#8217;t be forwarded to the output channel.<br>
Thus, while a channel is muted, all the values put in it will be discarded.</p>
</li>
<li>
<p>A paused input channel means that no values will be taken from it. This means that values put in the channel won&#8217;t<br>
be forwarded to the output channel nor discarded.</p>
</li>
<li>
<p>When soloing one or more channels the output channel will only receive the values put in soloed channels. By default<br>
non-soloed channels are muted but we can use <code>solo-mode</code> to decide between muting or pausing non-soloed channels.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>That was a lot of information so let&#8217;s see an example to improve our understanding. First of all, we&#8217;ll set up a mixer<br>
with an <code>out</code> channel and add three input channels to the mix. After that, we&#8217;ll be printing all the values received<br>
on the <code>out</code> channel to illustrate the control over input channels:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">chan</span> <span class="tok-nv">put!</span> <span class="tok-nv">&lt;!</span> <span class="tok-nv">close!</span> <span class="tok-nv">mix</span> <span class="tok-nv">admix</span> <span class="tok-nv">unmix</span> <span class="tok-nv">toggle</span> <span class="tok-nv">solo-mode</span><span class="tok-p">]])</span>
<span class="tok-p">(</span><span class="tok-nf">require-macros</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cljs.core.async.macros</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">go-loop</span><span class="tok-p">]])</span>

<span class="tok-c1">;; Output channel and mixer</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">out</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">mixer</span> <span class="tok-p">(</span><span class="tok-nf">mix</span> <span class="tok-nv">out</span><span class="tok-p">))</span>

<span class="tok-c1">;; Input channels</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">in-1</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">in-2</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">in-3</span> <span class="tok-p">(</span><span class="tok-nf">chan</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">admix</span> <span class="tok-nv">mixer</span> <span class="tok-nv">in-1</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">admix</span> <span class="tok-nv">mixer</span> <span class="tok-nv">in-2</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">admix</span> <span class="tok-nv">mixer</span> <span class="tok-nv">in-3</span><span class="tok-p">)</span>

<span class="tok-c1">;; Let&#39;s listen to the `out` channel and print what we get from it</span>
<span class="tok-p">(</span><span class="tok-nf">go-loop</span> <span class="tok-p">[</span><span class="tok-nv">value</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">out</span><span class="tok-p">)]</span>
  <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">nil? </span><span class="tok-nv">value</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;I&#39;m done&quot;</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nf">do</span>
      <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">[</span><span class="tok-ss">:a</span><span class="tok-p">]</span> <span class="tok-s">&quot;Got&quot;</span> <span class="tok-nv">value</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nf">recur</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">out</span><span class="tok-p">)))))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>By default, every value put in the input channels will be put in the <code>out</code> channel:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">do</span>
  <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in-1</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in-2</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in-3</span> <span class="tok-mi">3</span><span class="tok-p">))</span>

<span class="tok-c1">;; [:a] Got 1</span>
<span class="tok-c1">;; [:a] Got 2</span>
<span class="tok-c1">;; [:a] Got 3</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s pause the <code>in-2</code> channel, put a value in every input channel and resume <code>in-2</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">toggle</span> <span class="tok-nv">mixer</span> <span class="tok-p">{</span><span class="tok-nv">in-2</span> <span class="tok-p">{</span><span class="tok-ss">:pause</span> <span class="tok-nv">true</span><span class="tok-p">}})</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nf">do</span>
  <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in-1</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in-2</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in-3</span> <span class="tok-mi">3</span><span class="tok-p">))</span>

<span class="tok-c1">;; [:a] Got 1</span>
<span class="tok-c1">;; [:a] Got 3</span>

<span class="tok-p">(</span><span class="tok-nf">toggle</span> <span class="tok-nv">mixer</span> <span class="tok-p">{</span><span class="tok-nv">in-2</span> <span class="tok-p">{</span><span class="tok-ss">:pause</span> <span class="tok-nv">false</span><span class="tok-p">}})</span>

<span class="tok-c1">;; [:a] Got 2</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see in the example above, the values put in the paused channels aren&#8217;t discarded.<br>
For discarding values put in an input channel we have to mute it, let&#8217;s see an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">toggle</span> <span class="tok-nv">mixer</span> <span class="tok-p">{</span><span class="tok-nv">in-2</span> <span class="tok-p">{</span><span class="tok-ss">:mute</span> <span class="tok-nv">true</span><span class="tok-p">}})</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nf">do</span>
  <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in-1</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in-2</span> <span class="tok-mi">2</span><span class="tok-p">)</span>  <span class="tok-c1">;; `out` will never get this value since it&#39;s discarded</span>
  <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in-3</span> <span class="tok-mi">3</span><span class="tok-p">))</span>

<span class="tok-c1">;; [:a] Got 1</span>
<span class="tok-c1">;; [:a] Got 3</span>

<span class="tok-p">(</span><span class="tok-nf">toggle</span> <span class="tok-nv">mixer</span> <span class="tok-p">{</span><span class="tok-nv">in-2</span> <span class="tok-p">{</span><span class="tok-ss">:mute</span> <span class="tok-nv">false</span><span class="tok-p">}})</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We put a value (<code>2</code>) in the <code>in-2</code> channel and, since the channel was muted at the time, the value<br>
is discarded and never put into <code>out</code>. Let&#8217;s look at the third state a channel can be inside a mixer:<br>
solo.</p>
</div>
<div class="paragraph">
<p>As we mentioned before, soloing channels of a mixer implies muting the rest of them by default:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">toggle</span> <span class="tok-nv">mixer</span> <span class="tok-p">{</span><span class="tok-nv">in-1</span> <span class="tok-p">{</span><span class="tok-ss">:solo</span> <span class="tok-nv">true</span><span class="tok-p">}</span>
               <span class="tok-nv">in-2</span> <span class="tok-p">{</span><span class="tok-ss">:solo</span> <span class="tok-nv">true</span><span class="tok-p">}})</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nf">do</span>
  <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in-1</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in-2</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in-3</span> <span class="tok-mi">3</span><span class="tok-p">))</span> <span class="tok-c1">;; `out` will never get this value since it&#39;s discarded</span>

<span class="tok-c1">;; [:a] Got 1</span>
<span class="tok-c1">;; [:a] Got 2</span>

<span class="tok-p">(</span><span class="tok-nf">toggle</span> <span class="tok-nv">mixer</span> <span class="tok-p">{</span><span class="tok-nv">in-1</span> <span class="tok-p">{</span><span class="tok-ss">:solo</span> <span class="tok-nv">false</span><span class="tok-p">}</span>
               <span class="tok-nv">in-2</span> <span class="tok-p">{</span><span class="tok-ss">:solo</span> <span class="tok-nv">false</span><span class="tok-p">}})</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>However, we can set the mode the non-soloed channels will be in while there are soloed channels.<br>
Let&#8217;s set the default non-solo mode to pause instead of the default mute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">solo-mode</span> <span class="tok-nv">mixer</span> <span class="tok-ss">:pause</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>
<span class="tok-p">(</span><span class="tok-nf">toggle</span> <span class="tok-nv">mixer</span> <span class="tok-p">{</span><span class="tok-nv">in-1</span> <span class="tok-p">{</span><span class="tok-ss">:solo</span> <span class="tok-nv">true</span><span class="tok-p">}</span>
               <span class="tok-nv">in-2</span> <span class="tok-p">{</span><span class="tok-ss">:solo</span> <span class="tok-nv">true</span><span class="tok-p">}})</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nf">do</span>
  <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in-1</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in-2</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">put!</span> <span class="tok-nv">in-3</span> <span class="tok-mi">3</span><span class="tok-p">))</span>

<span class="tok-c1">;; [:a] Got 1</span>
<span class="tok-c1">;; [:a] Got 2</span>

<span class="tok-p">(</span><span class="tok-nf">toggle</span> <span class="tok-nv">mixer</span> <span class="tok-p">{</span><span class="tok-nv">in-1</span> <span class="tok-p">{</span><span class="tok-ss">:solo</span> <span class="tok-nv">false</span><span class="tok-p">}</span>
               <span class="tok-nv">in-2</span> <span class="tok-p">{</span><span class="tok-ss">:solo</span> <span class="tok-nv">false</span><span class="tok-p">}})</span>

<span class="tok-c1">;; [:a] Got 3</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="appendix-c-setting-up-a-clojurescript-development-environment"><a class="link" href="#appendix-c-setting-up-a-clojurescript-development-environment">6.3. Appendix C: Setting up a ClojureScript development environment</a></h3>
<div class="sect3">
<h4 id="cursive"><a class="link" href="#cursive">6.3.1. Cursive</a></h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect3">
<h4 id="emacs"><a class="link" href="#emacs">6.3.2. Emacs</a></h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect3">
<h4 id="vim"><a class="link" href="#vim">6.3.3. Vim</a></h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="acknowledgments"><a class="link" href="#acknowledgments">7. Acknowledgments</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Special thanks to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>J David Eisenberg</strong>: For the huge amount of time spend in fixing all kind of errors and<br>
writing entire sections of the book, as well as making very valuable suggestions.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>And here is an inevitably incomplete list of MUCH-APPRECIATED CONTRIBUTORS&#8201;&#8212;&#8201;people who have submitted corrections, new ideas and generally made the<br>
<em>ClojureScript Unraveled</em> book much better:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Anler Hernández Peral (@anler)</p>
</li>
<li>
<p>Diego Sevilla Ruiz (@dsevilla)</p>
</li>
<li>
<p>Eduardo Ferro Aldama (@eferro)</p>
</li>
<li>
<p>Tyler Anderson (@Tyler-Anderson)</p>
</li>
<li>
<p>Chris Ulrich (@chrisulrich)</p>
</li>
<li>
<p>Jean Hadrien Chabran (@jhchabran)</p>
</li>
<li>
<p>Tienson Qin (@tiensonqin)</p>
</li>
<li>
<p>FungusHumungus (@FungusHumungus),</p>
</li>
<li>
<p>Chris Charles (@ccharles)</p>
</li>
<li>
<p>Jearvon Dharrie (@iamjarvo)</p>
</li>
<li>
<p>Shaun LeBron (@shaunlebron)</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="further-reading"><a class="link" href="#further-reading">8. Further Reading</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Here is a list of more resources about ClojureScript.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/clojure/clojurescript/wiki">ClojureScript wiki</a>: a community-mantained wiki about ClojureScript.</p>
</li>
<li>
<p><a href="https://github.com/cljsinfo/cljs-api-docs/blob/catalog/INDEX.md">API Reference</a>: a community-maintained complete language api reference.</p>
</li>
<li>
<p><a href="http://cljs.info/cheatsheet/">ClojureScript Cheatsheet</a>: a comprehensive reference of the ClojureScript language.</p>
</li>
<li>
<p><a href="http://catcode.com/etudes-for-clojurescript/toc01.html">Études for ClojureScript</a>: a collection of exercises for learning ClojureScript.</p>
</li>
<li>
<p><a href="http://clojurescriptmadeeasy.com/">ClojureScript made easy</a>: a collection of short articles about solving common problems in ClojureScript.</p>
</li>
<li>
<p><a href="http://google.github.io/closure-library/api/">The Google Closure Library API reference</a></p>
</li>
</ul>
</div>
</div>
</div>
    </article>

  </div>
</div>


      <footer class="site-footer">

  <div class="wrapper">

    <hr>

    <div class="community-note">
      <i class="fa fa-tree"></i>
      website created by the community.<br>
      <a class="acknowledgements-link" href="/acknowledgements">acknowledgements</a>
    </div>

    <div class="cljs-legal">
      ClojureScript is licensed <a href="http://opensource.org/licenses/eclipse-1.0.php">EPL 1.0</a><br>
      Copyright © Rich Hickey
    </div>
  </div>
</footer>


    </div>
  </body>

</html>
